package plugin

import (
	"errors"
	"io"
	"log"
	"os"
	"path"
	"strings"

	"github.com/golang/protobuf/proto"
	plugingo "github.com/golang/protobuf/protoc-gen-go/plugin"
	"google.golang.org/protobuf/types/descriptorpb"
)

// ErrUnsupportedProvider is returned when the provider is not supported.
var ErrUnsupportedProvider = errors.New("unsupported provider")

// Templater is an interface for generating templates.
type Templater interface {
	BuildTemplate() string
	Imports() ImportSet
}

// Provider represents the database provider.
type Provider string

// String returns the provider as a string.
func (p Provider) String() string {
	return string(p)
}

// Available providers.
var (
	ProviderMysql    Provider = "mysql"
	ProviderPostgres Provider = "postgres"
	ProviderSqlite   Provider = "sqlite"
)

// PathType is a type for how to generate output filenames.
type PathType int

// Available path types.
const (
	PathTypeImport PathType = iota
	PathTypeSourceRelative
)

const GeneratedFilePostfix = ".db.go"

// Plugin handles generation of code based on protobufs.
type Plugin struct {
	req *plugingo.CodeGeneratorRequest
	res *plugingo.CodeGeneratorResponse

	pathType PathType
	provider Provider
	state    *State

	Param              map[string]string
	PackageName        string
	FileNameWithoutExt string
}

// NewPlugin creates a new Plugin.
func NewPlugin() *Plugin {
	return &Plugin{
		req: &plugingo.CodeGeneratorRequest{},
		res: &plugingo.CodeGeneratorResponse{},
	}
}

// Run handles the input/output of the plugin.
// It reads the request from stdin and writes the response to stdout.
func (p *Plugin) Run() {
	data, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read from stdin: %v", err)
	}

	if err := proto.Unmarshal(data, p.req); err != nil {
		log.Fatalf("Failed to unmarshal protobuf: %v", err)
	}

	if len(p.getUserProtoFiles()) == 0 {
		log.Fatalf("No proto file is supported: %d", len(p.getUserProtoFiles()))
	}

	// only one proto file is supported
	if len(p.getUserProtoFiles()) > 1 {
		log.Fatalf("Only one proto file is supported: %d", len(p.getUserProtoFiles()))
	}

	// fill default state
	//
	p.state = p.fillState()
	{
		p.FileNameWithoutExt = p.state.FileName
		p.PackageName = p.state.PackageName
		p.provider = p.state.Provider
	}

	// fill relations map in state struct
	//		- field name
	//		- reference name
	//		- table name
	//		- struct name
	//		- store name
	//		- many
	p.state = p.fillRelation(p.state)

	// parse command line parameters
	//
	p.parseCommandLineParameters(p.req.GetParameter())

	// tables is a slice of Templater interface
	// it contains all the tables that will be generated
	tables, err := p.getTemplaterTables()
	if err != nil {
		log.Fatalf("Failed to parse protobuf: %v", err)
	}

	// fill imports
	//
	// 	- import "database/sql"
	// 	- import "github.com/lib/pq"
	// 	- import "github.com/Masterminds/squirrel"
	// 	- import "context"
	// 	- import "errors"
	// 	- import "fmt"
	// 	- import "strings"
	//
	p.state.FillImports(tables)

	// generate content
	// 	- package name
	// 	- imports
	// 	- tables
	// 	- conditions
	// 	- init function
	//
	content := p.generateContent(tables)
	{
		generatedFileName := p.getGeneratedFilePath(p.req.GetFileToGenerate()[0])
		p.res.File = append(p.res.File, &plugingo.CodeGeneratorResponse_File{
			Name:    proto.String(generatedFileName),
			Content: proto.String(content),
		})
	}

	// format Go code and marshal protobuf
	//
	if err := goFmt(p.res); err != nil {
		log.Fatalf("Failed to format Go code: %v", err)
	}

	// marshal protobuf and write to stdout
	// 	- generated file name
	// 	- generated file content
	//
	data, err = proto.Marshal(p.res)
	if err != nil {
		log.Fatalf("Failed to marshal protobuf: %v", err)
	}

	// write to stdout
	if _, err := os.Stdout.Write(data); err != nil {
		log.Fatalf("Failed to write to stdout: %v", err)
	}
}

// generateContent generates the string content for the output.
func (p *Plugin) generateContent(tables []Templater) string {
	builder := &strings.Builder{}

	builder.WriteString("// Code generated by protoc-gen-structify. DO NOT EDIT.\n")
	builder.WriteString("// source: ")
	builder.WriteString(p.req.GetFileToGenerate()[0] + "\n")
	builder.WriteString("// provider: ")
	builder.WriteString(p.provider.String() + "\n")

	conditions := p.BuildConditionsTemplate()
	inits := p.BuildInitFunctionTemplate()

	// write package name
	builder.WriteString("package " + p.PackageName + "\n\n")

	// write imports
	builder.WriteString(p.state.Imports.String())
	builder.WriteString(inits + "\n")

	// write tables
	for _, t := range tables {
		builder.WriteString(t.BuildTemplate())
		builder.WriteString("\n")
	}

	builder.WriteString(conditions + "\n")

	return builder.String()
}

// parseCommandLineParameters parses the command line parameters into the Param map.
func (p *Plugin) parseCommandLineParameters(parameter string) {
	p.Param = make(map[string]string)
	params := strings.Split(parameter, ",")
	for _, param := range params {
		if i := strings.Index(param, "="); i < 0 {
			p.Param[param] = ""
		} else {
			p.Param[param[:i]] = param[i+1:]
		}
	}
	p.parsePathType()
}

// parsePathType parses the path type from the parameters.
func (p *Plugin) parsePathType() {
	switch p.Param["paths"] {
	case "import":
		p.pathType = PathTypeImport
	case "source_relative":
		p.pathType = PathTypeSourceRelative
	default:
		log.Fatalf(`Unknown path type %q: want "import" or "source_relative".`, p.Param["paths"])
	}
}

// fillState fills the state with default values.
func (p *Plugin) fillState() *State {
	protoFile := p.getUserProtoFile()

	return &State{
		Provider:    p.parseProvider(),
		PackageName: protoFile.GetPackage(),
		FileName:    p.parseFileName(),
		Imports:     map[Import]bool{},
	}
}

func (p *Plugin) parseFileName() string {
	fileBase := path.Base(p.req.GetFileToGenerate()[0])
	fileExt := path.Ext(fileBase)
	return strings.TrimSuffix(fileBase, fileExt)
}

// parsePackageName parses the package name from the protobuf options.
func (p *Plugin) parsePackageName() {
	for _, f := range p.getUserProtoFiles() {
		p.PackageName = f.GetPackage()
	}
}

// getGeneratedFilePath gets the generated file path based on the source file path.
func (p *Plugin) getGeneratedFilePath(sourceFilePath string) string {
	generatedBaseName := p.FileNameWithoutExt + GeneratedFilePostfix

	if p.pathType == PathTypeSourceRelative {
		// The generated file will have the same base as the source file, and it will be located in the same directory.
		fileDir := path.Dir(sourceFilePath)
		return path.Join(fileDir, generatedBaseName)
	}

	// If the path type is not source-relative, the generated file will have the same base as the source file,
	// but it will be located in the current directory.
	return generatedBaseName
}

// parseProvider parses the provider from the protobuf options.
func (p *Plugin) parseProvider() Provider {
	protoFile := p.getUserProtoFile()
	opts := getDBOptions(protoFile)
	if opts != nil {
		switch opts.GetProvider() {
		case "mysql":
			return ProviderMysql
		case "postgres":
			return ProviderPostgres
		case "sqlite":
			return ProviderSqlite
		default:
			return ProviderPostgres
		}
	}
	return ProviderPostgres
}

// getTemplaterTables parses the proto file and returns a slice of Tables.
func (p *Plugin) getTemplaterTables() ([]Templater, error) {
	var tables []Templater

	for _, m := range getMessages(p.req) {
		var table Templater
		switch p.provider {
		case ProviderPostgres:
			p.state.Imports.Enable(ImportErrors, ImportContext)
			table = createNewPostgresTableTemplate(m, p.state)
		case ProviderMysql:
			// todo: implement
		default:
			return nil, ErrUnsupportedProvider
		}

		tables = append(tables, table)
	}

	return tables, nil
}

// getUserProtoFiles returns the user proto files.
func (p *Plugin) getUserProtoFiles() []*descriptorpb.FileDescriptorProto {
	var userProtoFiles []*descriptorpb.FileDescriptorProto
	filesToGenerate := make(map[string]bool)
	for _, fileName := range p.req.GetFileToGenerate() {
		filesToGenerate[fileName] = true
	}

	for _, protoFile := range p.req.GetProtoFile() {
		if _, ok := filesToGenerate[*protoFile.Name]; ok {
			userProtoFiles = append(userProtoFiles, protoFile)
		}
	}

	return userProtoFiles
}

// getUserProtoFile returns the first user proto file.
func (p *Plugin) getUserProtoFile() *descriptorpb.FileDescriptorProto {
	return p.getUserProtoFiles()[0]
}

// fillRelation fills the relations map in the state struct.
func (p *Plugin) fillRelation(state *State) *State {
	protoFile := p.getUserProtoFile()
	state.Relations = make(map[string]*Relation)

	for _, msg := range protoFile.GetMessageType() {
		for _, field := range msg.GetField() {
			if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				convertedType := convertType(field)

				relation := &Relation{
					Field:      detectField(detectStructName(convertedType)),
					Reference:  detectReference(msg.GetName()),
					TableName:  detectTableName(convertedType),  // Assuming msg.GetName() is the table name
					StructName: detectStructName(convertedType), // Assuming field.GetName() is the struct name
					Store:      detectStoreName(convertedType),  // Fill this with the proper value
					Many:       detectMany(convertedType),       // As the field is repeated, it means there are many relations
				}

				options := getFieldOptions(field)
				if options != nil {
					relOptions := options.GetRelation()
					if relOptions != nil {
						relation.Field = relOptions.GetField()
						relation.Reference = relOptions.GetReference()
					}
				}

				// Add the relation to the map of relations
				state.Relations[msg.GetName()+"::"+relation.StructName] = relation
			}
		}
	}

	for _, msg := range protoFile.GetMessageType() {
		for _, field := range msg.GetField() {
			if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				convertedType := convertType(field)
				structName := detectStructName(convertedType)
				if v, ok := state.Relations[structName+"::"+msg.GetName()]; ok {
					state.Relations[msg.GetName()+"::"+structName].Field = v.Reference
					state.Relations[msg.GetName()+"::"+structName].Reference = v.Field
				}
			}
		}
	}

	return state
}
