package plugin

import (
	"errors"
	"io"
	"log"
	"os"
	"strings"

	"github.com/golang/protobuf/proto"
	plugingo "github.com/golang/protobuf/protoc-gen-go/plugin"
)

// ErrUnsupportedProvider is returned when the provider is not supported.
var ErrUnsupportedProvider = errors.New("unsupported provider")

// Templater is an interface for generating templates.
type Templater interface {
	BuildTemplate() string
}

// Provider represents the database provider.
type Provider string

// String returns the provider as a string.
func (p Provider) String() string {
	return string(p)
}

// Available providers.
var (
	ProviderMysql    Provider = "mysql"
	ProviderPostgres Provider = "postgres"
	ProviderSqlite   Provider = "sqlite"
)

// PathType is a type for how to generate output filenames.
type PathType int

// Available path types.
const (
	PathTypeImport PathType = iota
	PathTypeSourceRelative
)

const GeneratedFilePostfix = ".db.go"

// Plugin handles generation of code based on protobufs.
type Plugin struct {
	req      *plugingo.CodeGeneratorRequest
	res      *plugingo.CodeGeneratorResponse
	Param    map[string]string
	pathType PathType
	provider Provider
}

// NewPlugin creates a new Plugin.
func NewPlugin() *Plugin {
	return &Plugin{
		req: &plugingo.CodeGeneratorRequest{},
		res: &plugingo.CodeGeneratorResponse{},
	}
}

// Run handles the input/output of the plugin.
func (p *Plugin) Run() {
	data, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read from stdin: %v", err)
	}

	if err := proto.Unmarshal(data, p.req); err != nil {
		log.Fatalf("Failed to unmarshal protobuf: %v", err)
	}

	p.parseCommandLineParameters(p.req.GetParameter())
	p.fillDefaultOptions()

	tables, err := p.getTemplaterTables()
	if err != nil {
		log.Fatalf("Failed to parse protobuf: %v", err)
	}

	content := p.generateContent(tables)
	{
		p.res.File = append(p.res.File, &plugingo.CodeGeneratorResponse_File{
			Name:    proto.String("pro" + GeneratedFilePostfix),
			Content: proto.String(content),
		})
	}

	if err := goFmt(p.res); err != nil {
		log.Fatalf("Failed to format Go code: %v", err)
	}

	data, err = proto.Marshal(p.res)
	if err != nil {
		log.Fatalf("Failed to marshal protobuf: %v", err)
	}

	if _, err := os.Stdout.Write(data); err != nil {
		log.Fatalf("Failed to write to stdout: %v", err)
	}
}

// generateContent generates the string content for the output.
func (p *Plugin) generateContent(tables []Templater) string {
	builder := &strings.Builder{}
	builder.WriteString("// Code generated by protoc-gen-structify. DO NOT EDIT.\n")
	builder.WriteString("// source: ")
	builder.WriteString(p.req.GetFileToGenerate()[0] + "\n")
	builder.WriteString("// provider: ")
	builder.WriteString(p.provider.String() + "\n")
	builder.WriteString("package main\n\n")

	// todo: add imports

	// todo: add init function

	// add tables
	for _, t := range tables {
		builder.WriteString(t.BuildTemplate())
		builder.WriteString("\n")
	}

	// todo: add helper functions

	return builder.String()
}

// parseCommandLineParameters parses the command line parameters into the Param map.
func (p *Plugin) parseCommandLineParameters(parameter string) {
	p.Param = make(map[string]string)
	params := strings.Split(parameter, ",")
	for _, param := range params {
		if i := strings.Index(param, "="); i < 0 {
			p.Param[param] = ""
		} else {
			p.Param[param[:i]] = param[i+1:]
		}
	}
	p.parsePathType()
}

// parsePathType parses the path type from the parameters.
func (p *Plugin) parsePathType() {
	switch p.Param["paths"] {
	case "import":
		p.pathType = PathTypeImport
	case "source_relative":
		p.pathType = PathTypeSourceRelative
	default:
		log.Fatalf(`Unknown path type %q: want "import" or "source_relative".`, p.Param["paths"])
	}
}

// fillDefaultOptions fills the default options based on the protobuf.
func (p *Plugin) fillDefaultOptions() {
	p.parseProvider()
}

// parseProvider parses the provider from the protobuf options.
func (p *Plugin) parseProvider() {
	for _, f := range p.req.GetProtoFile() {
		opts := getDBOptions(f)
		if opts != nil {
			switch opts.GetProvider() {
			case "mysql":
				p.provider = ProviderMysql
			case "postgres":
				p.provider = ProviderPostgres
			case "sqlite":
				p.provider = ProviderSqlite
			default:
				p.provider = ProviderPostgres
			}
		}
	}
}

// getTemplaterTables parses the proto file and returns a slice of Tables.
func (p *Plugin) getTemplaterTables() ([]Templater, error) {
	var tables []Templater

	for _, m := range getMessages(p.req) {
		var table Templater
		switch p.provider {
		case ProviderPostgres:
			table = newPostgresTable(m)
		case ProviderMysql:
			// todo: implement
		default:
			return nil, ErrUnsupportedProvider
		}

		tables = append(tables, table)
	}

	return tables, nil
}
