package plugin

import (
	"errors"
	"io"
	"log"
	"os"
	"path"
	"strings"

	"github.com/golang/protobuf/proto"
	plugingo "github.com/golang/protobuf/protoc-gen-go/plugin"
)

// ErrUnsupportedProvider is returned when the provider is not supported.
var ErrUnsupportedProvider = errors.New("unsupported provider")

// Templater is an interface for generating templates.
type Templater interface {
	BuildTemplate() string
	Imports() map[Import]bool
}

// Provider represents the database provider.
type Provider string

// String returns the provider as a string.
func (p Provider) String() string {
	return string(p)
}

// Available providers.
var (
	ProviderMysql    Provider = "mysql"
	ProviderPostgres Provider = "postgres"
	ProviderSqlite   Provider = "sqlite"
)

// PathType is a type for how to generate output filenames.
type PathType int

// Available path types.
const (
	PathTypeImport PathType = iota
	PathTypeSourceRelative
)

const GeneratedFilePostfix = ".db.go"

// Plugin handles generation of code based on protobufs.
type Plugin struct {
	req         *plugingo.CodeGeneratorRequest
	res         *plugingo.CodeGeneratorResponse
	Param       map[string]string
	packageName string
	pathType    PathType
	provider    Provider

	imports []Import
}

// NewPlugin creates a new Plugin.
func NewPlugin() *Plugin {
	return &Plugin{
		req: &plugingo.CodeGeneratorRequest{},
		res: &plugingo.CodeGeneratorResponse{},
	}
}

// Run handles the input/output of the plugin.
func (p *Plugin) Run() {
	data, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read from stdin: %v", err)
	}

	if err := proto.Unmarshal(data, p.req); err != nil {
		log.Fatalf("Failed to unmarshal protobuf: %v", err)
	}

	p.parseCommandLineParameters(p.req.GetParameter())
	p.fillDefaultOptions()

	tables, err := p.getTemplaterTables()
	if err != nil {
		log.Fatalf("Failed to parse protobuf: %v", err)
	}

	content := p.generateContent(tables)
	{
		generatedFileName := p.getGeneratedFilePath(p.req.GetFileToGenerate()[0])
		p.res.File = append(p.res.File, &plugingo.CodeGeneratorResponse_File{
			Name:    proto.String(generatedFileName),
			Content: proto.String(content),
		})
	}

	if err := goFmt(p.res); err != nil {
		log.Fatalf("Failed to format Go code: %v", err)
	}

	data, err = proto.Marshal(p.res)
	if err != nil {
		log.Fatalf("Failed to marshal protobuf: %v", err)
	}

	if _, err := os.Stdout.Write(data); err != nil {
		log.Fatalf("Failed to write to stdout: %v", err)
	}
}

// generateContent generates the string content for the output.
func (p *Plugin) generateContent(tables []Templater) string {
	builder := &strings.Builder{}

	builder.WriteString("// Code generated by protoc-gen-structify. DO NOT EDIT.\n")
	builder.WriteString("// source: ")
	builder.WriteString(p.req.GetFileToGenerate()[0] + "\n")
	builder.WriteString("// provider: ")
	builder.WriteString(p.provider.String() + "\n")

	// write package name
	builder.WriteString("package " + p.packageName + "\n\n")

	// write tables to builder
	writeTable := func() {
		for _, t := range tables {
			builder.WriteString(t.BuildTemplate())
			builder.WriteString("\n")

			// add active imports
			for i, v := range t.Imports() {
				if v {
					p.imports = append(p.imports, i)
				}
			}
		}
	}

	// write imports
	for _, i := range p.imports {
		builder.WriteString("import " + i.String() + "\n")
	}

	// todo: add init function

	// write tables
	writeTable()

	return builder.String()
}

// parseCommandLineParameters parses the command line parameters into the Param map.
func (p *Plugin) parseCommandLineParameters(parameter string) {
	p.Param = make(map[string]string)
	params := strings.Split(parameter, ",")
	for _, param := range params {
		if i := strings.Index(param, "="); i < 0 {
			p.Param[param] = ""
		} else {
			p.Param[param[:i]] = param[i+1:]
		}
	}
	p.parsePathType()
}

// parsePathType parses the path type from the parameters.
func (p *Plugin) parsePathType() {
	switch p.Param["paths"] {
	case "import":
		p.pathType = PathTypeImport
	case "source_relative":
		p.pathType = PathTypeSourceRelative
	default:
		log.Fatalf(`Unknown path type %q: want "import" or "source_relative".`, p.Param["paths"])
	}
}

// fillDefaultOptions fills the default options based on the protobuf.
func (p *Plugin) fillDefaultOptions() {
	p.parseProvider()
	p.parsePackageName()
}

// parsePackageName parses the package name from the protobuf options.
func (p *Plugin) parsePackageName() {
	for _, f := range p.req.GetProtoFile() {
		p.packageName = f.GetPackage()
	}
}

// getGeneratedFilePath gets the generated file path based on the source file path.
func (p *Plugin) getGeneratedFilePath(sourceFilePath string) string {
	fileBase := path.Base(sourceFilePath)
	fileExt := path.Ext(fileBase)
	fileNameWithoutExt := strings.TrimSuffix(fileBase, fileExt)
	generatedBaseName := fileNameWithoutExt + GeneratedFilePostfix

	if p.pathType == PathTypeSourceRelative {
		// The generated file will have the same base as the source file, and it will be located in the same directory.
		fileDir := path.Dir(sourceFilePath)
		return path.Join(fileDir, generatedBaseName)
	}

	// If the path type is not source-relative, the generated file will have the same base as the source file,
	// but it will be located in the current directory.
	return generatedBaseName
}

// parseProvider parses the provider from the protobuf options.
func (p *Plugin) parseProvider() {
	for _, f := range p.req.GetProtoFile() {
		opts := getDBOptions(f)
		if opts != nil {
			switch opts.GetProvider() {
			case "mysql":
				p.provider = ProviderMysql
			case "postgres":
				p.provider = ProviderPostgres
			case "sqlite":
				p.provider = ProviderSqlite
			default:
				p.provider = ProviderPostgres
			}
		}
	}
}

// getTemplaterTables parses the proto file and returns a slice of Tables.
func (p *Plugin) getTemplaterTables() ([]Templater, error) {
	var tables []Templater

	for _, m := range getMessages(p.req) {
		var table Templater
		switch p.provider {
		case ProviderPostgres:
			table = newPostgresTable(m)
		case ProviderMysql:
			// todo: implement
		default:
			return nil, ErrUnsupportedProvider
		}

		tables = append(tables, table)
	}

	return tables, nil
}
