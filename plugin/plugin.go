package plugin

import (
	"errors"
	"io"
	"log"
	"os"
	"path"
	"strings"

	"github.com/golang/protobuf/proto"
	plugingo "github.com/golang/protobuf/protoc-gen-go/plugin"
)

// ErrUnsupportedProvider is returned when the provider is not supported.
var ErrUnsupportedProvider = errors.New("unsupported provider")

// Templater is an interface for generating templates.
type Templater interface {
	BuildTemplate() string
	Imports() ImportSet
}

// Provider represents the database provider.
type Provider string

// String returns the provider as a string.
func (p Provider) String() string {
	return string(p)
}

// Available providers.
var (
	ProviderMysql    Provider = "mysql"
	ProviderPostgres Provider = "postgres"
	ProviderSqlite   Provider = "sqlite"
)

// PathType is a type for how to generate output filenames.
type PathType int

// Available path types.
const (
	PathTypeImport PathType = iota
	PathTypeSourceRelative
)

const GeneratedFilePostfix = ".db.go"

// Plugin handles generation of code based on protobufs.
type Plugin struct {
	req *plugingo.CodeGeneratorRequest
	res *plugingo.CodeGeneratorResponse

	pathType PathType
	provider Provider
	imports  ImportSet

	Param              map[string]string
	PackageName        string
	FileNameWithoutExt string
}

// NewPlugin creates a new Plugin.
func NewPlugin() *Plugin {
	return &Plugin{
		req:     &plugingo.CodeGeneratorRequest{},
		res:     &plugingo.CodeGeneratorResponse{},
		imports: ImportSet{},
	}
}

// Run handles the input/output of the plugin.
func (p *Plugin) Run() {
	data, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read from stdin: %v", err)
	}

	if err := proto.Unmarshal(data, p.req); err != nil {
		log.Fatalf("Failed to unmarshal protobuf: %v", err)
	}

	p.parseCommandLineParameters(p.req.GetParameter())
	p.fillDefaultOptions()

	tables, err := p.getTemplaterTables()
	if err != nil {
		log.Fatalf("Failed to parse protobuf: %v", err)
	}

	// fill imports
	p.fillImports(tables)

	content := p.generateContent(tables)
	{
		generatedFileName := p.getGeneratedFilePath(p.req.GetFileToGenerate()[0])
		p.res.File = append(p.res.File, &plugingo.CodeGeneratorResponse_File{
			Name:    proto.String(generatedFileName),
			Content: proto.String(content),
		})
	}

	if err := goFmt(p.res); err != nil {
		log.Fatalf("Failed to format Go code: %v", err)
	}

	data, err = proto.Marshal(p.res)
	if err != nil {
		log.Fatalf("Failed to marshal protobuf: %v", err)
	}

	if _, err := os.Stdout.Write(data); err != nil {
		log.Fatalf("Failed to write to stdout: %v", err)
	}
}

// generateContent generates the string content for the output.
func (p *Plugin) generateContent(tables []Templater) string {
	builder := &strings.Builder{}

	builder.WriteString("// Code generated by protoc-gen-structify. DO NOT EDIT.\n")
	builder.WriteString("// source: ")
	builder.WriteString(p.req.GetFileToGenerate()[0] + "\n")
	builder.WriteString("// provider: ")
	builder.WriteString(p.provider.String() + "\n")

	conditions := p.BuildConditionsTemplate()
	inits := p.BuildInitFunctionTemplate()

	// write package name
	builder.WriteString("package " + p.PackageName + "\n\n")

	// write imports
	builder.WriteString(p.imports.String())
	builder.WriteString(inits + "\n")

	// write tables
	for _, t := range tables {
		builder.WriteString(t.BuildTemplate())
		builder.WriteString("\n")
	}

	builder.WriteString(conditions + "\n")

	return builder.String()
}

// parseCommandLineParameters parses the command line parameters into the Param map.
func (p *Plugin) parseCommandLineParameters(parameter string) {
	p.Param = make(map[string]string)
	params := strings.Split(parameter, ",")
	for _, param := range params {
		if i := strings.Index(param, "="); i < 0 {
			p.Param[param] = ""
		} else {
			p.Param[param[:i]] = param[i+1:]
		}
	}
	p.parsePathType()
}

// fillImports fills the imports based on the tables.
func (p *Plugin) fillImports(tables []Templater) {
	for _, t := range tables {
		for i, v := range t.Imports() {
			if v {
				p.imports[i] = v
			}
		}
	}
}

// parsePatmhType parses the path type from the parameters.
func (p *Plugin) parsePathType() {
	switch p.Param["paths"] {
	case "import":
		p.pathType = PathTypeImport
	case "source_relative":
		p.pathType = PathTypeSourceRelative
	default:
		log.Fatalf(`Unknown path type %q: want "import" or "source_relative".`, p.Param["paths"])
	}
}

// fillDefaultOptions fills the default options based on the protobuf.
func (p *Plugin) fillDefaultOptions() {
	p.parseProvider()
	p.parsePackageName()
	p.parseFileName()
}

func (p *Plugin) parseFileName() {
	fileBase := path.Base(p.req.GetFileToGenerate()[0])
	fileExt := path.Ext(fileBase)
	p.FileNameWithoutExt = strings.TrimSuffix(fileBase, fileExt)
}

// parsePackageName parses the package name from the protobuf options.
func (p *Plugin) parsePackageName() {
	for _, f := range p.req.GetProtoFile() {
		p.PackageName = f.GetPackage()
	}
}

// getGeneratedFilePath gets the generated file path based on the source file path.
func (p *Plugin) getGeneratedFilePath(sourceFilePath string) string {
	generatedBaseName := p.FileNameWithoutExt + GeneratedFilePostfix

	if p.pathType == PathTypeSourceRelative {
		// The generated file will have the same base as the source file, and it will be located in the same directory.
		fileDir := path.Dir(sourceFilePath)
		return path.Join(fileDir, generatedBaseName)
	}

	// If the path type is not source-relative, the generated file will have the same base as the source file,
	// but it will be located in the current directory.
	return generatedBaseName
}

// parseProvider parses the provider from the protobuf options.
func (p *Plugin) parseProvider() {
	for _, f := range p.req.GetProtoFile() {
		opts := getDBOptions(f)
		if opts != nil {
			switch opts.GetProvider() {
			case "mysql":
				p.provider = ProviderMysql
			case "postgres":
				p.provider = ProviderPostgres
			case "sqlite":
				p.provider = ProviderSqlite
			default:
				p.provider = ProviderPostgres
			}
		}
	}
}

// getTemplaterTables parses the proto file and returns a slice of Tables.
func (p *Plugin) getTemplaterTables() ([]Templater, error) {
	var tables []Templater

	for _, m := range getMessages(p.req) {
		var table Templater
		switch p.provider {
		case ProviderPostgres:
			p.imports.Enable(ImportErrors, ImportContext)
			table = createNewPostgresTableTemplate(m)
		case ProviderMysql:
			// todo: implement
		default:
			return nil, ErrUnsupportedProvider
		}

		tables = append(tables, table)
	}

	return tables, nil
}
