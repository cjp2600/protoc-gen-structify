// Code generated by protoc-gen-structify. DO NOT EDIT.
// source: example/db/blog.proto
// provider: postgres
package db

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	_ "github.com/lib/pq"
	"strconv"
	"strings"
)

// BlogDBClientOptions are the options for the BlogDBClient.
type BlogDBClientOptions struct {
	SSLMode string
	Timeout int
}

// Option is a function that configures the BlogDBClient.
type BlogDBClientOption func(*BlogDBClientOptions)

// WithSSLMode sets the SSL mode for the database connection.
func WithSSLMode(sslMode string) BlogDBClientOption {
	return func(opts *BlogDBClientOptions) {
		opts.SSLMode = sslMode
	}
}

// WithTimeout sets the timeout for the database connection.
func WithTimeout(timeout int) BlogDBClientOption {
	return func(opts *BlogDBClientOptions) {
		opts.Timeout = timeout
	}
}

// DBConnect connects to the database and returns a *sql.DB.
func DBConnect(host string, port int, user string, password string, dbname string, opts ...BlogDBClientOption) (*sql.DB, error) {
	options := &BlogDBClientOptions{}

	for _, opt := range opts {
		opt(options)
	}

	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s", host, port, user, password, dbname)

	if options.SSLMode != "" {
		psqlInfo += " sslmode=" + options.SSLMode
	}
	if options.Timeout != 0 {
		psqlInfo += " connect_timeout=" + strconv.Itoa(options.Timeout)
	}

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err = db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

// BlogDBClient is a map of provider to init function.
type BlogDBClient struct {
	db *sql.DB

	addressStore *AddressStore
	userStore    *UserStore
}

// NewBlogDBClient returns a new BlogDBClient. extra value
func NewBlogDBClient(db *sql.DB) *BlogDBClient {
	return &BlogDBClient{
		db: db,

		addressStore: &AddressStore{db: db},
		userStore:    &UserStore{db: db},
	}
}

// User returns the User store.
func (c *BlogDBClient) User() *UserStore {
	return c.userStore
}

// Address returns the Address store.
func (c *BlogDBClient) Address() *AddressStore {
	return c.addressStore
}

func (c *BlogDBClient) CreateTables() error {
	var err error

	_, err = c.db.Exec(c.userStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	_, err = c.db.Exec(c.addressStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	return nil
}

// error row not found
var ErrRowNotFound = errors.New("row not found")

// ErrNoTransaction is returned when the transaction is nil.
var ErrNoTransaction = errors.New("no transaction provided")

type UserStore struct {
	db *sql.DB
}

// User is a struct for the "users" table.
type User struct {
	Id        string `db:"id"`
	Name      string `db:"name"`
	Age       int32  `db:"age"`
	Email     string `db:"email"`
	LastName  string `db:"last_name"`
	Addresses []*Address
}

// TableName returns the name of the table.
func (u *UserStore) TableName() string {
	return "users"
}

// Columns returns the database columns for the table.
func (u *UserStore) Columns() []string {
	return []string{"id", "name", "age", "email", "last_name"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (u *UserStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS users (
id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
name TEXT NOT NULL,
age INTEGER NOT NULL,
email TEXT UNIQUE NOT NULL,
last_name TEXT NOT NULL,);COMMENT ON TABLE users IS 'This is a comment of User';`
}

// FindById returns a single row by ID.
func (u *UserStore) FindById(id string) (*User, error) {
	return u.FindOne(WhereUserIdEq(id))
}

// DeleteById returns a single row by ID.
func (u *UserStore) DeleteById(id string) (int64, error) {
	return u.Delete(WhereUserIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (u *UserStore) FindOne(conditions ...Condition) (*User, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	query := psql.Select(u.Columns()...).From(u.TableName())
	for _, condition := range conditions {
		query = condition.Apply(query)
	}
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}
	row := u.db.QueryRow(sqlQuery, args...)
	var model User
	err = row.Scan(&model.Id, &model.Name, &model.Age, &model.Email, &model.LastName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	// Relations statement

	aStore := &AddressStore{db: u.db}
	a, err := aStore.FindMany(WhereAddressUserIdEq(model.Id))
	if err != nil {
		return nil, fmt.Errorf("failed to find relation addresses: %w", err)
	}
	if a != nil {
		model.Addresses = a
	}
	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (u *UserStore) FindMany(conditions ...Condition) ([]*User, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(u.Columns()...).From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := u.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var users []*User
	for rows.Next() {
		var model User
		err = rows.Scan(&model.Id, &model.Name, &model.Age, &model.Email, &model.LastName)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		users = append(users, &model)
	}

	return users, nil
}

// Count returns the number of rows that match the provided conditions.
func (u *UserStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (u *UserStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(u.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := u.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (u *UserStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(u.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// UserUpdateRequest is the data required to update a row.
type UserUpdateRequest struct {
	Name     *string
	Age      *int32
	Email    *string
	LastName *string
}

// Update updates a row with the provided data.
func (u *UserStore) Update(ctx context.Context, id string, model *UserUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(u.TableName())
	if model.Name != nil {
		query = query.Set("name", model.Name)
	}
	if model.Age != nil {
		query = query.Set("age", model.Age)
	}
	if model.Email != nil {
		query = query.Set("email", model.Email)
	}
	if model.LastName != nil {
		query = query.Set("last_name", model.LastName)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = u.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (u *UserStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *UserUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(u.TableName())
	if model.Name != nil {
		query = query.Set("name", model.Name)
	}
	if model.Age != nil {
		query = query.Set("age", model.Age)
	}
	if model.Email != nil {
		query = query.Set("email", model.Email)
	}
	if model.LastName != nil {
		query = query.Set("last_name", model.LastName)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (u *UserStore) Create(ctx context.Context, model *User) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Age, model.Email, model.LastName)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (u *UserStore) CreateWithTx(tx *sql.Tx, model *User) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Age, model.Email, model.LastName)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (u *UserStore) CreateMany(ctx context.Context, models []*User) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name")

	for _, model := range models {
		query = query.Values(model.Name, model.Age, model.Email, model.LastName)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := u.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (u *UserStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*User) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name")

	for _, model := range models {
		query = query.Values(model.Name, model.Age, model.Email, model.LastName)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

type AddressStore struct {
	db *sql.DB
}

// Address is a struct for the "addresses" table.
type Address struct {
	Id     string `db:"id"`
	Street string `db:"street"`
	City   string `db:"city"`
	State  int32  `db:"state"`
	Zip    int64  `db:"zip"`
	User   *User
	UserId string `db:"user_id"`
}

// TableName returns the name of the table.
func (a *AddressStore) TableName() string {
	return "addresses"
}

// Columns returns the database columns for the table.
func (a *AddressStore) Columns() []string {
	return []string{"id", "street", "city", "state", "zip", "user_id"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (a *AddressStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS addresses (
id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
street TEXT NOT NULL,
city TEXT NOT NULL,
state INTEGER NOT NULL,
zip BIGINT NOT NULL,
user_id UUID NOT NULL);`
}

// FindById returns a single row by ID.
func (a *AddressStore) FindById(id string) (*Address, error) {
	return a.FindOne(WhereAddressIdEq(id))
}

// DeleteById returns a single row by ID.
func (a *AddressStore) DeleteById(id string) (int64, error) {
	return a.Delete(WhereAddressIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (a *AddressStore) FindOne(conditions ...Condition) (*Address, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	query := psql.Select(a.Columns()...).From(a.TableName())
	for _, condition := range conditions {
		query = condition.Apply(query)
	}
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}
	row := a.db.QueryRow(sqlQuery, args...)
	var model Address
	err = row.Scan(&model.Id, &model.Street, &model.City, &model.State, &model.Zip, &model.UserId)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	// Relations statement

	uStore := &UserStore{db: a.db}
	u, err := uStore.FindOne(WhereUserIdEq(model.UserId))
	if err != nil && err != ErrRowNotFound {
		return nil, fmt.Errorf("failed to find relation users: %w", err)
	}
	if u != nil {
		model.User = u
	}

	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (a *AddressStore) FindMany(conditions ...Condition) ([]*Address, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(a.Columns()...).From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := a.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var addresses []*Address
	for rows.Next() {
		var model Address
		err = rows.Scan(&model.Id, &model.Street, &model.City, &model.State, &model.Zip, &model.UserId)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		addresses = append(addresses, &model)
	}

	return addresses, nil
}

// Count returns the number of rows that match the provided conditions.
func (a *AddressStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (a *AddressStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(a.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := a.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (a *AddressStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(a.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// AddressUpdateRequest is the data required to update a row.
type AddressUpdateRequest struct {
	Street *string
	City   *string
	State  *int32
	Zip    *int64
	UserId *string
}

// Update updates a row with the provided data.
func (a *AddressStore) Update(ctx context.Context, id string, model *AddressUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(a.TableName())
	if model.Street != nil {
		query = query.Set("street", model.Street)
	}
	if model.City != nil {
		query = query.Set("city", model.City)
	}
	if model.State != nil {
		query = query.Set("state", model.State)
	}
	if model.Zip != nil {
		query = query.Set("zip", model.Zip)
	}
	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = a.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (a *AddressStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *AddressUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(a.TableName())
	if model.Street != nil {
		query = query.Set("street", model.Street)
	}
	if model.City != nil {
		query = query.Set("city", model.City)
	}
	if model.State != nil {
		query = query.Set("state", model.State)
	}
	if model.Zip != nil {
		query = query.Set("zip", model.Zip)
	}
	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (a *AddressStore) Create(ctx context.Context, model *Address) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id").
		Suffix("RETURNING \"id\"").
		Values(model.Street, model.City, model.State, model.Zip, model.UserId)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (a *AddressStore) CreateWithTx(tx *sql.Tx, model *Address) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id").
		Suffix("RETURNING \"id\"").
		Values(model.Street, model.City, model.State, model.Zip, model.UserId)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (a *AddressStore) CreateMany(ctx context.Context, models []*Address) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id")

	for _, model := range models {
		query = query.Values(model.Street, model.City, model.State, model.Zip, model.UserId)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := a.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (a *AddressStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*Address) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id")

	for _, model := range models {
		query = query.Values(model.Street, model.City, model.State, model.Zip, model.UserId)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// Condition is a condition filters.
type Condition interface {
	Apply(query sq.SelectBuilder) sq.SelectBuilder
	ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder
}

// PageCondition is a condition that limits the number of rows returned based on the page number.
type PageCondition struct {
	PageSize uint64
	Page     uint64
}

// Page returns a condition that limits the number of rows returned based on the page number.
func Page(pageSize uint64, page uint64) Condition {
	return PageCondition{PageSize: pageSize, Page: page}
}

// Apply applies the condition to the query.
func (c PageCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	// Calculate offset based on the page number
	offset := c.PageSize * (c.Page - 1)
	return query.Limit(c.PageSize).Offset(offset)
}

// ApplyDelete applies the condition to the query.
func (c PageCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	// Calculate offset based on the page number
	offset := c.PageSize * (c.Page - 1)
	return query.Limit(c.PageSize).Offset(offset)
}

// PaginateCondition is a condition that limits the number of rows returned.
type PaginateCondition struct {
	Limit  uint64
	Offset uint64
}

// Paginate returns a condition that limits the number of rows returned.
func Paginate(limit uint64, offset uint64) Condition {
	return PaginateCondition{Limit: limit, Offset: offset}
}

// Apply applies the condition to the query.
func (c PaginateCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Limit(c.Limit).Offset(c.Offset)
}

// ApplyDelete applies the condition to the query.
func (c PaginateCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Limit(c.Limit).Offset(c.Offset)
}

// LimitCondition is a condition that limits the number of rows returned.
type LimitCondition struct {
	Limit uint64
}

// Limit returns a condition that limits the number of rows returned.
func Limit(limit uint64) Condition {
	return LimitCondition{Limit: limit}
}

// Apply applies the condition to the query.
func (c LimitCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Limit(c.Limit)
}

// ApplyDelete applies the condition to the query.
func (c LimitCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Limit(c.Limit)
}

// OffsetCondition is a condition that skips the first n rows.
type OffsetCondition struct {
	Offset uint64
}

// Offset returns a condition that skips the first n rows.
func Offset(offset uint64) Condition {
	return OffsetCondition{Offset: offset}
}

// Apply applies the condition to the query.
func (c OffsetCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Offset(c.Offset)
}

// ApplyDelete applies the condition to the query.
func (c OffsetCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Offset(c.Offset)
}

// And returns a condition that combines the given conditions with AND.
type AndCondition struct {
	Where []Condition
}

// And returns a condition that combines the given conditions with AND.
func And(conditions ...Condition) Condition {
	return AndCondition{Where: conditions}
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	for _, condition := range c.Where {
		query = condition.Apply(query)
	}
	return query
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	for _, condition := range c.Where {
		query = condition.ApplyDelete(query)
	}
	return query
}

// Or returns a condition that checks if any of the conditions are true.
type OrCondition struct {
	Conditions []Condition
}

func Or(conditions ...Condition) Condition {
	return OrCondition{Conditions: conditions}
}

// Apply applies the condition to the query.
func (c OrCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// Apply applies the condition to the query.
func (c OrCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// EqualsCondition equals condition.
type EqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c EqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

func (c EqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

// WhereEq returns a condition that checks if the field equals the value.
func WhereEq(field string, value interface{}) Condition {
	return EqualsCondition{Field: field, Value: value}
}

// WhereAddressIdEq returns a condition that checks if the field equals the value.
func WhereAddressIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// WhereAddressStreetEq returns a condition that checks if the field equals the value.
func WhereAddressStreetEq(value interface{}) Condition {
	return EqualsCondition{Field: "street", Value: value}
}

// WhereAddressCityEq returns a condition that checks if the field equals the value.
func WhereAddressCityEq(value interface{}) Condition {
	return EqualsCondition{Field: "city", Value: value}
}

// WhereAddressStateEq returns a condition that checks if the field equals the value.
func WhereAddressStateEq(value interface{}) Condition {
	return EqualsCondition{Field: "state", Value: value}
}

// WhereAddressZipEq returns a condition that checks if the field equals the value.
func WhereAddressZipEq(value interface{}) Condition {
	return EqualsCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdEq returns a condition that checks if the field equals the value.
func WhereAddressUserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "user_id", Value: value}
}

// WhereUserIdEq returns a condition that checks if the field equals the value.
func WhereUserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// WhereUserNameEq returns a condition that checks if the field equals the value.
func WhereUserNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "name", Value: value}
}

// WhereUserAgeEq returns a condition that checks if the field equals the value.
func WhereUserAgeEq(value interface{}) Condition {
	return EqualsCondition{Field: "age", Value: value}
}

// WhereUserEmailEq returns a condition that checks if the field equals the value.
func WhereUserEmailEq(value interface{}) Condition {
	return EqualsCondition{Field: "email", Value: value}
}

// WhereUserLastNameEq returns a condition that checks if the field equals the value.
func WhereUserLastNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "last_name", Value: value}
}

// ------------------------------

// NotEqualsCondition not equals condition.
type NotEqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotEqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotEqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// WhereNotEq returns a condition that checks if the field equals the value.
func WhereNotEq(field string, value interface{}) Condition {
	return NotEqualsCondition{Field: field, Value: value}
}

// WhereAddressIdNotEq returns a condition that checks if the field equals the value.
func WhereAddressIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// WhereAddressStreetNotEq returns a condition that checks if the field equals the value.
func WhereAddressStreetNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "street", Value: value}
}

// WhereAddressCityNotEq returns a condition that checks if the field equals the value.
func WhereAddressCityNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "city", Value: value}
}

// WhereAddressStateNotEq returns a condition that checks if the field equals the value.
func WhereAddressStateNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "state", Value: value}
}

// WhereAddressZipNotEq returns a condition that checks if the field equals the value.
func WhereAddressZipNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdNotEq returns a condition that checks if the field equals the value.
func WhereAddressUserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// WhereUserIdNotEq returns a condition that checks if the field equals the value.
func WhereUserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// WhereUserNameNotEq returns a condition that checks if the field equals the value.
func WhereUserNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "name", Value: value}
}

// WhereUserAgeNotEq returns a condition that checks if the field equals the value.
func WhereUserAgeNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "age", Value: value}
}

// WhereUserEmailNotEq returns a condition that checks if the field equals the value.
func WhereUserEmailNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "email", Value: value}
}

// WhereUserLastNameNotEq returns a condition that checks if the field equals the value.
func WhereUserLastNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "last_name", Value: value}
}

// --------------------------------

// GreaterThanCondition greaterThanCondition than condition.
type GreaterThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// WhereGreaterThan returns a condition that checks if the field equals the value.
func WhereGreaterThan(field string, value interface{}) Condition {
	return GreaterThanCondition{Field: field, Value: value}
}

// WhereAddressIdGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// WhereAddressStreetGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressStreetGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "street", Value: value}
}

// WhereAddressCityGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressCityGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "city", Value: value}
}

// WhereAddressStateGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressStateGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "state", Value: value}
}

// WhereAddressZipGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressZipGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressUserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// WhereUserIdGreaterThan returns a condition that checks if the field equals the value.
func WhereUserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// WhereUserNameGreaterThan returns a condition that checks if the field equals the value.
func WhereUserNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "name", Value: value}
}

// WhereUserAgeGreaterThan returns a condition that checks if the field equals the value.
func WhereUserAgeGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "age", Value: value}
}

// WhereUserEmailGreaterThan returns a condition that checks if the field equals the value.
func WhereUserEmailGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "email", Value: value}
}

// WhereUserLastNameGreaterThan returns a condition that checks if the field equals the value.
func WhereUserLastNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LessThanCondition less than condition.
type LessThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// WhereLessThan returns a condition that checks if the field equals the value.
func WhereLessThan(field string, value interface{}) Condition {
	return LessThanCondition{Field: field, Value: value}
}

// WhereAddressIdLessThan returns a condition that checks if the field equals the value.
func WhereAddressIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// WhereAddressStreetLessThan returns a condition that checks if the field equals the value.
func WhereAddressStreetLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "street", Value: value}
}

// WhereAddressCityLessThan returns a condition that checks if the field equals the value.
func WhereAddressCityLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "city", Value: value}
}

// WhereAddressStateLessThan returns a condition that checks if the field equals the value.
func WhereAddressStateLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "state", Value: value}
}

// WhereAddressZipLessThan returns a condition that checks if the field equals the value.
func WhereAddressZipLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdLessThan returns a condition that checks if the field equals the value.
func WhereAddressUserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "user_id", Value: value}
}

// WhereUserIdLessThan returns a condition that checks if the field equals the value.
func WhereUserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// WhereUserNameLessThan returns a condition that checks if the field equals the value.
func WhereUserNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "name", Value: value}
}

// WhereUserAgeLessThan returns a condition that checks if the field equals the value.
func WhereUserAgeLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "age", Value: value}
}

// WhereUserEmailLessThan returns a condition that checks if the field equals the value.
func WhereUserEmailLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "email", Value: value}
}

// WhereUserLastNameLessThan returns a condition that checks if the field equals the value.
func WhereUserLastNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LessThanOrEqualCondition less than or equal condition.
type GreaterThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// WhereGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereGreaterThanOrEqual(field string, value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: field, Value: value}
}

// WhereAddressIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// WhereAddressStreetGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStreetGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "street", Value: value}
}

// WhereAddressCityGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressCityGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "city", Value: value}
}

// WhereAddressStateGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStateGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "state", Value: value}
}

// WhereAddressZipGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressZipGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressUserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// WhereUserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// WhereUserNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// WhereUserAgeGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserAgeGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "age", Value: value}
}

// WhereUserEmailGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserEmailGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "email", Value: value}
}

// WhereUserLastNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserLastNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LessThanOrEqualCondition less than or equal condition.
type LessThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

// WhereLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereLessThanOrEqual(field string, value interface{}) Condition {
	return LessThanOrEqualCondition{Field: field, Value: value}
}

// WhereAddressIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// WhereAddressStreetLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStreetLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "street", Value: value}
}

// WhereAddressCityLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressCityLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "city", Value: value}
}

// WhereAddressStateLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStateLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "state", Value: value}
}

// WhereAddressZipLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressZipLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressUserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// WhereUserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// WhereUserNameLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// WhereUserAgeLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserAgeLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "age", Value: value}
}

// WhereUserEmailLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserEmailLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "email", Value: value}
}

// WhereUserLastNameLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserLastNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LikeCondition like condition.
type LikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// WhereLike returns a condition that checks if the field equals the value.
func WhereLike(field string, value interface{}) Condition {
	return LikeCondition{Field: field, Value: value}
}

// WhereAddressIdLike returns a condition that checks if the field equals the value.
func WhereAddressIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// WhereAddressStreetLike returns a condition that checks if the field equals the value.
func WhereAddressStreetLike(value interface{}) Condition {
	return LikeCondition{Field: "street", Value: value}
}

// WhereAddressCityLike returns a condition that checks if the field equals the value.
func WhereAddressCityLike(value interface{}) Condition {
	return LikeCondition{Field: "city", Value: value}
}

// WhereAddressStateLike returns a condition that checks if the field equals the value.
func WhereAddressStateLike(value interface{}) Condition {
	return LikeCondition{Field: "state", Value: value}
}

// WhereAddressZipLike returns a condition that checks if the field equals the value.
func WhereAddressZipLike(value interface{}) Condition {
	return LikeCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdLike returns a condition that checks if the field equals the value.
func WhereAddressUserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "user_id", Value: value}
}

// WhereUserIdLike returns a condition that checks if the field equals the value.
func WhereUserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// WhereUserNameLike returns a condition that checks if the field equals the value.
func WhereUserNameLike(value interface{}) Condition {
	return LikeCondition{Field: "name", Value: value}
}

// WhereUserAgeLike returns a condition that checks if the field equals the value.
func WhereUserAgeLike(value interface{}) Condition {
	return LikeCondition{Field: "age", Value: value}
}

// WhereUserEmailLike returns a condition that checks if the field equals the value.
func WhereUserEmailLike(value interface{}) Condition {
	return LikeCondition{Field: "email", Value: value}
}

// WhereUserLastNameLike returns a condition that checks if the field equals the value.
func WhereUserLastNameLike(value interface{}) Condition {
	return LikeCondition{Field: "last_name", Value: value}
}

// --------------------------------

// NotLikeCondition not like condition.
type NotLikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotLikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotLikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// WhereNotLike returns a condition that checks if the field equals the value.
func WhereNotLike(field string, value interface{}) Condition {
	return NotLikeCondition{Field: field, Value: value}
}

// WhereAddressIdNotLike returns a condition that checks if the field equals the value.
func WhereAddressIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// WhereAddressStreetNotLike returns a condition that checks if the field equals the value.
func WhereAddressStreetNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "street", Value: value}
}

// WhereAddressCityNotLike returns a condition that checks if the field equals the value.
func WhereAddressCityNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "city", Value: value}
}

// WhereAddressStateNotLike returns a condition that checks if the field equals the value.
func WhereAddressStateNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "state", Value: value}
}

// WhereAddressZipNotLike returns a condition that checks if the field equals the value.
func WhereAddressZipNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdNotLike returns a condition that checks if the field equals the value.
func WhereAddressUserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// WhereUserIdNotLike returns a condition that checks if the field equals the value.
func WhereUserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// WhereUserNameNotLike returns a condition that checks if the field equals the value.
func WhereUserNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "name", Value: value}
}

// WhereUserAgeNotLike returns a condition that checks if the field equals the value.
func WhereUserAgeNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "age", Value: value}
}

// WhereUserEmailNotLike returns a condition that checks if the field equals the value.
func WhereUserEmailNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "email", Value: value}
}

// WhereUserLastNameNotLike returns a condition that checks if the field equals the value.
func WhereUserLastNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "last_name", Value: value}
}

// --------------------------------

// IsNullCondition represents the IS NULL condition.
type IsNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// WhereIsNull returns a condition that checks if the field is null.
func WhereIsNull(field string) Condition {
	return IsNullCondition{Field: field}
}

// WhereAddressIdIsNull returns a condition that checks if the field is null.
func WhereAddressIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// WhereAddressStreetIsNull returns a condition that checks if the field is null.
func WhereAddressStreetIsNull() Condition {
	return IsNullCondition{Field: "street"}
}

// WhereAddressCityIsNull returns a condition that checks if the field is null.
func WhereAddressCityIsNull() Condition {
	return IsNullCondition{Field: "city"}
}

// WhereAddressStateIsNull returns a condition that checks if the field is null.
func WhereAddressStateIsNull() Condition {
	return IsNullCondition{Field: "state"}
}

// WhereAddressZipIsNull returns a condition that checks if the field is null.
func WhereAddressZipIsNull() Condition {
	return IsNullCondition{Field: "zip"}
}

// WhereAddressUserIdIsNull returns a condition that checks if the field is null.
func WhereAddressUserIdIsNull() Condition {
	return IsNullCondition{Field: "user_id"}
}

// WhereUserIdIsNull returns a condition that checks if the field is null.
func WhereUserIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// WhereUserNameIsNull returns a condition that checks if the field is null.
func WhereUserNameIsNull() Condition {
	return IsNullCondition{Field: "name"}
}

// WhereUserAgeIsNull returns a condition that checks if the field is null.
func WhereUserAgeIsNull() Condition {
	return IsNullCondition{Field: "age"}
}

// WhereUserEmailIsNull returns a condition that checks if the field is null.
func WhereUserEmailIsNull() Condition {
	return IsNullCondition{Field: "email"}
}

// WhereUserLastNameIsNull returns a condition that checks if the field is null.
func WhereUserLastNameIsNull() Condition {
	return IsNullCondition{Field: "last_name"}
}

// --------------------------------

// IsNotNullCondition represents the IS NOT NULL condition.
type IsNotNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNotNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNotNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// WhereIsNotNull returns a condition that checks if the field is not null.
func WhereIsNotNull(field string) Condition {
	return IsNotNullCondition{Field: field}
}

// WhereAddressIdIsNotNull returns a condition that checks if the field is not null.
func WhereAddressIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// WhereAddressStreetIsNotNull returns a condition that checks if the field is not null.
func WhereAddressStreetIsNotNull() Condition {
	return IsNotNullCondition{Field: "street"}
}

// WhereAddressCityIsNotNull returns a condition that checks if the field is not null.
func WhereAddressCityIsNotNull() Condition {
	return IsNotNullCondition{Field: "city"}
}

// WhereAddressStateIsNotNull returns a condition that checks if the field is not null.
func WhereAddressStateIsNotNull() Condition {
	return IsNotNullCondition{Field: "state"}
}

// WhereAddressZipIsNotNull returns a condition that checks if the field is not null.
func WhereAddressZipIsNotNull() Condition {
	return IsNotNullCondition{Field: "zip"}
}

// WhereAddressUserIdIsNotNull returns a condition that checks if the field is not null.
func WhereAddressUserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "user_id"}
}

// WhereUserIdIsNotNull returns a condition that checks if the field is not null.
func WhereUserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// WhereUserNameIsNotNull returns a condition that checks if the field is not null.
func WhereUserNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "name"}
}

// WhereUserAgeIsNotNull returns a condition that checks if the field is not null.
func WhereUserAgeIsNotNull() Condition {
	return IsNotNullCondition{Field: "age"}
}

// WhereUserEmailIsNotNull returns a condition that checks if the field is not null.
func WhereUserEmailIsNotNull() Condition {
	return IsNotNullCondition{Field: "email"}
}

// WhereUserLastNameIsNotNull returns a condition that checks if the field is not null.
func WhereUserLastNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "last_name"}
}

// --------------------------------

// InCondition represents the IN condition.
type InCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c InCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c InCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// WhereIn returns a condition that checks if the field is in the given values.
func WhereIn(field string, values ...interface{}) Condition {
	return InCondition{Field: field, Values: values}
}

// WhereAddressIdIn returns a condition that checks if the field is in the given values.
func WhereAddressIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// WhereAddressStreetIn returns a condition that checks if the field is in the given values.
func WhereAddressStreetIn(values ...interface{}) Condition {
	return InCondition{Field: "street", Values: values}
}

// WhereAddressCityIn returns a condition that checks if the field is in the given values.
func WhereAddressCityIn(values ...interface{}) Condition {
	return InCondition{Field: "city", Values: values}
}

// WhereAddressStateIn returns a condition that checks if the field is in the given values.
func WhereAddressStateIn(values ...interface{}) Condition {
	return InCondition{Field: "state", Values: values}
}

// WhereAddressZipIn returns a condition that checks if the field is in the given values.
func WhereAddressZipIn(values ...interface{}) Condition {
	return InCondition{Field: "zip", Values: values}
}

// WhereAddressUserIdIn returns a condition that checks if the field is in the given values.
func WhereAddressUserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "user_id", Values: values}
}

// WhereUserIdIn returns a condition that checks if the field is in the given values.
func WhereUserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// WhereUserNameIn returns a condition that checks if the field is in the given values.
func WhereUserNameIn(values ...interface{}) Condition {
	return InCondition{Field: "name", Values: values}
}

// WhereUserAgeIn returns a condition that checks if the field is in the given values.
func WhereUserAgeIn(values ...interface{}) Condition {
	return InCondition{Field: "age", Values: values}
}

// WhereUserEmailIn returns a condition that checks if the field is in the given values.
func WhereUserEmailIn(values ...interface{}) Condition {
	return InCondition{Field: "email", Values: values}
}

// WhereUserLastNameIn returns a condition that checks if the field is in the given values.
func WhereUserLastNameIn(values ...interface{}) Condition {
	return InCondition{Field: "last_name", Values: values}
}

// --------------------------------

// NotInCondition represents the NOT IN condition.
type NotInCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c NotInCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c NotInCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// WhereNotIn returns a condition that checks if the field is not in the given values.
func WhereNotIn(field string, values ...interface{}) Condition {
	return NotInCondition{Field: field, Values: values}
}

// WhereAddressIdNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// WhereAddressStreetNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressStreetNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "street", Values: values}
}

// WhereAddressCityNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressCityNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "city", Values: values}
}

// WhereAddressStateNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressStateNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "state", Values: values}
}

// WhereAddressZipNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressZipNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "zip", Values: values}
}

// WhereAddressUserIdNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressUserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "user_id", Values: values}
}

// WhereUserIdNotIn returns a condition that checks if the field is not in the given values.
func WhereUserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// WhereUserNameNotIn returns a condition that checks if the field is not in the given values.
func WhereUserNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "name", Values: values}
}

// WhereUserAgeNotIn returns a condition that checks if the field is not in the given values.
func WhereUserAgeNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "age", Values: values}
}

// WhereUserEmailNotIn returns a condition that checks if the field is not in the given values.
func WhereUserEmailNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "email", Values: values}
}

// WhereUserLastNameNotIn returns a condition that checks if the field is not in the given values.
func WhereUserLastNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "last_name", Values: values}
}

// --------------------------------

// BetweenCondition represents the BETWEEN condition.
type BetweenCondition struct {
	Field string
	From  interface{}
	To    interface{}
}

// Apply applies the condition to the query.
func (c BetweenCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s BETWEEN ? AND ?", c.Field), c.From, c.To))
}

// ApplyDelete applies the condition to the query.
func (c BetweenCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s BETWEEN ? AND ?", c.Field), c.From, c.To))
}

// WhereBetween returns a condition that checks if the field is between the given values.
func WhereBetween(field string, from, to interface{}) Condition {
	return BetweenCondition{Field: field, From: from, To: to}
}

// WhereAddressIdBetween returns a condition that checks if the field is between the given values.
func WhereAddressIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// WhereAddressStreetBetween returns a condition that checks if the field is between the given values.
func WhereAddressStreetBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "street", From: from, To: to}
}

// WhereAddressCityBetween returns a condition that checks if the field is between the given values.
func WhereAddressCityBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "city", From: from, To: to}
}

// WhereAddressStateBetween returns a condition that checks if the field is between the given values.
func WhereAddressStateBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "state", From: from, To: to}
}

// WhereAddressZipBetween returns a condition that checks if the field is between the given values.
func WhereAddressZipBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "zip", From: from, To: to}
}

// WhereAddressUserIdBetween returns a condition that checks if the field is between the given values.
func WhereAddressUserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "user_id", From: from, To: to}
}

// WhereUserIdBetween returns a condition that checks if the field is between the given values.
func WhereUserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// WhereUserNameBetween returns a condition that checks if the field is between the given values.
func WhereUserNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "name", From: from, To: to}
}

// WhereUserAgeBetween returns a condition that checks if the field is between the given values.
func WhereUserAgeBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "age", From: from, To: to}
}

// WhereUserEmailBetween returns a condition that checks if the field is between the given values.
func WhereUserEmailBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "email", From: from, To: to}
}

// WhereUserLastNameBetween returns a condition that checks if the field is between the given values.
func WhereUserLastNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "last_name", From: from, To: to}
}

// --------------------------------

// OrderCondition represents the ORDER BY condition.
type OrderCondition struct {
	Column string
	Asc    bool
}

// WhereOrderBy applies the condition to the query.
func WhereOrderBy(column string, asc bool) Condition {
	return OrderCondition{Column: column, Asc: asc}
}

// Apply applies the condition to the query.
func (c OrderCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	if c.Asc {
		return query.OrderBy(c.Column + " ASC")
	}
	return query.OrderBy(c.Column + " DESC")
}

func (c OrderCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query
}

// WhereAddressIdOrderBy returns a condition that orders the query by the given column.
func WhereAddressIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// WhereAddressStreetOrderBy returns a condition that orders the query by the given column.
func WhereAddressStreetOrderBy(asc bool) Condition {
	return OrderCondition{Column: "street", Asc: asc}
}

// WhereAddressCityOrderBy returns a condition that orders the query by the given column.
func WhereAddressCityOrderBy(asc bool) Condition {
	return OrderCondition{Column: "city", Asc: asc}
}

// WhereAddressStateOrderBy returns a condition that orders the query by the given column.
func WhereAddressStateOrderBy(asc bool) Condition {
	return OrderCondition{Column: "state", Asc: asc}
}

// WhereAddressZipOrderBy returns a condition that orders the query by the given column.
func WhereAddressZipOrderBy(asc bool) Condition {
	return OrderCondition{Column: "zip", Asc: asc}
}

// WhereAddressUserIdOrderBy returns a condition that orders the query by the given column.
func WhereAddressUserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "user_id", Asc: asc}
}

// WhereUserIdOrderBy returns a condition that orders the query by the given column.
func WhereUserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// WhereUserNameOrderBy returns a condition that orders the query by the given column.
func WhereUserNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "name", Asc: asc}
}

// WhereUserAgeOrderBy returns a condition that orders the query by the given column.
func WhereUserAgeOrderBy(asc bool) Condition {
	return OrderCondition{Column: "age", Asc: asc}
}

// WhereUserEmailOrderBy returns a condition that orders the query by the given column.
func WhereUserEmailOrderBy(asc bool) Condition {
	return OrderCondition{Column: "email", Asc: asc}
}

// WhereUserLastNameOrderBy returns a condition that orders the query by the given column.
func WhereUserLastNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "last_name", Asc: asc}
}
