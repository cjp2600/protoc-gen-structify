// Code generated by protoc-gen-structify. DO NOT EDIT.
// source: example/db/blog.proto
// provider: postgres
// protoc-gen-structify: (version=v1.0.0-26-g5cd3002, branch=main, revision=5cd300219f6e01eae3a348ebebf53af9d6399a5b), build: (go=go1.20.7, date=2023-08-16T12:45:57+0300)
// protoc: 3.15.8
package db

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	"github.com/lib/pq"
	_ "github.com/lib/pq"
	"github.com/pkg/errors"
	"strconv"
	"time"
)

//
// Database connection.
//

// Dsn builds the DSN string for the database connection.
// See https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING
func Dsn(host string, port int, user string, password string, dbname string, sslMode string, timeout int) string {
	dsn := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s", host, port, user, password, dbname)

	// sslMode is optional. If not provided, it will be omitted.
	// valid values are: disable, allow, prefer, require, verify-ca, verify-full
	if sslMode != "" {
		dsn += " sslmode=" + sslMode
	}

	if timeout != 0 {
		dsn += " connect_timeout=" + strconv.Itoa(timeout)
	}

	return dsn
}

// Open connects to the database and returns a *sql.DB.
// The caller is responsible for closing the database.
// The caller is responsible for calling db.Ping() to verify the connection.
// The caller is responsible for setting the connection pool options.
//
// See https://golang.org/pkg/database/sql/#DB.SetMaxOpenConns
// See https://golang.org/pkg/database/sql/#DB.SetMaxIdleConns
// See https://golang.org/pkg/database/sql/#DB.SetConnMaxIdleTime
// See https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime
// See https://golang.org/pkg/database/sql/#DB.Ping
func Open(dsn string, opts ...BlogDatabaseClientOption) (*sql.DB, error) {
	options := &BlogDatabaseClientOptions{
		MaxOpenConns:    10,
		MaxIdleConns:    5,
		ConnMaxIdleTime: time.Minute,
		MaxLifetime:     time.Minute * 2,
	}

	for _, opt := range opts {
		opt(options)
	}

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Ping verifies a connection to the database is still alive, establishing a connection if necessary.
	if err = db.Ping(); err != nil {
		// If Ping fails, close the DB and return an error.
		db.Close() // Ignoring error from Close, as we already have a more significant error.
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	// Set the connection pool options.
	db.SetMaxOpenConns(options.MaxOpenConns)
	// SetMaxIdleConns sets the maximum number of connections in the idle connection pool.
	db.SetMaxIdleConns(options.MaxIdleConns)
	// SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.
	db.SetConnMaxIdleTime(options.ConnMaxIdleTime)
	// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
	db.SetConnMaxLifetime(options.MaxLifetime)

	return db, nil
}

// BlogDatabaseClientOptions are the options for the BlogDatabaseClient.
type BlogDatabaseClientOptions struct {
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxIdleTime time.Duration
	MaxLifetime     time.Duration
}

// Option is a function that configures the BlogDatabaseClient.
type BlogDatabaseClientOption func(*BlogDatabaseClientOptions)

// WithMaxOpenConns sets the maximum number of open connections to the database.
func WithMaxOpenConns(maxOpenConns int) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.MaxOpenConns = maxOpenConns
	}
}

// WithMaxIdleConns sets the maximum number of idle connections to the database.
func WithMaxIdleConns(maxIdleConns int) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.MaxIdleConns = maxIdleConns
	}
}

// WithConnMaxIdleTime sets the maximum amount of time a connection may be idle.
func WithConnMaxIdleTime(connMaxIdleTime time.Duration) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.ConnMaxIdleTime = connMaxIdleTime
	}
}

// WithMaxLifetime sets the maximum amount of time a connection may be reused.
func WithMaxLifetime(maxLifetime time.Duration) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.MaxLifetime = maxLifetime
	}
}

//
// storages.
//

// blogStorages is a map of provider to init function.
type blogStorages struct {
	db *sql.DB    // The database connection.
	tx *TxManager // The transaction manager.

	addressStorage AddressStorage
	deviceStorage  DeviceStorage
	settingStorage SettingStorage
	userStorage    UserStorage
}

// BlogStorages is the interface for the BlogStorages.
type BlogStorages interface {
	// GetAddressStorage returns the AddressStorage store.
	GetAddressStorage() AddressStorage
	// GetDeviceStorage returns the DeviceStorage store.
	GetDeviceStorage() DeviceStorage
	// GetSettingStorage returns the SettingStorage store.
	GetSettingStorage() SettingStorage
	// GetUserStorage returns the UserStorage store.
	GetUserStorage() UserStorage
	// TxManager returns the transaction manager.
	TxManager() *TxManager
	// CreateTables creates the tables for all the stores.
	CreateTables() error
	// DropTables drops the tables for all the stores.
	DropTables() error
	// TruncateTables truncates the tables for all the stores.
	TruncateTables() error
	// UpgradeTables upgrades the tables for all the stores.
	UpgradeTables() error
}

// NewBlogStorages returns a new BlogStorages.
func NewBlogStorages(db *sql.DB) BlogStorages {
	return &blogStorages{
		db: db,
		tx: NewTxManager(db),

		addressStorage: NewAddressStorage(db),
		deviceStorage:  NewDeviceStorage(db),
		settingStorage: NewSettingStorage(db),
		userStorage:    NewUserStorage(db),
	}
}

// TxManager returns the transaction manager.
func (c *blogStorages) TxManager() *TxManager {
	return c.tx
}

// GetAddressStorage returns the AddressStorage store.
func (c *blogStorages) GetAddressStorage() AddressStorage {
	return c.addressStorage
}

// GetDeviceStorage returns the DeviceStorage store.
func (c *blogStorages) GetDeviceStorage() DeviceStorage {
	return c.deviceStorage
}

// GetSettingStorage returns the SettingStorage store.
func (c *blogStorages) GetSettingStorage() SettingStorage {
	return c.settingStorage
}

// GetUserStorage returns the UserStorage store.
func (c *blogStorages) GetUserStorage() UserStorage {
	return c.userStorage
}

// CreateTables creates the tables for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) CreateTables() error {
	var err error

	// create the AddressStorage table.
	err = c.addressStorage.CreateTable()
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the DeviceStorage table.
	err = c.deviceStorage.CreateTable()
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the SettingStorage table.
	err = c.settingStorage.CreateTable()
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the UserStorage table.
	err = c.userStorage.CreateTable()
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	return nil
}

// DropTables drops the tables for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) DropTables() error {
	var err error

	// drop the AddressStorage table.
	err = c.addressStorage.DropTable()
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the DeviceStorage table.
	err = c.deviceStorage.DropTable()
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the SettingStorage table.
	err = c.settingStorage.DropTable()
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the UserStorage table.
	err = c.userStorage.DropTable()
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	return nil
}

// TruncateTables truncates the tables for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) TruncateTables() error {
	var err error

	// truncate the AddressStorage table.
	err = c.addressStorage.TruncateTable()
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the DeviceStorage table.
	err = c.deviceStorage.TruncateTable()
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the SettingStorage table.
	err = c.settingStorage.TruncateTable()
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the UserStorage table.
	err = c.userStorage.TruncateTable()
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	return nil
}

// UpgradeTables runs the database upgrades for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) UpgradeTables() error {
	var err error

	// run the AddressStorage upgrade.
	err = c.addressStorage.UpgradeTable()
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the DeviceStorage upgrade.
	err = c.deviceStorage.UpgradeTable()
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the SettingStorage upgrade.
	err = c.settingStorage.UpgradeTable()
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the UserStorage upgrade.
	err = c.userStorage.UpgradeTable()
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	return nil
}

//
// Json types.
//

// Comment is a JSON type nested in another message.
type UserComment struct {
	Name string       `json:"name"`
	Meta *CommentMeta `json:"meta"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserComment) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserComment) Value() (driver.Value, error) {
	if m == nil {
		m = &UserComment{}
	}
	return json.Marshal(m)
}

// Meta is a JSON type nested in another message.
type CommentMeta struct {
	Ip      string `json:"ip"`
	Browser string `json:"browser"`
	Os      string `json:"os"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *CommentMeta) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *CommentMeta) Value() (driver.Value, error) {
	if m == nil {
		m = &CommentMeta{}
	}
	return json.Marshal(m)
}

// NotificationSetting is a JSON type nested in another message.
type UserNotificationSetting struct {
	RegistrationEmail bool `json:"registration_email"`
	OrderEmail        bool `json:"order_email"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserNotificationSetting) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserNotificationSetting) Value() (driver.Value, error) {
	if m == nil {
		m = &UserNotificationSetting{}
	}
	return json.Marshal(m)
}

// Numr is a JSON type nested in another message.
type UserNumr struct {
	Street string `json:"street"`
	City   string `json:"city"`
	State  int32  `json:"state"`
	Zip    int64  `json:"zip"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserNumr) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserNumr) Value() (driver.Value, error) {
	if m == nil {
		m = &UserNumr{}
	}
	return json.Marshal(m)
}

//
// Single repeated types.
//

// UserBallsRepeated is a JSON type nested in another message.
type UserBallsRepeated struct {
	Balls []int32 `json:"balls"`
}

// NewBallsField returns a new UserBallsRepeated.
func NewBallsField(v []int32) *UserBallsRepeated {
	return &UserBallsRepeated{
		Balls: v,
	}
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserBallsRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserBallsRepeated) Value() (driver.Value, error) {
	if m == nil {
		m = &UserBallsRepeated{}
	}
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m *UserBallsRepeated) Get() []int32 {
	return m.Balls
}

func (m *UserBallsRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// UserCommentsRepeated is a JSON type nested in another message.
type UserCommentsRepeated struct {
	Comments []UserComment `json:"comments"`
}

// NewCommentsField returns a new UserCommentsRepeated.
func NewCommentsField(v []UserComment) *UserCommentsRepeated {
	return &UserCommentsRepeated{
		Comments: v,
	}
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserCommentsRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserCommentsRepeated) Value() (driver.Value, error) {
	if m == nil {
		m = &UserCommentsRepeated{}
	}
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m *UserCommentsRepeated) Get() []UserComment {
	return m.Comments
}

func (m *UserCommentsRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// UserNumrsRepeated is a JSON type nested in another message.
type UserNumrsRepeated struct {
	Numrs []UserNumr `json:"numrs"`
}

// NewNumrsField returns a new UserNumrsRepeated.
func NewNumrsField(v []UserNumr) *UserNumrsRepeated {
	return &UserNumrsRepeated{
		Numrs: v,
	}
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserNumrsRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserNumrsRepeated) Value() (driver.Value, error) {
	if m == nil {
		m = &UserNumrsRepeated{}
	}
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m *UserNumrsRepeated) Get() []UserNumr {
	return m.Numrs
}

func (m *UserNumrsRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// UserPhonesRepeated is a JSON type nested in another message.
type UserPhonesRepeated struct {
	Phones []string `json:"phones"`
}

// NewPhonesField returns a new UserPhonesRepeated.
func NewPhonesField(v []string) *UserPhonesRepeated {
	return &UserPhonesRepeated{
		Phones: v,
	}
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserPhonesRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserPhonesRepeated) Value() (driver.Value, error) {
	if m == nil {
		m = &UserPhonesRepeated{}
	}
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m *UserPhonesRepeated) Get() []string {
	return m.Phones
}

func (m *UserPhonesRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

//
// errors.
//

var (
	// ErrNotFound is returned when a record is not found.
	ErrRowNotFound = errors.New("row not found")
	// ErrNoTransaction is returned when a transaction is not provided.
	ErrNoTransaction = errors.New("no transaction provided")
	// ErrRowAlreadyExist is returned when a row already exist.
	ErrRowAlreadyExist = errors.New("row already exist")
)

//
// Transaction manager.
//

// txKey is the key used to store the transaction in the context.
type txKey struct{}

// TxFromContext returns the transaction from the context.
func TxFromContext(ctx context.Context) (*sql.Tx, bool) {
	tx, ok := ctx.Value(txKey{}).(*sql.Tx)
	return tx, ok
}

// TxManager is a transaction manager.
type TxManager struct {
	db *sql.DB
}

// NewTxManager creates a new transaction manager.
func NewTxManager(db *sql.DB) *TxManager {
	return &TxManager{
		db: db,
	}
}

// Begin begins a transaction.
func (m *TxManager) Begin(ctx context.Context) (context.Context, error) {
	if _, ok := TxFromContext(ctx); ok {
		return ctx, nil
	}

	tx, err := m.db.Begin()
	if err != nil {
		return ctx, fmt.Errorf("could not begin transaction: %w", err)
	}

	// store the transaction in the context.
	return context.WithValue(ctx, txKey{}, tx), nil
}

// IsTxOpen returns true if a transaction is open.
func (m *TxManager) Commit(ctx context.Context) error {
	tx, ok := TxFromContext(ctx)
	if !ok {
		return errors.New("transactions wasn't opened")
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("could not commit transaction: %w", err)
	}

	return nil
}

// Rollback rolls back a transaction.
func (m *TxManager) Rollback(ctx context.Context) error {
	if tx, ok := TxFromContext(ctx); ok {
		err := tx.Rollback()
		if err != nil && !errors.Is(err, sql.ErrTxDone) {
			return err
		}
	}

	return nil
}

// ExecFuncWithTx executes a function with a transaction.
func (m *TxManager) ExecFuncWithTx(ctx context.Context, f func(context.Context) error) error {
	// if a transaction is already open, just execute the function.
	if m.IsTxOpen(ctx) {
		return f(ctx)
	}

	ctx, err := m.Begin(ctx)
	if err != nil {
		return err
	}
	// rollback the transaction if there is an error.
	defer func() { _ = m.Rollback(ctx) }()

	if err := f(ctx); err != nil {
		return err
	}

	// commit the transaction.
	if err := m.Commit(ctx); err != nil {
		return err
	}

	return nil
}

// IsTxOpen returns true if a transaction is open.
func (m *TxManager) IsTxOpen(ctx context.Context) bool {
	_, ok := TxFromContext(ctx)
	return ok
}

// QueryExecer is an interface that can execute queries.
type QueryExecer interface {
	Query(query string, args ...interface{}) (*sql.Rows, error)
	Exec(query string, args ...interface{}) (sql.Result, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

// IsPgCheckViolation returns true if the error is a postgres check violation.
func IsPgUniqueViolation(err error) bool {
	pgErr, ok := err.(*pq.Error)
	if !ok {
		return false
	}

	return pgErr.Code == errPgUniqueViolationError
}

// IsPgCheckViolation returns true if the error is a postgres check violation.
func IsPgViolationError(err error) bool {
	pgErr, ok := err.(*pq.Error)
	if !ok {
		return false
	}

	return pgErr.Code == errPgCheckViolation ||
		pgErr.Code == errPgNotNullViolation ||
		pgErr.Code == errPgForeignKeyViolation ||
		pgErr.Code == errPgUniqueViolationError
}

// PgPrettyErr returns a pretty postgres error.
func PgPrettyErr(err error) error {
	if pgErr, ok := err.(*pq.Error); ok {
		return errors.New(pgErr.Detail)
	}
	return err
}

// errors for postgres.
// https://www.postgresql.org/docs/9.3/errcodes-appendix.html
const (
	errPgCheckViolation       = "23514"
	errPgNotNullViolation     = "23502"
	errPgForeignKeyViolation  = "23503"
	errPgUniqueViolationError = "23505"
)

// deviceStorage is a struct for the "devices" table.
type deviceStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type DeviceStorage interface {
	// CreateTable creates the table.
	CreateTable() error
	// DropTable drops the table.
	DropTable() error
	// TruncateTable truncates the table.
	TruncateTable() error
	// UpgradeTable upgrades the table.
	UpgradeTable() error
	// Create creates a new Device.
	Create(ctx context.Context, model *Device) error
}

// NewDeviceStorage returns a new deviceStorage.
func NewDeviceStorage(db *sql.DB) DeviceStorage {
	return &deviceStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *deviceStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *deviceStorage) CreateTable() error {
	sqlQuery := `
		-- Table: devices
		CREATE TABLE IF NOT EXISTS devices (
		name TEXT,
		value TEXT,
		user_id UUID NOT NULL);
		
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// DropTable drops the table.
func (t *deviceStorage) DropTable() error {
	sqlQuery := `
		DROP TABLE IF EXISTS devices;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *deviceStorage) TruncateTable() error {
	sqlQuery := `
		TRUNCATE TABLE devices;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
func (t *deviceStorage) UpgradeTable() error {
	return nil
}

// Create creates a new Device.
func (t *deviceStorage) Create(ctx context.Context, model *Device) error {
	if model == nil {
		return errors.New("model is nil")
	}

	query := t.queryBuilder.Insert("devices").
		Columns(
			"name",
			"value",
			"user_id",
		).
		Values(
			model.Name,
			model.Value,
			model.UserId,
		)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).Exec(sqlQuery, args...)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return fmt.Errorf("failed to create Device: %w", err)
	}

	return nil
}

// Device is a struct for the "devices" table.
type Device struct {
	Name   string `db:"name"`
	Value  string `db:"value"`
	UserId string `db:"user_id"`
}

// ScanRow scans a row into a Device.
func (t *Device) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Name, &t.Value, &t.UserId)
}

// TableName returns the table name.
func (t *Device) TableName() string {
	return "devices"
}

// Columns returns the columns for the table.
func (t *Device) Columns() []string {
	return []string{
		"name", "value", "user_id",
	}
}

// userStorage is a struct for the "users" table.
type userStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type UserStorage interface {
	// CreateTable creates the table.
	CreateTable() error
	// DropTable drops the table.
	DropTable() error
	// TruncateTable truncates the table.
	TruncateTable() error
	// UpgradeTable upgrades the table.
	UpgradeTable() error
	// Create creates a new User.
	Create(ctx context.Context, model *User) (*string, error)
}

// NewUserStorage returns a new userStorage.
func NewUserStorage(db *sql.DB) UserStorage {
	return &userStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *userStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *userStorage) CreateTable() error {
	sqlQuery := `
		CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
		-- Table: users
		CREATE TABLE IF NOT EXISTS users (
		id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
		name TEXT NOT NULL,
		age INTEGER,
		email TEXT UNIQUE NOT NULL,
		last_name TEXT,
		created_at TIMESTAMP NOT NULL DEFAULT now(),
		updated_at TIMESTAMP,
		notification_settings JSONB,
		phones JSONB,
		balls JSONB,
		numrs JSONB,
		comments JSONB);
		COMMENT ON TABLE users IS 'This is a comment of User';
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// DropTable drops the table.
func (t *userStorage) DropTable() error {
	sqlQuery := `
		DROP TABLE IF EXISTS users;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *userStorage) TruncateTable() error {
	sqlQuery := `
		TRUNCATE TABLE users;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
func (t *userStorage) UpgradeTable() error {
	return nil
}

// Create creates a new User.
func (t *userStorage) Create(ctx context.Context, model *User) (*string, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}
	// get value of phones
	phones, err := model.Phones.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get phones value: %w", err)
	}
	// get value of balls
	balls, err := model.Balls.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get balls value: %w", err)
	}
	// get value of numrs
	numrs, err := model.Numrs.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get numrs value: %w", err)
	}
	// get value of comments
	comments, err := model.Comments.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get comments value: %w", err)
	}

	query := t.queryBuilder.Insert("users").
		Columns(
			"name",
			"age",
			"email",
			"last_name",
			"created_at",
			"updated_at",
			"notification_settings",
			"phones",
			"balls",
			"numrs",
			"comments",
		).
		Values(
			model.Name,
			model.Age,
			model.Email,
			model.LastName,
			model.CreatedAt,
			model.UpdatedAt,
			model.NotificationSettings,
			phones,
			balls,
			numrs,
			comments,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id string
	err = t.DB(ctx).QueryRow(sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create User: %w", err)
	}

	if model.Device != nil {
		s := NewDeviceStorage(t.db)
		model.Device.UserId = id
		err := s.Create(ctx, model.Device)
		if err != nil {
			return nil, fmt.Errorf("failed to create Device: %w", err)
		}
	}
	if model.Settings != nil {
		s := NewSettingStorage(t.db)
		model.Settings.UserId = id
		_, err := s.Create(ctx, model.Settings)
		if err != nil {
			return nil, fmt.Errorf("failed to create Settings: %w", err)
		}
	}
	if model.Addresses != nil {
		for _, item := range model.Addresses {
			item.UserId = id
			s := NewAddressStorage(t.db)
			_, err := s.Create(ctx, item)
			if err != nil {
				return nil, fmt.Errorf("failed to create Addresses: %w", err)
			}
		}
	}

	return &id, nil
}

// User is a struct for the "users" table.
type User struct {
	Id                   string  `db:"id"`
	Name                 string  `db:"name"`
	Age                  int32   `db:"age"`
	Email                string  `db:"email"`
	LastName             *string `db:"last_name"`
	Device               *Device
	Settings             *Setting
	Addresses            []*Address
	CreatedAt            time.Time                `db:"created_at"`
	UpdatedAt            *time.Time               `db:"updated_at"`
	NotificationSettings *UserNotificationSetting `db:"notification_settings"`
	Phones               UserPhonesRepeated       `db:"phones"`
	Balls                UserBallsRepeated        `db:"balls"`
	Numrs                UserNumrsRepeated        `db:"numrs"`
	Comments             UserCommentsRepeated     `db:"comments"`
}

// ScanRow scans a row into a User.
func (t *User) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Name, &t.Age, &t.Email, &t.LastName, &t.CreatedAt, &t.UpdatedAt, &t.NotificationSettings, &t.Phones, &t.Balls, &t.Numrs, &t.Comments)
}

// TableName returns the table name.
func (t *User) TableName() string {
	return "users"
}

// Columns returns the columns for the table.
func (t *User) Columns() []string {
	return []string{
		"id", "name", "age", "email", "last_name", "created_at", "updated_at", "notification_settings", "phones", "balls", "numrs", "comments",
	}
}

// settingStorage is a struct for the "settings" table.
type settingStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type SettingStorage interface {
	// CreateTable creates the table.
	CreateTable() error
	// DropTable drops the table.
	DropTable() error
	// TruncateTable truncates the table.
	TruncateTable() error
	// UpgradeTable upgrades the table.
	UpgradeTable() error
	// Create creates a new Setting.
	Create(ctx context.Context, model *Setting) (*int32, error)
}

// NewSettingStorage returns a new settingStorage.
func NewSettingStorage(db *sql.DB) SettingStorage {
	return &settingStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *settingStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *settingStorage) CreateTable() error {
	sqlQuery := `
		-- Table: settings
		CREATE TABLE IF NOT EXISTS settings (
		id  SERIAL PRIMARY KEY,
		name TEXT NOT NULL,
		value TEXT,
		user_id UUID NOT NULL);
		
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// DropTable drops the table.
func (t *settingStorage) DropTable() error {
	sqlQuery := `
		DROP TABLE IF EXISTS settings;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *settingStorage) TruncateTable() error {
	sqlQuery := `
		TRUNCATE TABLE settings;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
func (t *settingStorage) UpgradeTable() error {
	return nil
}

// Create creates a new Setting.
func (t *settingStorage) Create(ctx context.Context, model *Setting) (*int32, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	query := t.queryBuilder.Insert("settings").
		Columns(
			"name",
			"value",
			"user_id",
		).
		Values(
			model.Name,
			model.Value,
			model.UserId,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id int32
	err = t.DB(ctx).QueryRow(sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create Setting: %w", err)
	}

	return &id, nil
}

// Setting is a struct for the "settings" table.
type Setting struct {
	Id     int32  `db:"id"`
	Name   string `db:"name"`
	Value  string `db:"value"`
	User   *User
	UserId string `db:"user_id"`
}

// ScanRow scans a row into a Setting.
func (t *Setting) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Name, &t.Value, &t.UserId)
}

// TableName returns the table name.
func (t *Setting) TableName() string {
	return "settings"
}

// Columns returns the columns for the table.
func (t *Setting) Columns() []string {
	return []string{
		"id", "name", "value", "user_id",
	}
}

// addressStorage is a struct for the "addresses" table.
type addressStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type AddressStorage interface {
	// CreateTable creates the table.
	CreateTable() error
	// DropTable drops the table.
	DropTable() error
	// TruncateTable truncates the table.
	TruncateTable() error
	// UpgradeTable upgrades the table.
	UpgradeTable() error
	// Create creates a new Address.
	Create(ctx context.Context, model *Address) (*string, error)
}

// NewAddressStorage returns a new addressStorage.
func NewAddressStorage(db *sql.DB) AddressStorage {
	return &addressStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *addressStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *addressStorage) CreateTable() error {
	sqlQuery := `
		CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
		-- Table: addresses
		CREATE TABLE IF NOT EXISTS addresses (
		id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
		street TEXT,
		city TEXT NOT NULL,
		state INTEGER,
		zip BIGINT,
		user_id UUID NOT NULL,
		created_at TIMESTAMP NOT NULL DEFAULT now(),
		updated_at TIMESTAMP);
		
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// DropTable drops the table.
func (t *addressStorage) DropTable() error {
	sqlQuery := `
		DROP TABLE IF EXISTS addresses;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *addressStorage) TruncateTable() error {
	sqlQuery := `
		TRUNCATE TABLE addresses;
	`

	_, err := t.db.Exec(sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
func (t *addressStorage) UpgradeTable() error {
	return nil
}

// Create creates a new Address.
func (t *addressStorage) Create(ctx context.Context, model *Address) (*string, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	query := t.queryBuilder.Insert("addresses").
		Columns(
			"street",
			"city",
			"state",
			"zip",
			"user_id",
			"created_at",
			"updated_at",
		).
		Values(
			model.Street,
			model.City,
			model.State,
			model.Zip,
			model.UserId,
			model.CreatedAt,
			model.UpdatedAt,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id string
	err = t.DB(ctx).QueryRow(sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create Address: %w", err)
	}

	return &id, nil
}

// Address is a struct for the "addresses" table.
type Address struct {
	Id        string `db:"id"`
	Street    string `db:"street"`
	City      string `db:"city"`
	State     int32  `db:"state"`
	Zip       int64  `db:"zip"`
	User      *User
	UserId    string     `db:"user_id"`
	CreatedAt time.Time  `db:"created_at"`
	UpdatedAt *time.Time `db:"updated_at"`
}

// ScanRow scans a row into a Address.
func (t *Address) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Street, &t.City, &t.State, &t.Zip, &t.UserId, &t.CreatedAt, &t.UpdatedAt)
}

// TableName returns the table name.
func (t *Address) TableName() string {
	return "addresses"
}

// Columns returns the columns for the table.
func (t *Address) Columns() []string {
	return []string{
		"id", "street", "city", "state", "zip", "user_id", "created_at", "updated_at",
	}
}
