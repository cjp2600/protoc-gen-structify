// Code generated by protoc-gen-structify. DO NOT EDIT.
// source: example/db/blog.proto
// provider: postgres
package db

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	_ "github.com/lib/pq"
	"strconv"
	"strings"
	"sync"
	"time"
)

// BlogDBClientOptions are the options for the BlogDBClient.
type BlogDBClientOptions struct {
	SSLMode string
	Timeout int
}

// Option is a function that configures the BlogDBClient.
type BlogDBClientOption func(*BlogDBClientOptions)

// WithSSLMode sets the SSL mode for the database connection.
func WithSSLMode(sslMode string) BlogDBClientOption {
	return func(opts *BlogDBClientOptions) {
		opts.SSLMode = sslMode
	}
}

// WithTimeout sets the timeout for the database connection.
func WithTimeout(timeout int) BlogDBClientOption {
	return func(opts *BlogDBClientOptions) {
		opts.Timeout = timeout
	}
}

// DBConnect connects to the database and returns a *sql.DB.
func DBConnect(host string, port int, user string, password string, dbname string, opts ...BlogDBClientOption) (*sql.DB, error) {
	options := &BlogDBClientOptions{}

	for _, opt := range opts {
		opt(options)
	}

	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s", host, port, user, password, dbname)

	if options.SSLMode != "" {
		psqlInfo += " sslmode=" + options.SSLMode
	}
	if options.Timeout != 0 {
		psqlInfo += " connect_timeout=" + strconv.Itoa(options.Timeout)
	}

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err = db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

// BlogDBClient is a map of provider to init function.
type BlogDBClient struct {
	db *sql.DB

	addressStore *AddressStore
	settingStore *SettingStore
	userStore    *UserStore
}

// NewBlogDBClient returns a new BlogDBClient. extra value
func NewBlogDBClient(db *sql.DB) *BlogDBClient {
	return &BlogDBClient{
		db: db,

		addressStore: &AddressStore{db: db},
		settingStore: &SettingStore{db: db},
		userStore:    &UserStore{db: db},
	}
}

// User returns the User store.
func (c *BlogDBClient) User() *UserStore {
	return c.userStore
}

// Setting returns the Setting store.
func (c *BlogDBClient) Setting() *SettingStore {
	return c.settingStore
}

// Address returns the Address store.
func (c *BlogDBClient) Address() *AddressStore {
	return c.addressStore
}

func (c *BlogDBClient) CreateTables() error {
	var err error

	_, err = c.db.Exec(c.userStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	_, err = c.db.Exec(c.settingStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	_, err = c.db.Exec(c.addressStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	return nil
}

// error row not found
var ErrRowNotFound = errors.New("row not found")

// ErrNoTransaction is returned when the transaction is nil.
var ErrNoTransaction = errors.New("no transaction provided")

type UserStore struct {
	db *sql.DB
}

// User is a struct for the "users" table.
type User struct {
	Id        string  `db:"id"`
	Name      string  `db:"name"`
	Age       int32   `db:"age"`
	Email     string  `db:"email"`
	LastName  *string `db:"last_name"`
	Settings  []*Setting
	Addresses []*Address
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

// SacnRow scans a row into the struct fields.
func (u *UserStore) ScanRow(row *sql.Row) (*User, error) {
	var model *User
	err := row.Scan(
		&model.Id,
		&model.Name,
		&model.Age,
		&model.Email,
		&model.LastName,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	return model, nil
}

// TableName returns the name of the table.
func (u *UserStore) TableName() string {
	return "users"
}

// Columns returns the database columns for the table.
func (u *UserStore) Columns() []string {
	return []string{"users.id", "users.name", "users.age", "users.email", "users.last_name", "users.created_at", "users.updated_at"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (u *UserStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS users (
id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
name TEXT NOT NULL,
age INTEGER NOT NULL,
email TEXT UNIQUE NOT NULL,
last_name TEXT,
created_at TIMESTAMP NOT NULL DEFAULT now(),
updated_at TIMESTAMP NOT NULL);COMMENT ON TABLE users IS 'This is a comment of User';`
}

// FindById returns a single row by ID.
func (u *UserStore) FindById(id string) (*User, error) {
	return u.FindOne(WhereUserIdEq(id))
}

// DeleteById returns a single row by ID.
func (u *UserStore) DeleteById(id string) (int64, error) {
	return u.Delete(WhereUserIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (u *UserStore) FindOne(conditions ...Condition) (*User, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	query := psql.Select(u.Columns()...).From(u.TableName())
	for _, condition := range conditions {
		query = condition.Apply(query)
	}
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}
	row := u.db.QueryRow(sqlQuery, args...)
	var model User
	err = row.Scan(&model.Id, &model.Name, &model.Age, &model.Email, &model.LastName, &model.CreatedAt, &model.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	// relations
	var wg sync.WaitGroup
	var findRelationErr error
	var mutex sync.Mutex

	wg.Add(1)
	go func() {
		defer wg.Done()
		settingsRelationStore := &SettingStore{db: u.db}

		settingsRelation, err := settingsRelationStore.FindMany(WhereSettingUserIdEq(model.Id), Limit(100))

		mutex.Lock()
		if err != nil && err != ErrRowNotFound && findRelationErr == nil {
			findRelationErr = fmt.Errorf("failed to find relation settings: %w", err)
		}
		if settingsRelation != nil {
			model.Settings = settingsRelation
		}
		mutex.Unlock()
	}()

	wg.Add(1)
	go func() {
		defer wg.Done()
		addressesRelationStore := &AddressStore{db: u.db}

		addressesRelation, err := addressesRelationStore.FindMany(WhereAddressUserIdEq(model.Id), Limit(3))

		mutex.Lock()
		if err != nil && err != ErrRowNotFound && findRelationErr == nil {
			findRelationErr = fmt.Errorf("failed to find relation addresses: %w", err)
		}
		if addressesRelation != nil {
			model.Addresses = addressesRelation
		}
		mutex.Unlock()
	}()

	wg.Wait()
	if findRelationErr != nil {
		return nil, findRelationErr
	}

	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (u *UserStore) FindMany(conditions ...Condition) ([]*User, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(u.Columns()...).From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := u.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var users []*User
	for rows.Next() {
		var model User
		err = rows.Scan(&model.Id, &model.Name, &model.Age, &model.Email, &model.LastName, &model.CreatedAt, &model.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		users = append(users, &model)
	}

	return users, nil
}

// Count returns the number of rows that match the provided conditions.
func (u *UserStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (u *UserStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(u.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := u.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (u *UserStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(u.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// UserUpdateRequest is the data required to update a row.
type UserUpdateRequest struct {
	Name      *string
	Age       *int32
	Email     *string
	LastName  *string
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// Update updates a row with the provided data.
func (u *UserStore) Update(ctx context.Context, id string, model *UserUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(u.TableName())
	if model.Name != nil {
		query = query.Set("name", model.Name)
	}
	if model.Age != nil {
		query = query.Set("age", model.Age)
	}
	if model.Email != nil {
		query = query.Set("email", model.Email)
	}
	if model.LastName != nil {
		query = query.Set("last_name", model.LastName)
	}
	if model.CreatedAt != nil {
		query = query.Set("created_at", model.CreatedAt)
	}
	if model.UpdatedAt != nil {
		query = query.Set("updated_at", model.UpdatedAt)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = u.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (u *UserStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *UserUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(u.TableName())
	if model.Name != nil {
		query = query.Set("name", model.Name)
	}
	if model.Age != nil {
		query = query.Set("age", model.Age)
	}
	if model.Email != nil {
		query = query.Set("email", model.Email)
	}
	if model.LastName != nil {
		query = query.Set("last_name", model.LastName)
	}
	if model.CreatedAt != nil {
		query = query.Set("created_at", model.CreatedAt)
	}
	if model.UpdatedAt != nil {
		query = query.Set("updated_at", model.UpdatedAt)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (u *UserStore) Create(ctx context.Context, model *User) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name", "created_at", "updated_at").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Age, model.Email, model.LastName, model.CreatedAt, model.UpdatedAt)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (u *UserStore) CreateWithTx(tx *sql.Tx, model *User) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name", "created_at", "updated_at").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Age, model.Email, model.LastName, model.CreatedAt, model.UpdatedAt)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (u *UserStore) CreateMany(ctx context.Context, models []*User) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name", "created_at", "updated_at")

	for _, model := range models {
		query = query.Values(model.Name, model.Age, model.Email, model.LastName, model.CreatedAt, model.UpdatedAt)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := u.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (u *UserStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*User) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name", "created_at", "updated_at")

	for _, model := range models {
		query = query.Values(model.Name, model.Age, model.Email, model.LastName, model.CreatedAt, model.UpdatedAt)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

type SettingStore struct {
	db *sql.DB
}

// Setting is a struct for the "settings" table.
type Setting struct {
	Id     string `db:"id"`
	Name   string `db:"name"`
	Value  string `db:"value"`
	User   *User
	UserId string `db:"user_id"`
}

// SacnRow scans a row into the struct fields.
func (s *SettingStore) ScanRow(row *sql.Row) (*Setting, error) {
	var model *Setting
	err := row.Scan(
		&model.Id,
		&model.Name,
		&model.Value,
		&model.UserId,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	return model, nil
}

// TableName returns the name of the table.
func (s *SettingStore) TableName() string {
	return "settings"
}

// Columns returns the database columns for the table.
func (s *SettingStore) Columns() []string {
	return []string{"settings.id", "settings.name", "settings.value", "settings.user_id"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (s *SettingStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS settings (
id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
name TEXT NOT NULL,
value TEXT NOT NULL,
user_id UUID NOT NULL);`
}

// FindById returns a single row by ID.
func (s *SettingStore) FindById(id string) (*Setting, error) {
	return s.FindOne(WhereSettingIdEq(id))
}

// DeleteById returns a single row by ID.
func (s *SettingStore) DeleteById(id string) (int64, error) {
	return s.Delete(WhereSettingIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (s *SettingStore) FindOne(conditions ...Condition) (*Setting, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	query := psql.Select(s.Columns()...).From(s.TableName())
	for _, condition := range conditions {
		query = condition.Apply(query)
	}
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}
	row := s.db.QueryRow(sqlQuery, args...)
	var model Setting
	err = row.Scan(&model.Id, &model.Name, &model.Value, &model.UserId)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	// relations
	var wg sync.WaitGroup
	var findRelationErr error
	var mutex sync.Mutex

	wg.Add(1)
	go func() {
		defer wg.Done()
		userRelationStore := &UserStore{db: s.db}

		userRelation, err := userRelationStore.FindOne(WhereUserIdEq(model.UserId))

		mutex.Lock()
		if err != nil && err != ErrRowNotFound && findRelationErr == nil {
			findRelationErr = fmt.Errorf("failed to find relation users: %w", err)
		}
		if userRelation != nil {
			model.User = userRelation
		}
		mutex.Unlock()
	}()

	wg.Wait()
	if findRelationErr != nil {
		return nil, findRelationErr
	}

	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (s *SettingStore) FindMany(conditions ...Condition) ([]*Setting, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(s.Columns()...).From(s.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := s.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var settings []*Setting
	for rows.Next() {
		var model Setting
		err = rows.Scan(&model.Id, &model.Name, &model.Value, &model.UserId)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		settings = append(settings, &model)
	}

	return settings, nil
}

// Count returns the number of rows that match the provided conditions.
func (s *SettingStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(s.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := s.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (s *SettingStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(s.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := s.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (s *SettingStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(s.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// SettingUpdateRequest is the data required to update a row.
type SettingUpdateRequest struct {
	Name   *string
	Value  *string
	UserId *string
}

// Update updates a row with the provided data.
func (s *SettingStore) Update(ctx context.Context, id string, model *SettingUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(s.TableName())
	if model.Name != nil {
		query = query.Set("name", model.Name)
	}
	if model.Value != nil {
		query = query.Set("value", model.Value)
	}
	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = s.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (s *SettingStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *SettingUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(s.TableName())
	if model.Name != nil {
		query = query.Set("name", model.Name)
	}
	if model.Value != nil {
		query = query.Set("value", model.Value)
	}
	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (s *SettingStore) Create(ctx context.Context, model *Setting) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(s.TableName()).
		Columns("name", "value", "user_id").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Value, model.UserId)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := s.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (s *SettingStore) CreateWithTx(tx *sql.Tx, model *Setting) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(s.TableName()).
		Columns("name", "value", "user_id").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Value, model.UserId)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (s *SettingStore) CreateMany(ctx context.Context, models []*Setting) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(s.TableName()).
		Columns("name", "value", "user_id")

	for _, model := range models {
		query = query.Values(model.Name, model.Value, model.UserId)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := s.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (s *SettingStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*Setting) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(s.TableName()).
		Columns("name", "value", "user_id")

	for _, model := range models {
		query = query.Values(model.Name, model.Value, model.UserId)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

type AddressStore struct {
	db *sql.DB
}

// Address is a struct for the "addresses" table.
type Address struct {
	Id        string `db:"id"`
	Street    string `db:"street"`
	City      string `db:"city"`
	State     int32  `db:"state"`
	Zip       int64  `db:"zip"`
	User      *User
	UserId    string    `db:"user_id"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

// SacnRow scans a row into the struct fields.
func (a *AddressStore) ScanRow(row *sql.Row) (*Address, error) {
	var model *Address
	err := row.Scan(
		&model.Id,
		&model.Street,
		&model.City,
		&model.State,
		&model.Zip,
		&model.UserId,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	return model, nil
}

// TableName returns the name of the table.
func (a *AddressStore) TableName() string {
	return "addresses"
}

// Columns returns the database columns for the table.
func (a *AddressStore) Columns() []string {
	return []string{"addresses.id", "addresses.street", "addresses.city", "addresses.state", "addresses.zip", "addresses.user_id", "addresses.created_at", "addresses.updated_at"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (a *AddressStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE IF NOT EXISTS addresses (
id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
street TEXT NOT NULL,
city TEXT NOT NULL,
state INTEGER NOT NULL,
zip BIGINT NOT NULL,
user_id UUID NOT NULL,
created_at TIMESTAMP NOT NULL,
updated_at TIMESTAMP NOT NULL);`
}

// FindById returns a single row by ID.
func (a *AddressStore) FindById(id string) (*Address, error) {
	return a.FindOne(WhereAddressIdEq(id))
}

// DeleteById returns a single row by ID.
func (a *AddressStore) DeleteById(id string) (int64, error) {
	return a.Delete(WhereAddressIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (a *AddressStore) FindOne(conditions ...Condition) (*Address, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	query := psql.Select(a.Columns()...).From(a.TableName())
	for _, condition := range conditions {
		query = condition.Apply(query)
	}
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}
	row := a.db.QueryRow(sqlQuery, args...)
	var model Address
	err = row.Scan(&model.Id, &model.Street, &model.City, &model.State, &model.Zip, &model.UserId, &model.CreatedAt, &model.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	// relations
	var wg sync.WaitGroup
	var findRelationErr error
	var mutex sync.Mutex

	wg.Add(1)
	go func() {
		defer wg.Done()
		userRelationStore := &UserStore{db: a.db}

		userRelation, err := userRelationStore.FindOne(WhereUserIdEq(model.UserId))

		mutex.Lock()
		if err != nil && err != ErrRowNotFound && findRelationErr == nil {
			findRelationErr = fmt.Errorf("failed to find relation users: %w", err)
		}
		if userRelation != nil {
			model.User = userRelation
		}
		mutex.Unlock()
	}()

	wg.Wait()
	if findRelationErr != nil {
		return nil, findRelationErr
	}

	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (a *AddressStore) FindMany(conditions ...Condition) ([]*Address, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(a.Columns()...).From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := a.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var addresses []*Address
	for rows.Next() {
		var model Address
		err = rows.Scan(&model.Id, &model.Street, &model.City, &model.State, &model.Zip, &model.UserId, &model.CreatedAt, &model.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		addresses = append(addresses, &model)
	}

	return addresses, nil
}

// Count returns the number of rows that match the provided conditions.
func (a *AddressStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (a *AddressStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(a.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := a.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (a *AddressStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(a.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// AddressUpdateRequest is the data required to update a row.
type AddressUpdateRequest struct {
	Street    *string
	City      *string
	State     *int32
	Zip       *int64
	UserId    *string
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// Update updates a row with the provided data.
func (a *AddressStore) Update(ctx context.Context, id string, model *AddressUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(a.TableName())
	if model.Street != nil {
		query = query.Set("street", model.Street)
	}
	if model.City != nil {
		query = query.Set("city", model.City)
	}
	if model.State != nil {
		query = query.Set("state", model.State)
	}
	if model.Zip != nil {
		query = query.Set("zip", model.Zip)
	}
	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}
	if model.CreatedAt != nil {
		query = query.Set("created_at", model.CreatedAt)
	}
	if model.UpdatedAt != nil {
		query = query.Set("updated_at", model.UpdatedAt)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = a.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (a *AddressStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *AddressUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(a.TableName())
	if model.Street != nil {
		query = query.Set("street", model.Street)
	}
	if model.City != nil {
		query = query.Set("city", model.City)
	}
	if model.State != nil {
		query = query.Set("state", model.State)
	}
	if model.Zip != nil {
		query = query.Set("zip", model.Zip)
	}
	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}
	if model.CreatedAt != nil {
		query = query.Set("created_at", model.CreatedAt)
	}
	if model.UpdatedAt != nil {
		query = query.Set("updated_at", model.UpdatedAt)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (a *AddressStore) Create(ctx context.Context, model *Address) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id", "created_at", "updated_at").
		Suffix("RETURNING \"id\"").
		Values(model.Street, model.City, model.State, model.Zip, model.UserId, model.CreatedAt, model.UpdatedAt)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (a *AddressStore) CreateWithTx(tx *sql.Tx, model *Address) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id", "created_at", "updated_at").
		Suffix("RETURNING \"id\"").
		Values(model.Street, model.City, model.State, model.Zip, model.UserId, model.CreatedAt, model.UpdatedAt)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (a *AddressStore) CreateMany(ctx context.Context, models []*Address) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id", "created_at", "updated_at")

	for _, model := range models {
		query = query.Values(model.Street, model.City, model.State, model.Zip, model.UserId, model.CreatedAt, model.UpdatedAt)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := a.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (a *AddressStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*Address) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id", "created_at", "updated_at")

	for _, model := range models {
		query = query.Values(model.Street, model.City, model.State, model.Zip, model.UserId, model.CreatedAt, model.UpdatedAt)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// Condition is a condition filters.
type Condition interface {
	Apply(query sq.SelectBuilder) sq.SelectBuilder
	ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder
}

// PageCondition is a condition that limits the number of rows returned based on the page number.
type PageCondition struct {
	PageSize uint64
	Page     uint64
}

// Page returns a condition that limits the number of rows returned based on the page number.
func Page(pageSize uint64, page uint64) Condition {
	return PageCondition{PageSize: pageSize, Page: page}
}

// Apply applies the condition to the query.
func (c PageCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	// Calculate offset based on the page number
	offset := c.PageSize * (c.Page - 1)
	return query.Limit(c.PageSize).Offset(offset)
}

// ApplyDelete applies the condition to the query.
func (c PageCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	// Calculate offset based on the page number
	offset := c.PageSize * (c.Page - 1)
	return query.Limit(c.PageSize).Offset(offset)
}

// PaginateCondition is a condition that limits the number of rows returned.
type PaginateCondition struct {
	Limit  uint64
	Offset uint64
}

// Paginate returns a condition that limits the number of rows returned.
func Paginate(limit uint64, offset uint64) Condition {
	return PaginateCondition{Limit: limit, Offset: offset}
}

// Apply applies the condition to the query.
func (c PaginateCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Limit(c.Limit).Offset(c.Offset)
}

// ApplyDelete applies the condition to the query.
func (c PaginateCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Limit(c.Limit).Offset(c.Offset)
}

// LimitCondition is a condition that limits the number of rows returned.
type LimitCondition struct {
	Limit uint64
}

// Limit returns a condition that limits the number of rows returned.
func Limit(limit uint64) Condition {
	return LimitCondition{Limit: limit}
}

// Apply applies the condition to the query.
func (c LimitCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Limit(c.Limit)
}

// ApplyDelete applies the condition to the query.
func (c LimitCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Limit(c.Limit)
}

// OffsetCondition is a condition that skips the first n rows.
type OffsetCondition struct {
	Offset uint64
}

// Offset returns a condition that skips the first n rows.
func Offset(offset uint64) Condition {
	return OffsetCondition{Offset: offset}
}

// Apply applies the condition to the query.
func (c OffsetCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Offset(c.Offset)
}

// ApplyDelete applies the condition to the query.
func (c OffsetCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Offset(c.Offset)
}

// And returns a condition that combines the given conditions with AND.
type AndCondition struct {
	Where []Condition
}

// And returns a condition that combines the given conditions with AND.
func And(conditions ...Condition) Condition {
	return AndCondition{Where: conditions}
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	for _, condition := range c.Where {
		query = condition.Apply(query)
	}
	return query
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	for _, condition := range c.Where {
		query = condition.ApplyDelete(query)
	}
	return query
}

// Or returns a condition that checks if any of the conditions are true.
type OrCondition struct {
	Conditions []Condition
}

func Or(conditions ...Condition) Condition {
	return OrCondition{Conditions: conditions}
}

// Apply applies the condition to the query.
func (c OrCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// Apply applies the condition to the query.
func (c OrCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// EqualsCondition equals condition.
type EqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c EqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

func (c EqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

// WhereEq returns a condition that checks if the field equals the value.
func WhereEq(field string, value interface{}) Condition {
	return EqualsCondition{Field: field, Value: value}
}

// WhereAddressIdEq returns a condition that checks if the field equals the value.
func WhereAddressIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// WhereAddressStreetEq returns a condition that checks if the field equals the value.
func WhereAddressStreetEq(value interface{}) Condition {
	return EqualsCondition{Field: "street", Value: value}
}

// WhereAddressCityEq returns a condition that checks if the field equals the value.
func WhereAddressCityEq(value interface{}) Condition {
	return EqualsCondition{Field: "city", Value: value}
}

// WhereAddressStateEq returns a condition that checks if the field equals the value.
func WhereAddressStateEq(value interface{}) Condition {
	return EqualsCondition{Field: "state", Value: value}
}

// WhereAddressZipEq returns a condition that checks if the field equals the value.
func WhereAddressZipEq(value interface{}) Condition {
	return EqualsCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdEq returns a condition that checks if the field equals the value.
func WhereAddressUserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtEq returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtEq(value interface{}) Condition {
	return EqualsCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtEq returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtEq(value interface{}) Condition {
	return EqualsCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdEq returns a condition that checks if the field equals the value.
func WhereSettingIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// WhereSettingNameEq returns a condition that checks if the field equals the value.
func WhereSettingNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "name", Value: value}
}

// WhereSettingValueEq returns a condition that checks if the field equals the value.
func WhereSettingValueEq(value interface{}) Condition {
	return EqualsCondition{Field: "value", Value: value}
}

// WhereSettingUserIdEq returns a condition that checks if the field equals the value.
func WhereSettingUserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "user_id", Value: value}
}

// WhereUserIdEq returns a condition that checks if the field equals the value.
func WhereUserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// WhereUserNameEq returns a condition that checks if the field equals the value.
func WhereUserNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "name", Value: value}
}

// WhereUserAgeEq returns a condition that checks if the field equals the value.
func WhereUserAgeEq(value interface{}) Condition {
	return EqualsCondition{Field: "age", Value: value}
}

// WhereUserEmailEq returns a condition that checks if the field equals the value.
func WhereUserEmailEq(value interface{}) Condition {
	return EqualsCondition{Field: "email", Value: value}
}

// WhereUserLastNameEq returns a condition that checks if the field equals the value.
func WhereUserLastNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtEq returns a condition that checks if the field equals the value.
func WhereUserCreatedAtEq(value interface{}) Condition {
	return EqualsCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtEq returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtEq(value interface{}) Condition {
	return EqualsCondition{Field: "updated_at", Value: value}
}

// ------------------------------

// NotEqualsCondition not equals condition.
type NotEqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotEqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotEqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// WhereNotEq returns a condition that checks if the field equals the value.
func WhereNotEq(field string, value interface{}) Condition {
	return NotEqualsCondition{Field: field, Value: value}
}

// WhereAddressIdNotEq returns a condition that checks if the field equals the value.
func WhereAddressIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// WhereAddressStreetNotEq returns a condition that checks if the field equals the value.
func WhereAddressStreetNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "street", Value: value}
}

// WhereAddressCityNotEq returns a condition that checks if the field equals the value.
func WhereAddressCityNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "city", Value: value}
}

// WhereAddressStateNotEq returns a condition that checks if the field equals the value.
func WhereAddressStateNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "state", Value: value}
}

// WhereAddressZipNotEq returns a condition that checks if the field equals the value.
func WhereAddressZipNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdNotEq returns a condition that checks if the field equals the value.
func WhereAddressUserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtNotEq returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtNotEq returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdNotEq returns a condition that checks if the field equals the value.
func WhereSettingIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// WhereSettingNameNotEq returns a condition that checks if the field equals the value.
func WhereSettingNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "name", Value: value}
}

// WhereSettingValueNotEq returns a condition that checks if the field equals the value.
func WhereSettingValueNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "value", Value: value}
}

// WhereSettingUserIdNotEq returns a condition that checks if the field equals the value.
func WhereSettingUserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// WhereUserIdNotEq returns a condition that checks if the field equals the value.
func WhereUserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// WhereUserNameNotEq returns a condition that checks if the field equals the value.
func WhereUserNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "name", Value: value}
}

// WhereUserAgeNotEq returns a condition that checks if the field equals the value.
func WhereUserAgeNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "age", Value: value}
}

// WhereUserEmailNotEq returns a condition that checks if the field equals the value.
func WhereUserEmailNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "email", Value: value}
}

// WhereUserLastNameNotEq returns a condition that checks if the field equals the value.
func WhereUserLastNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtNotEq returns a condition that checks if the field equals the value.
func WhereUserCreatedAtNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtNotEq returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// GreaterThanCondition greaterThanCondition than condition.
type GreaterThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// WhereGreaterThan returns a condition that checks if the field equals the value.
func WhereGreaterThan(field string, value interface{}) Condition {
	return GreaterThanCondition{Field: field, Value: value}
}

// WhereAddressIdGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// WhereAddressStreetGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressStreetGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "street", Value: value}
}

// WhereAddressCityGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressCityGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "city", Value: value}
}

// WhereAddressStateGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressStateGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "state", Value: value}
}

// WhereAddressZipGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressZipGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressUserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtGreaterThan returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdGreaterThan returns a condition that checks if the field equals the value.
func WhereSettingIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// WhereSettingNameGreaterThan returns a condition that checks if the field equals the value.
func WhereSettingNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "name", Value: value}
}

// WhereSettingValueGreaterThan returns a condition that checks if the field equals the value.
func WhereSettingValueGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "value", Value: value}
}

// WhereSettingUserIdGreaterThan returns a condition that checks if the field equals the value.
func WhereSettingUserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// WhereUserIdGreaterThan returns a condition that checks if the field equals the value.
func WhereUserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// WhereUserNameGreaterThan returns a condition that checks if the field equals the value.
func WhereUserNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "name", Value: value}
}

// WhereUserAgeGreaterThan returns a condition that checks if the field equals the value.
func WhereUserAgeGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "age", Value: value}
}

// WhereUserEmailGreaterThan returns a condition that checks if the field equals the value.
func WhereUserEmailGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "email", Value: value}
}

// WhereUserLastNameGreaterThan returns a condition that checks if the field equals the value.
func WhereUserLastNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtGreaterThan returns a condition that checks if the field equals the value.
func WhereUserCreatedAtGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtGreaterThan returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// LessThanCondition less than condition.
type LessThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// WhereLessThan returns a condition that checks if the field equals the value.
func WhereLessThan(field string, value interface{}) Condition {
	return LessThanCondition{Field: field, Value: value}
}

// WhereAddressIdLessThan returns a condition that checks if the field equals the value.
func WhereAddressIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// WhereAddressStreetLessThan returns a condition that checks if the field equals the value.
func WhereAddressStreetLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "street", Value: value}
}

// WhereAddressCityLessThan returns a condition that checks if the field equals the value.
func WhereAddressCityLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "city", Value: value}
}

// WhereAddressStateLessThan returns a condition that checks if the field equals the value.
func WhereAddressStateLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "state", Value: value}
}

// WhereAddressZipLessThan returns a condition that checks if the field equals the value.
func WhereAddressZipLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdLessThan returns a condition that checks if the field equals the value.
func WhereAddressUserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtLessThan returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtLessThan returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdLessThan returns a condition that checks if the field equals the value.
func WhereSettingIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// WhereSettingNameLessThan returns a condition that checks if the field equals the value.
func WhereSettingNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "name", Value: value}
}

// WhereSettingValueLessThan returns a condition that checks if the field equals the value.
func WhereSettingValueLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "value", Value: value}
}

// WhereSettingUserIdLessThan returns a condition that checks if the field equals the value.
func WhereSettingUserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "user_id", Value: value}
}

// WhereUserIdLessThan returns a condition that checks if the field equals the value.
func WhereUserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// WhereUserNameLessThan returns a condition that checks if the field equals the value.
func WhereUserNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "name", Value: value}
}

// WhereUserAgeLessThan returns a condition that checks if the field equals the value.
func WhereUserAgeLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "age", Value: value}
}

// WhereUserEmailLessThan returns a condition that checks if the field equals the value.
func WhereUserEmailLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "email", Value: value}
}

// WhereUserLastNameLessThan returns a condition that checks if the field equals the value.
func WhereUserLastNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtLessThan returns a condition that checks if the field equals the value.
func WhereUserCreatedAtLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtLessThan returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// LessThanOrEqualCondition less than or equal condition.
type GreaterThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// WhereGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereGreaterThanOrEqual(field string, value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: field, Value: value}
}

// WhereAddressIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// WhereAddressStreetGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStreetGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "street", Value: value}
}

// WhereAddressCityGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressCityGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "city", Value: value}
}

// WhereAddressStateGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStateGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "state", Value: value}
}

// WhereAddressZipGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressZipGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressUserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// WhereSettingNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// WhereSettingValueGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingValueGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "value", Value: value}
}

// WhereSettingUserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingUserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// WhereUserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// WhereUserNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// WhereUserAgeGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserAgeGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "age", Value: value}
}

// WhereUserEmailGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserEmailGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "email", Value: value}
}

// WhereUserLastNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserLastNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserCreatedAtGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtGreaterThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// LessThanOrEqualCondition less than or equal condition.
type LessThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

// WhereLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereLessThanOrEqual(field string, value interface{}) Condition {
	return LessThanOrEqualCondition{Field: field, Value: value}
}

// WhereAddressIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// WhereAddressStreetLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStreetLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "street", Value: value}
}

// WhereAddressCityLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressCityLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "city", Value: value}
}

// WhereAddressStateLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressStateLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "state", Value: value}
}

// WhereAddressZipLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressZipLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressUserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// WhereSettingNameLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// WhereSettingValueLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingValueLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "value", Value: value}
}

// WhereSettingUserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereSettingUserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// WhereUserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// WhereUserNameLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// WhereUserAgeLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserAgeLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "age", Value: value}
}

// WhereUserEmailLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserEmailLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "email", Value: value}
}

// WhereUserLastNameLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserLastNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserCreatedAtLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtLessThanOrEqual returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// LikeCondition like condition.
type LikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// WhereLike returns a condition that checks if the field equals the value.
func WhereLike(field string, value interface{}) Condition {
	return LikeCondition{Field: field, Value: value}
}

// WhereAddressIdLike returns a condition that checks if the field equals the value.
func WhereAddressIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// WhereAddressStreetLike returns a condition that checks if the field equals the value.
func WhereAddressStreetLike(value interface{}) Condition {
	return LikeCondition{Field: "street", Value: value}
}

// WhereAddressCityLike returns a condition that checks if the field equals the value.
func WhereAddressCityLike(value interface{}) Condition {
	return LikeCondition{Field: "city", Value: value}
}

// WhereAddressStateLike returns a condition that checks if the field equals the value.
func WhereAddressStateLike(value interface{}) Condition {
	return LikeCondition{Field: "state", Value: value}
}

// WhereAddressZipLike returns a condition that checks if the field equals the value.
func WhereAddressZipLike(value interface{}) Condition {
	return LikeCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdLike returns a condition that checks if the field equals the value.
func WhereAddressUserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtLike returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtLike(value interface{}) Condition {
	return LikeCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtLike returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtLike(value interface{}) Condition {
	return LikeCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdLike returns a condition that checks if the field equals the value.
func WhereSettingIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// WhereSettingNameLike returns a condition that checks if the field equals the value.
func WhereSettingNameLike(value interface{}) Condition {
	return LikeCondition{Field: "name", Value: value}
}

// WhereSettingValueLike returns a condition that checks if the field equals the value.
func WhereSettingValueLike(value interface{}) Condition {
	return LikeCondition{Field: "value", Value: value}
}

// WhereSettingUserIdLike returns a condition that checks if the field equals the value.
func WhereSettingUserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "user_id", Value: value}
}

// WhereUserIdLike returns a condition that checks if the field equals the value.
func WhereUserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// WhereUserNameLike returns a condition that checks if the field equals the value.
func WhereUserNameLike(value interface{}) Condition {
	return LikeCondition{Field: "name", Value: value}
}

// WhereUserAgeLike returns a condition that checks if the field equals the value.
func WhereUserAgeLike(value interface{}) Condition {
	return LikeCondition{Field: "age", Value: value}
}

// WhereUserEmailLike returns a condition that checks if the field equals the value.
func WhereUserEmailLike(value interface{}) Condition {
	return LikeCondition{Field: "email", Value: value}
}

// WhereUserLastNameLike returns a condition that checks if the field equals the value.
func WhereUserLastNameLike(value interface{}) Condition {
	return LikeCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtLike returns a condition that checks if the field equals the value.
func WhereUserCreatedAtLike(value interface{}) Condition {
	return LikeCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtLike returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtLike(value interface{}) Condition {
	return LikeCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// NotLikeCondition not like condition.
type NotLikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotLikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotLikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// WhereNotLike returns a condition that checks if the field equals the value.
func WhereNotLike(field string, value interface{}) Condition {
	return NotLikeCondition{Field: field, Value: value}
}

// WhereAddressIdNotLike returns a condition that checks if the field equals the value.
func WhereAddressIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// WhereAddressStreetNotLike returns a condition that checks if the field equals the value.
func WhereAddressStreetNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "street", Value: value}
}

// WhereAddressCityNotLike returns a condition that checks if the field equals the value.
func WhereAddressCityNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "city", Value: value}
}

// WhereAddressStateNotLike returns a condition that checks if the field equals the value.
func WhereAddressStateNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "state", Value: value}
}

// WhereAddressZipNotLike returns a condition that checks if the field equals the value.
func WhereAddressZipNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "zip", Value: value}
}

// WhereAddressUserIdNotLike returns a condition that checks if the field equals the value.
func WhereAddressUserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// WhereAddressCreatedAtNotLike returns a condition that checks if the field equals the value.
func WhereAddressCreatedAtNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "created_at", Value: value}
}

// WhereAddressUpdatedAtNotLike returns a condition that checks if the field equals the value.
func WhereAddressUpdatedAtNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "updated_at", Value: value}
}

// WhereSettingIdNotLike returns a condition that checks if the field equals the value.
func WhereSettingIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// WhereSettingNameNotLike returns a condition that checks if the field equals the value.
func WhereSettingNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "name", Value: value}
}

// WhereSettingValueNotLike returns a condition that checks if the field equals the value.
func WhereSettingValueNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "value", Value: value}
}

// WhereSettingUserIdNotLike returns a condition that checks if the field equals the value.
func WhereSettingUserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// WhereUserIdNotLike returns a condition that checks if the field equals the value.
func WhereUserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// WhereUserNameNotLike returns a condition that checks if the field equals the value.
func WhereUserNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "name", Value: value}
}

// WhereUserAgeNotLike returns a condition that checks if the field equals the value.
func WhereUserAgeNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "age", Value: value}
}

// WhereUserEmailNotLike returns a condition that checks if the field equals the value.
func WhereUserEmailNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "email", Value: value}
}

// WhereUserLastNameNotLike returns a condition that checks if the field equals the value.
func WhereUserLastNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "last_name", Value: value}
}

// WhereUserCreatedAtNotLike returns a condition that checks if the field equals the value.
func WhereUserCreatedAtNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "created_at", Value: value}
}

// WhereUserUpdatedAtNotLike returns a condition that checks if the field equals the value.
func WhereUserUpdatedAtNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "updated_at", Value: value}
}

// --------------------------------

// IsNullCondition represents the IS NULL condition.
type IsNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// WhereIsNull returns a condition that checks if the field is null.
func WhereIsNull(field string) Condition {
	return IsNullCondition{Field: field}
}

// WhereAddressIdIsNull returns a condition that checks if the field is null.
func WhereAddressIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// WhereAddressStreetIsNull returns a condition that checks if the field is null.
func WhereAddressStreetIsNull() Condition {
	return IsNullCondition{Field: "street"}
}

// WhereAddressCityIsNull returns a condition that checks if the field is null.
func WhereAddressCityIsNull() Condition {
	return IsNullCondition{Field: "city"}
}

// WhereAddressStateIsNull returns a condition that checks if the field is null.
func WhereAddressStateIsNull() Condition {
	return IsNullCondition{Field: "state"}
}

// WhereAddressZipIsNull returns a condition that checks if the field is null.
func WhereAddressZipIsNull() Condition {
	return IsNullCondition{Field: "zip"}
}

// WhereAddressUserIdIsNull returns a condition that checks if the field is null.
func WhereAddressUserIdIsNull() Condition {
	return IsNullCondition{Field: "user_id"}
}

// WhereAddressCreatedAtIsNull returns a condition that checks if the field is null.
func WhereAddressCreatedAtIsNull() Condition {
	return IsNullCondition{Field: "created_at"}
}

// WhereAddressUpdatedAtIsNull returns a condition that checks if the field is null.
func WhereAddressUpdatedAtIsNull() Condition {
	return IsNullCondition{Field: "updated_at"}
}

// WhereSettingIdIsNull returns a condition that checks if the field is null.
func WhereSettingIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// WhereSettingNameIsNull returns a condition that checks if the field is null.
func WhereSettingNameIsNull() Condition {
	return IsNullCondition{Field: "name"}
}

// WhereSettingValueIsNull returns a condition that checks if the field is null.
func WhereSettingValueIsNull() Condition {
	return IsNullCondition{Field: "value"}
}

// WhereSettingUserIdIsNull returns a condition that checks if the field is null.
func WhereSettingUserIdIsNull() Condition {
	return IsNullCondition{Field: "user_id"}
}

// WhereUserIdIsNull returns a condition that checks if the field is null.
func WhereUserIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// WhereUserNameIsNull returns a condition that checks if the field is null.
func WhereUserNameIsNull() Condition {
	return IsNullCondition{Field: "name"}
}

// WhereUserAgeIsNull returns a condition that checks if the field is null.
func WhereUserAgeIsNull() Condition {
	return IsNullCondition{Field: "age"}
}

// WhereUserEmailIsNull returns a condition that checks if the field is null.
func WhereUserEmailIsNull() Condition {
	return IsNullCondition{Field: "email"}
}

// WhereUserLastNameIsNull returns a condition that checks if the field is null.
func WhereUserLastNameIsNull() Condition {
	return IsNullCondition{Field: "last_name"}
}

// WhereUserCreatedAtIsNull returns a condition that checks if the field is null.
func WhereUserCreatedAtIsNull() Condition {
	return IsNullCondition{Field: "created_at"}
}

// WhereUserUpdatedAtIsNull returns a condition that checks if the field is null.
func WhereUserUpdatedAtIsNull() Condition {
	return IsNullCondition{Field: "updated_at"}
}

// --------------------------------

// IsNotNullCondition represents the IS NOT NULL condition.
type IsNotNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNotNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNotNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// WhereIsNotNull returns a condition that checks if the field is not null.
func WhereIsNotNull(field string) Condition {
	return IsNotNullCondition{Field: field}
}

// WhereAddressIdIsNotNull returns a condition that checks if the field is not null.
func WhereAddressIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// WhereAddressStreetIsNotNull returns a condition that checks if the field is not null.
func WhereAddressStreetIsNotNull() Condition {
	return IsNotNullCondition{Field: "street"}
}

// WhereAddressCityIsNotNull returns a condition that checks if the field is not null.
func WhereAddressCityIsNotNull() Condition {
	return IsNotNullCondition{Field: "city"}
}

// WhereAddressStateIsNotNull returns a condition that checks if the field is not null.
func WhereAddressStateIsNotNull() Condition {
	return IsNotNullCondition{Field: "state"}
}

// WhereAddressZipIsNotNull returns a condition that checks if the field is not null.
func WhereAddressZipIsNotNull() Condition {
	return IsNotNullCondition{Field: "zip"}
}

// WhereAddressUserIdIsNotNull returns a condition that checks if the field is not null.
func WhereAddressUserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "user_id"}
}

// WhereAddressCreatedAtIsNotNull returns a condition that checks if the field is not null.
func WhereAddressCreatedAtIsNotNull() Condition {
	return IsNotNullCondition{Field: "created_at"}
}

// WhereAddressUpdatedAtIsNotNull returns a condition that checks if the field is not null.
func WhereAddressUpdatedAtIsNotNull() Condition {
	return IsNotNullCondition{Field: "updated_at"}
}

// WhereSettingIdIsNotNull returns a condition that checks if the field is not null.
func WhereSettingIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// WhereSettingNameIsNotNull returns a condition that checks if the field is not null.
func WhereSettingNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "name"}
}

// WhereSettingValueIsNotNull returns a condition that checks if the field is not null.
func WhereSettingValueIsNotNull() Condition {
	return IsNotNullCondition{Field: "value"}
}

// WhereSettingUserIdIsNotNull returns a condition that checks if the field is not null.
func WhereSettingUserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "user_id"}
}

// WhereUserIdIsNotNull returns a condition that checks if the field is not null.
func WhereUserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// WhereUserNameIsNotNull returns a condition that checks if the field is not null.
func WhereUserNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "name"}
}

// WhereUserAgeIsNotNull returns a condition that checks if the field is not null.
func WhereUserAgeIsNotNull() Condition {
	return IsNotNullCondition{Field: "age"}
}

// WhereUserEmailIsNotNull returns a condition that checks if the field is not null.
func WhereUserEmailIsNotNull() Condition {
	return IsNotNullCondition{Field: "email"}
}

// WhereUserLastNameIsNotNull returns a condition that checks if the field is not null.
func WhereUserLastNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "last_name"}
}

// WhereUserCreatedAtIsNotNull returns a condition that checks if the field is not null.
func WhereUserCreatedAtIsNotNull() Condition {
	return IsNotNullCondition{Field: "created_at"}
}

// WhereUserUpdatedAtIsNotNull returns a condition that checks if the field is not null.
func WhereUserUpdatedAtIsNotNull() Condition {
	return IsNotNullCondition{Field: "updated_at"}
}

// --------------------------------

// InCondition represents the IN condition.
type InCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c InCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c InCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// WhereIn returns a condition that checks if the field is in the given values.
func WhereIn(field string, values ...interface{}) Condition {
	return InCondition{Field: field, Values: values}
}

// WhereAddressIdIn returns a condition that checks if the field is in the given values.
func WhereAddressIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// WhereAddressStreetIn returns a condition that checks if the field is in the given values.
func WhereAddressStreetIn(values ...interface{}) Condition {
	return InCondition{Field: "street", Values: values}
}

// WhereAddressCityIn returns a condition that checks if the field is in the given values.
func WhereAddressCityIn(values ...interface{}) Condition {
	return InCondition{Field: "city", Values: values}
}

// WhereAddressStateIn returns a condition that checks if the field is in the given values.
func WhereAddressStateIn(values ...interface{}) Condition {
	return InCondition{Field: "state", Values: values}
}

// WhereAddressZipIn returns a condition that checks if the field is in the given values.
func WhereAddressZipIn(values ...interface{}) Condition {
	return InCondition{Field: "zip", Values: values}
}

// WhereAddressUserIdIn returns a condition that checks if the field is in the given values.
func WhereAddressUserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "user_id", Values: values}
}

// WhereAddressCreatedAtIn returns a condition that checks if the field is in the given values.
func WhereAddressCreatedAtIn(values ...interface{}) Condition {
	return InCondition{Field: "created_at", Values: values}
}

// WhereAddressUpdatedAtIn returns a condition that checks if the field is in the given values.
func WhereAddressUpdatedAtIn(values ...interface{}) Condition {
	return InCondition{Field: "updated_at", Values: values}
}

// WhereSettingIdIn returns a condition that checks if the field is in the given values.
func WhereSettingIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// WhereSettingNameIn returns a condition that checks if the field is in the given values.
func WhereSettingNameIn(values ...interface{}) Condition {
	return InCondition{Field: "name", Values: values}
}

// WhereSettingValueIn returns a condition that checks if the field is in the given values.
func WhereSettingValueIn(values ...interface{}) Condition {
	return InCondition{Field: "value", Values: values}
}

// WhereSettingUserIdIn returns a condition that checks if the field is in the given values.
func WhereSettingUserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "user_id", Values: values}
}

// WhereUserIdIn returns a condition that checks if the field is in the given values.
func WhereUserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// WhereUserNameIn returns a condition that checks if the field is in the given values.
func WhereUserNameIn(values ...interface{}) Condition {
	return InCondition{Field: "name", Values: values}
}

// WhereUserAgeIn returns a condition that checks if the field is in the given values.
func WhereUserAgeIn(values ...interface{}) Condition {
	return InCondition{Field: "age", Values: values}
}

// WhereUserEmailIn returns a condition that checks if the field is in the given values.
func WhereUserEmailIn(values ...interface{}) Condition {
	return InCondition{Field: "email", Values: values}
}

// WhereUserLastNameIn returns a condition that checks if the field is in the given values.
func WhereUserLastNameIn(values ...interface{}) Condition {
	return InCondition{Field: "last_name", Values: values}
}

// WhereUserCreatedAtIn returns a condition that checks if the field is in the given values.
func WhereUserCreatedAtIn(values ...interface{}) Condition {
	return InCondition{Field: "created_at", Values: values}
}

// WhereUserUpdatedAtIn returns a condition that checks if the field is in the given values.
func WhereUserUpdatedAtIn(values ...interface{}) Condition {
	return InCondition{Field: "updated_at", Values: values}
}

// --------------------------------

// NotInCondition represents the NOT IN condition.
type NotInCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c NotInCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c NotInCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// WhereNotIn returns a condition that checks if the field is not in the given values.
func WhereNotIn(field string, values ...interface{}) Condition {
	return NotInCondition{Field: field, Values: values}
}

// WhereAddressIdNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// WhereAddressStreetNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressStreetNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "street", Values: values}
}

// WhereAddressCityNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressCityNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "city", Values: values}
}

// WhereAddressStateNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressStateNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "state", Values: values}
}

// WhereAddressZipNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressZipNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "zip", Values: values}
}

// WhereAddressUserIdNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressUserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "user_id", Values: values}
}

// WhereAddressCreatedAtNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressCreatedAtNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "created_at", Values: values}
}

// WhereAddressUpdatedAtNotIn returns a condition that checks if the field is not in the given values.
func WhereAddressUpdatedAtNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "updated_at", Values: values}
}

// WhereSettingIdNotIn returns a condition that checks if the field is not in the given values.
func WhereSettingIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// WhereSettingNameNotIn returns a condition that checks if the field is not in the given values.
func WhereSettingNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "name", Values: values}
}

// WhereSettingValueNotIn returns a condition that checks if the field is not in the given values.
func WhereSettingValueNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "value", Values: values}
}

// WhereSettingUserIdNotIn returns a condition that checks if the field is not in the given values.
func WhereSettingUserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "user_id", Values: values}
}

// WhereUserIdNotIn returns a condition that checks if the field is not in the given values.
func WhereUserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// WhereUserNameNotIn returns a condition that checks if the field is not in the given values.
func WhereUserNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "name", Values: values}
}

// WhereUserAgeNotIn returns a condition that checks if the field is not in the given values.
func WhereUserAgeNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "age", Values: values}
}

// WhereUserEmailNotIn returns a condition that checks if the field is not in the given values.
func WhereUserEmailNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "email", Values: values}
}

// WhereUserLastNameNotIn returns a condition that checks if the field is not in the given values.
func WhereUserLastNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "last_name", Values: values}
}

// WhereUserCreatedAtNotIn returns a condition that checks if the field is not in the given values.
func WhereUserCreatedAtNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "created_at", Values: values}
}

// WhereUserUpdatedAtNotIn returns a condition that checks if the field is not in the given values.
func WhereUserUpdatedAtNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "updated_at", Values: values}
}

// --------------------------------

// BetweenCondition represents the BETWEEN condition.
type BetweenCondition struct {
	Field string
	From  interface{}
	To    interface{}
}

// Apply applies the condition to the query.
func (c BetweenCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s BETWEEN ? AND ?", c.Field), c.From, c.To))
}

// ApplyDelete applies the condition to the query.
func (c BetweenCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s BETWEEN ? AND ?", c.Field), c.From, c.To))
}

// WhereBetween returns a condition that checks if the field is between the given values.
func WhereBetween(field string, from, to interface{}) Condition {
	return BetweenCondition{Field: field, From: from, To: to}
}

// WhereAddressIdBetween returns a condition that checks if the field is between the given values.
func WhereAddressIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// WhereAddressStreetBetween returns a condition that checks if the field is between the given values.
func WhereAddressStreetBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "street", From: from, To: to}
}

// WhereAddressCityBetween returns a condition that checks if the field is between the given values.
func WhereAddressCityBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "city", From: from, To: to}
}

// WhereAddressStateBetween returns a condition that checks if the field is between the given values.
func WhereAddressStateBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "state", From: from, To: to}
}

// WhereAddressZipBetween returns a condition that checks if the field is between the given values.
func WhereAddressZipBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "zip", From: from, To: to}
}

// WhereAddressUserIdBetween returns a condition that checks if the field is between the given values.
func WhereAddressUserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "user_id", From: from, To: to}
}

// WhereAddressCreatedAtBetween returns a condition that checks if the field is between the given values.
func WhereAddressCreatedAtBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "created_at", From: from, To: to}
}

// WhereAddressUpdatedAtBetween returns a condition that checks if the field is between the given values.
func WhereAddressUpdatedAtBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "updated_at", From: from, To: to}
}

// WhereSettingIdBetween returns a condition that checks if the field is between the given values.
func WhereSettingIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// WhereSettingNameBetween returns a condition that checks if the field is between the given values.
func WhereSettingNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "name", From: from, To: to}
}

// WhereSettingValueBetween returns a condition that checks if the field is between the given values.
func WhereSettingValueBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "value", From: from, To: to}
}

// WhereSettingUserIdBetween returns a condition that checks if the field is between the given values.
func WhereSettingUserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "user_id", From: from, To: to}
}

// WhereUserIdBetween returns a condition that checks if the field is between the given values.
func WhereUserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// WhereUserNameBetween returns a condition that checks if the field is between the given values.
func WhereUserNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "name", From: from, To: to}
}

// WhereUserAgeBetween returns a condition that checks if the field is between the given values.
func WhereUserAgeBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "age", From: from, To: to}
}

// WhereUserEmailBetween returns a condition that checks if the field is between the given values.
func WhereUserEmailBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "email", From: from, To: to}
}

// WhereUserLastNameBetween returns a condition that checks if the field is between the given values.
func WhereUserLastNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "last_name", From: from, To: to}
}

// WhereUserCreatedAtBetween returns a condition that checks if the field is between the given values.
func WhereUserCreatedAtBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "created_at", From: from, To: to}
}

// WhereUserUpdatedAtBetween returns a condition that checks if the field is between the given values.
func WhereUserUpdatedAtBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "updated_at", From: from, To: to}
}

// --------------------------------

// OrderCondition represents the ORDER BY condition.
type OrderCondition struct {
	Column string
	Asc    bool
}

// WhereOrderBy applies the condition to the query.
func WhereOrderBy(column string, asc bool) Condition {
	return OrderCondition{Column: column, Asc: asc}
}

// Apply applies the condition to the query.
func (c OrderCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	if c.Asc {
		return query.OrderBy(c.Column + " ASC")
	}
	return query.OrderBy(c.Column + " DESC")
}

func (c OrderCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query
}

// WhereAddressIdOrderBy returns a condition that orders the query by the given column.
func WhereAddressIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// WhereAddressStreetOrderBy returns a condition that orders the query by the given column.
func WhereAddressStreetOrderBy(asc bool) Condition {
	return OrderCondition{Column: "street", Asc: asc}
}

// WhereAddressCityOrderBy returns a condition that orders the query by the given column.
func WhereAddressCityOrderBy(asc bool) Condition {
	return OrderCondition{Column: "city", Asc: asc}
}

// WhereAddressStateOrderBy returns a condition that orders the query by the given column.
func WhereAddressStateOrderBy(asc bool) Condition {
	return OrderCondition{Column: "state", Asc: asc}
}

// WhereAddressZipOrderBy returns a condition that orders the query by the given column.
func WhereAddressZipOrderBy(asc bool) Condition {
	return OrderCondition{Column: "zip", Asc: asc}
}

// WhereAddressUserIdOrderBy returns a condition that orders the query by the given column.
func WhereAddressUserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "user_id", Asc: asc}
}

// WhereAddressCreatedAtOrderBy returns a condition that orders the query by the given column.
func WhereAddressCreatedAtOrderBy(asc bool) Condition {
	return OrderCondition{Column: "created_at", Asc: asc}
}

// WhereAddressUpdatedAtOrderBy returns a condition that orders the query by the given column.
func WhereAddressUpdatedAtOrderBy(asc bool) Condition {
	return OrderCondition{Column: "updated_at", Asc: asc}
}

// WhereSettingIdOrderBy returns a condition that orders the query by the given column.
func WhereSettingIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// WhereSettingNameOrderBy returns a condition that orders the query by the given column.
func WhereSettingNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "name", Asc: asc}
}

// WhereSettingValueOrderBy returns a condition that orders the query by the given column.
func WhereSettingValueOrderBy(asc bool) Condition {
	return OrderCondition{Column: "value", Asc: asc}
}

// WhereSettingUserIdOrderBy returns a condition that orders the query by the given column.
func WhereSettingUserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "user_id", Asc: asc}
}

// WhereUserIdOrderBy returns a condition that orders the query by the given column.
func WhereUserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// WhereUserNameOrderBy returns a condition that orders the query by the given column.
func WhereUserNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "name", Asc: asc}
}

// WhereUserAgeOrderBy returns a condition that orders the query by the given column.
func WhereUserAgeOrderBy(asc bool) Condition {
	return OrderCondition{Column: "age", Asc: asc}
}

// WhereUserEmailOrderBy returns a condition that orders the query by the given column.
func WhereUserEmailOrderBy(asc bool) Condition {
	return OrderCondition{Column: "email", Asc: asc}
}

// WhereUserLastNameOrderBy returns a condition that orders the query by the given column.
func WhereUserLastNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "last_name", Asc: asc}
}

// WhereUserCreatedAtOrderBy returns a condition that orders the query by the given column.
func WhereUserCreatedAtOrderBy(asc bool) Condition {
	return OrderCondition{Column: "created_at", Asc: asc}
}

// WhereUserUpdatedAtOrderBy returns a condition that orders the query by the given column.
func WhereUserUpdatedAtOrderBy(asc bool) Condition {
	return OrderCondition{Column: "updated_at", Asc: asc}
}

// --------------------------------

// DateAfterCondition represents the '>' condition for dates.
type DateAfterCondition struct {
	Field string
	Date  time.Time
}

// Apply applies the condition to the query.
func (c DateAfterCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s > $1", c.Field), c.Date))
}

// ApplyDelete applies the condition to the query.
func (c DateAfterCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s > $1", c.Field), c.Date))
}

// WhereDateAfter returns a condition that checks if the field is after the given date.
func WhereDateAfter(field string, date time.Time) Condition {
	return DateAfterCondition{Field: field, Date: date}
}

// DateBeforeCondition represents the '<' condition for dates.
type DateBeforeCondition struct {
	Field string
	Date  time.Time
}

// Apply applies the condition to the query.
func (c DateBeforeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s < $1", c.Field), c.Date))
}

// ApplyDelete applies the condition to the query.
func (c DateBeforeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s < $1", c.Field), c.Date))
}

// WhereDateBefore returns a condition that checks if the field is before the given date.
func WhereDateBefore(field string, date time.Time) Condition {
	return DateBeforeCondition{Field: field, Date: date}
}

// WhereAddressCreatedAtAfter returns a condition that checks if the field is after the given date.
func WhereAddressCreatedAtAfter(date time.Time) Condition {
	return DateAfterCondition{Field: "created_at", Date: date}
}

// WhereAddressCreatedAtBefore returns a condition that checks if the field is before the given date.
func WhereAddressCreatedAtBefore(date time.Time) Condition {
	return DateBeforeCondition{Field: "created_at", Date: date}
}

// WhereAddressUpdatedAtAfter returns a condition that checks if the field is after the given date.
func WhereAddressUpdatedAtAfter(date time.Time) Condition {
	return DateAfterCondition{Field: "updated_at", Date: date}
}

// WhereAddressUpdatedAtBefore returns a condition that checks if the field is before the given date.
func WhereAddressUpdatedAtBefore(date time.Time) Condition {
	return DateBeforeCondition{Field: "updated_at", Date: date}
}

// WhereUserCreatedAtAfter returns a condition that checks if the field is after the given date.
func WhereUserCreatedAtAfter(date time.Time) Condition {
	return DateAfterCondition{Field: "created_at", Date: date}
}

// WhereUserCreatedAtBefore returns a condition that checks if the field is before the given date.
func WhereUserCreatedAtBefore(date time.Time) Condition {
	return DateBeforeCondition{Field: "created_at", Date: date}
}

// WhereUserUpdatedAtAfter returns a condition that checks if the field is after the given date.
func WhereUserUpdatedAtAfter(date time.Time) Condition {
	return DateAfterCondition{Field: "updated_at", Date: date}
}

// WhereUserUpdatedAtBefore returns a condition that checks if the field is before the given date.
func WhereUserUpdatedAtBefore(date time.Time) Condition {
	return DateBeforeCondition{Field: "updated_at", Date: date}
}

// --------------------------------
// JSON
// --------------------------------

// JSONExistsCondition	exists condition.
type JSONExistsCondition struct {
	Field string
	Key   string
}

// Apply applies the condition to the query.
func (c JSONExistsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s -> '%s' IS NOT NULL", c.Field, c.Key)))
}

// ApplyDelete applies the condition to the query.
func (c JSONExistsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s -> '%s' IS NOT NULL", c.Field, c.Key)))
}

// JSONEqualsCondition equals condition.
type JSONEqualsCondition struct {
	Field string
	Key   string
	Value interface{}
}

// Apply applies the condition to the query.
func (c JSONEqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s ->> '%s' = ?", c.Field, c.Key), c.Value))
}

// ApplyDelete applies the condition to the query.
func (c JSONEqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s ->> '%s' = ?", c.Field, c.Key), c.Value))
}

// JSONContainsCondition contains condition.
type JSONContainsCondition struct {
	Field string
	Value string // This should be a JSON string
}

// Apply applies the condition to the query.
func (c JSONContainsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s @> ?", c.Field), c.Value))
}

// ApplyDelete applies the condition to the query.
func (c JSONContainsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s @> ?", c.Field), c.Value))
}

// JSONContainedInCondition contained in condition.
type JSONContainedInCondition struct {
	Field string
	Value string // This should be a JSON string
}

// Apply applies the condition to the query.
func (c JSONContainedInCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s <@ ?", c.Field), c.Value))
}

// ApplyDelete applies the condition to the query.
func (c JSONContainedInCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s <@ ?", c.Field), c.Value))
}

// WhereJSONExists returns a condition that checks if the JSON field contains the given key.
func WhereJSONExists(field string, key string) Condition {
	return JSONExistsCondition{Field: field, Key: key}
}

// WhereJSONEquals returns a condition that checks if the JSON field's key equals to the given value.
func WhereJSONEquals(field string, key string, value interface{}) Condition {
	return JSONEqualsCondition{Field: field, Key: key, Value: value}
}

// WhereJSONContains returns a condition that checks if the JSON field contains the given JSON value.
func WhereJSONContains(field string, value string) Condition {
	return JSONContainsCondition{Field: field, Value: value}
}

// WhereJSONContainedIn returns a condition that checks if the JSON field is contained in the given JSON value.
func WhereJSONContainedIn(field string, value string) Condition {
	return JSONContainedInCondition{Field: field, Value: value}
}
