// Code generated by protoc-gen-structify. DO NOT EDIT.
// source: example/db/blog.proto
// provider: postgres
package db

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	_ "github.com/lib/pq"
	"strconv"
	"strings"
)

// BlogDBClientOptions are the options for the BlogDBClient.
type BlogDBClientOptions struct {
	SSLMode string
	Timeout int
}

// Option is a function that configures the BlogDBClient.
type BlogDBClientOption func(*BlogDBClientOptions)

// WithSSLMode sets the SSL mode for the database connection.
func WithSSLMode(sslMode string) BlogDBClientOption {
	return func(opts *BlogDBClientOptions) {
		opts.SSLMode = sslMode
	}
}

// WithTimeout sets the timeout for the database connection.
func WithTimeout(timeout int) BlogDBClientOption {
	return func(opts *BlogDBClientOptions) {
		opts.Timeout = timeout
	}
}

// DBConnect connects to the database and returns a *sql.DB.
func DBConnect(host string, port int, user string, password string, dbname string, opts ...BlogDBClientOption) (*sql.DB, error) {
	options := &BlogDBClientOptions{}

	for _, opt := range opts {
		opt(options)
	}

	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s", host, port, user, password, dbname)

	if options.SSLMode != "" {
		psqlInfo += " sslmode=" + options.SSLMode
	}
	if options.Timeout != 0 {
		psqlInfo += " connect_timeout=" + strconv.Itoa(options.Timeout)
	}

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err = db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

// BlogDBClient is a map of provider to init function.
type BlogDBClient struct {
	db *sql.DB

	addressStore *AddressStore
	userStore    *UserStore
}

// NewBlogDBClient returns a new BlogDBClient. extra value
func NewBlogDBClient(db *sql.DB) *BlogDBClient {
	return &BlogDBClient{
		db: db,

		addressStore: &AddressStore{db: db},
		userStore:    &UserStore{db: db},
	}
}

// User returns the User store.
func (c *BlogDBClient) User() *UserStore {
	return c.userStore
}

// Address returns the Address store.
func (c *BlogDBClient) Address() *AddressStore {
	return c.addressStore
}

func (c *BlogDBClient) CreateTables() error {
	var err error

	_, err = c.db.Exec(c.userStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	_, err = c.db.Exec(c.addressStore.CreateTableSQL())
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	return nil
}

// error row not found
var ErrRowNotFound = errors.New("row not found")

// ErrNoTransaction is returned when the transaction is nil.
var ErrNoTransaction = errors.New("no transaction provided")

type UserStore struct {
	db *sql.DB
}

// User is a struct for the "users" table.
type User struct {
	Id       string `db:"id"`
	Name     string `db:"name"`
	Age      int32  `db:"age"`
	Email    string `db:"email"`
	LastName string `db:"last_name"`
}

// TableName returns the name of the table.
func (u *UserStore) TableName() string {
	return "users"
}

// Columns returns the database columns for the table.
func (u *UserStore) Columns() []string {
	return []string{"id", "name", "age", "email", "last_name"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (u *UserStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";CREATE TABLE IF NOT EXISTS users (
id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
name TEXT NOT NULL,
age INTEGER NOT NULL,
email TEXT UNIQUE NOT NULL,
last_name TEXT NOT NULL);COMMENT ON TABLE users IS 'This is a comment of User';`
}

// FindByID returns a single row by ID.
func (u *UserStore) FindById(id string) (*User, error) {
	return u.FindOne(UserIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (u *UserStore) FindOne(conditions ...Condition) (*User, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(u.Columns()...).From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRow(sqlQuery, args...)

	var model User
	err = row.Scan(&model.Id, &model.Name, &model.Age, &model.Email, &model.LastName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (u *UserStore) FindMany(conditions ...Condition) ([]User, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(u.Columns()...).From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := u.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var users []User
	for rows.Next() {
		var model User
		err = rows.Scan(&model.Id, &model.Name, &model.Age, &model.Email, &model.LastName)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		users = append(users, model)
	}

	return users, nil
}

// Count returns the number of rows that match the provided conditions.
func (u *UserStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(u.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (u *UserStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(u.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := u.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (u *UserStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(u.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// UserUpdateRequest is the data required to update a row.
type UserUpdateRequest struct {
	Name     *string
	Age      *int32
	Email    *string
	LastName *string
}

// Update updates a row with the provided data.
func (u *UserStore) Update(ctx context.Context, id string, model *UserUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(u.TableName())

	if model.Name != nil {
		query = query.Set("name", model.Name)
	}

	if model.Age != nil {
		query = query.Set("age", model.Age)
	}

	if model.Email != nil {
		query = query.Set("email", model.Email)
	}

	if model.LastName != nil {
		query = query.Set("last_name", model.LastName)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = u.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (u *UserStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *UserUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(u.TableName())

	if model.Name != nil {
		query = query.Set("name", model.Name)
	}

	if model.Age != nil {
		query = query.Set("age", model.Age)
	}

	if model.Email != nil {
		query = query.Set("email", model.Email)
	}

	if model.LastName != nil {
		query = query.Set("last_name", model.LastName)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (u *UserStore) Create(ctx context.Context, model *User) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Age, model.Email, model.LastName)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := u.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (u *UserStore) CreateWithTx(tx *sql.Tx, model *User) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name").
		Suffix("RETURNING \"id\"").
		Values(model.Name, model.Age, model.Email, model.LastName)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (u *UserStore) CreateMany(ctx context.Context, models []*User) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name")

	for _, model := range models {
		query = query.Values(model.Name, model.Age, model.Email, model.LastName)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := u.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (u *UserStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*User) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(u.TableName()).
		Columns("name", "age", "email", "last_name")

	for _, model := range models {
		query = query.Values(model.Name, model.Age, model.Email, model.LastName)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

type AddressStore struct {
	db *sql.DB
}

// Address is a struct for the "addresses" table.
type Address struct {
	Id     string `db:"id"`
	Street string `db:"street"`
	City   string `db:"city"`
	State  int32  `db:"state"`
	Zip    int64  `db:"zip"`
	UserId string `db:"user_id"`
}

// TableName returns the name of the table.
func (a *AddressStore) TableName() string {
	return "addresses"
}

// Columns returns the database columns for the table.
func (a *AddressStore) Columns() []string {
	return []string{"id", "street", "city", "state", "zip", "user_id"}
}

// CreateTableSQL returns the SQL statement to create the table.
func (a *AddressStore) CreateTableSQL() string {
	return `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";CREATE TABLE IF NOT EXISTS addresses (
id TEXT PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
street TEXT NOT NULL,
city TEXT NOT NULL,
state INTEGER NOT NULL,
zip BIGINT NOT NULL,
user_id TEXT NOT NULL);`
}

// FindByID returns a single row by ID.
func (a *AddressStore) FindById(id string) (*Address, error) {
	return a.FindOne(AddressIdEq(id))
}

// FindOne filters rows by the provided conditions and returns the first matching row.
func (a *AddressStore) FindOne(conditions ...Condition) (*Address, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(a.Columns()...).From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRow(sqlQuery, args...)

	var model Address
	err = row.Scan(&model.Id, &model.Street, &model.City, &model.State, &model.Zip, &model.UserId)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRowNotFound
		}
		return nil, fmt.Errorf("failed to scan row: %w", err)
	}

	return &model, nil
}

// FindMany filters rows by the provided conditions and returns matching rows.
func (a *AddressStore) FindMany(conditions ...Condition) ([]Address, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select(a.Columns()...).From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := a.db.Query(sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var addresses []Address
	for rows.Next() {
		var model Address
		err = rows.Scan(&model.Id, &model.Street, &model.City, &model.State, &model.Zip, &model.UserId)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}
		addresses = append(addresses, model)
	}

	return addresses, nil
}

// Count returns the number of rows that match the provided conditions.
func (a *AddressStore) Count(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Select("COUNT(*)").From(a.TableName())

	for _, condition := range conditions {
		query = condition.Apply(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRow(sqlQuery, args...)

	var count int64
	err = row.Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	return count, nil
}

// Delete deletes rows that match the provided conditions.
func (a *AddressStore) Delete(conditions ...Condition) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(a.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := a.db.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// DeleteWithTx deletes rows that match the provided conditions inside a transaction.
func (a *AddressStore) DeleteWithTx(tx *sql.Tx, conditions ...Condition) (int64, error) {
	if tx == nil {
		return 0, ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Delete(a.TableName())

	for _, condition := range conditions {
		query = condition.ApplyDelete(query)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build sql: %w", err)
	}

	result, err := tx.Exec(sqlQuery, args...)
	if err != nil {
		return 0, fmt.Errorf("failed to execute query: %w", err)
	}

	deletedRows, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("failed to get affected rows: %w", err)
	}

	return deletedRows, nil
}

// AddressUpdateRequest is the data required to update a row.
type AddressUpdateRequest struct {
	Street *string
	City   *string
	State  *int32
	Zip    *int64
	UserId *string
}

// Update updates a row with the provided data.
func (a *AddressStore) Update(ctx context.Context, id string, model *AddressUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(a.TableName())

	if model.Street != nil {
		query = query.Set("street", model.Street)
	}

	if model.City != nil {
		query = query.Set("city", model.City)
	}

	if model.State != nil {
		query = query.Set("state", model.State)
	}

	if model.Zip != nil {
		query = query.Set("zip", model.Zip)
	}

	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = a.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// UpdateWithTx updates a row with the provided data inside a transaction.
func (a *AddressStore) UpdateWithTx(ctx context.Context, tx *sql.Tx, id string, model *AddressUpdateRequest) error {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Update(a.TableName())

	if model.Street != nil {
		query = query.Set("street", model.Street)
	}

	if model.City != nil {
		query = query.Set("city", model.City)
	}

	if model.State != nil {
		query = query.Set("state", model.State)
	}

	if model.Zip != nil {
		query = query.Set("zip", model.Zip)
	}

	if model.UserId != nil {
		query = query.Set("user_id", model.UserId)
	}

	query = query.Where(sq.Eq{"id": id})

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build sql: %w", err)
	}

	_, err = tx.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to execute query: %w", err)
	}

	return nil
}

// Create inserts a new row into the database.
func (a *AddressStore) Create(ctx context.Context, model *Address) (string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id").
		Suffix("RETURNING \"id\"").
		Values(model.Street, model.City, model.State, model.Zip, model.UserId)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := a.db.QueryRowContext(ctx, sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateWithTx inserts a new row into the database inside a transaction.
func (a *AddressStore) CreateWithTx(tx *sql.Tx, model *Address) (string, error) {
	if tx == nil {
		return "", ErrNoTransaction
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id").
		Suffix("RETURNING \"id\"").
		Values(model.Street, model.City, model.State, model.Zip, model.UserId)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return "", fmt.Errorf("failed to build sql: %w", err)
	}

	row := tx.QueryRow(sqlQuery, args...)
	if err != nil {
		return "", fmt.Errorf("failed to execute query: %w", err)
	}

	var id string
	if err := row.Scan(&id); err != nil {
		return "", fmt.Errorf("failed to scan id: %w", err)
	}

	return id, nil
}

// CreateMany inserts multiple rows into the database.
func (a *AddressStore) CreateMany(ctx context.Context, models []*Address) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id")

	for _, model := range models {
		query = query.Values(model.Street, model.City, model.State, model.Zip, model.UserId)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := a.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// CreateManyWithTx inserts multiple rows into the database inside a transaction.
func (a *AddressStore) CreateManyWithTx(ctx context.Context, tx *sql.Tx, models []*Address) ([]string, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	query := psql.Insert(a.TableName()).
		Columns("street", "city", "state", "zip", "user_id")

	for _, model := range models {
		query = query.Values(model.Street, model.City, model.State, model.Zip, model.UserId)
	}

	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build sql: %w", err)
	}

	rows, err := tx.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("failed to scan id: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return ids, nil
}

// Condition is a condition filters.
type Condition interface {
	Apply(query sq.SelectBuilder) sq.SelectBuilder
	ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder
}

// PageCondition is a condition that limits the number of rows returned based on the page number.
type PageCondition struct {
	PageSize uint64
	Page     uint64
}

// Page returns a condition that limits the number of rows returned based on the page number.
func Page(pageSize uint64, page uint64) Condition {
	return PageCondition{PageSize: pageSize, Page: page}
}

// Apply applies the condition to the query.
func (c PageCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	// Calculate offset based on the page number
	offset := c.PageSize * (c.Page - 1)
	return query.Limit(c.PageSize).Offset(offset)
}

// ApplyDelete applies the condition to the query.
func (c PageCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	// Calculate offset based on the page number
	offset := c.PageSize * (c.Page - 1)
	return query.Limit(c.PageSize).Offset(offset)
}

// PaginateCondition is a condition that limits the number of rows returned.
type PaginateCondition struct {
	Limit  uint64
	Offset uint64
}

// Paginate returns a condition that limits the number of rows returned.
func Paginate(limit uint64, offset uint64) Condition {
	return PaginateCondition{Limit: limit, Offset: offset}
}

// Apply applies the condition to the query.
func (c PaginateCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Limit(c.Limit).Offset(c.Offset)
}

// ApplyDelete applies the condition to the query.
func (c PaginateCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Limit(c.Limit).Offset(c.Offset)
}

// LimitCondition is a condition that limits the number of rows returned.
type LimitCondition struct {
	Limit uint64
}

// Limit returns a condition that limits the number of rows returned.
func Limit(limit uint64) Condition {
	return LimitCondition{Limit: limit}
}

// Apply applies the condition to the query.
func (c LimitCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Limit(c.Limit)
}

// ApplyDelete applies the condition to the query.
func (c LimitCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Limit(c.Limit)
}

// OffsetCondition is a condition that skips the first n rows.
type OffsetCondition struct {
	Offset uint64
}

// Offset returns a condition that skips the first n rows.
func Offset(offset uint64) Condition {
	return OffsetCondition{Offset: offset}
}

// Apply applies the condition to the query.
func (c OffsetCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Offset(c.Offset)
}

// ApplyDelete applies the condition to the query.
func (c OffsetCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Offset(c.Offset)
}

// And returns a condition that combines the given conditions with AND.
type AndCondition struct {
	Where []Condition
}

// And returns a condition that combines the given conditions with AND.
func And(conditions ...Condition) Condition {
	return AndCondition{Where: conditions}
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	for _, condition := range c.Where {
		query = condition.Apply(query)
	}
	return query
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	for _, condition := range c.Where {
		query = condition.ApplyDelete(query)
	}
	return query
}

// Or returns a condition that checks if any of the conditions are true.
type OrCondition struct {
	Conditions []Condition
}

func Or(conditions ...Condition) Condition {
	return OrCondition{Conditions: conditions}
}

// Apply applies the condition to the query.
func (c OrCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// Apply applies the condition to the query.
func (c OrCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// EqualsCondition equals condition.
type EqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c EqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

func (c EqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

// Eq returns a condition that checks if the field equals the value.
func Eq(field string, value interface{}) Condition {
	return EqualsCondition{Field: field, Value: value}
}

// AddressIdEq returns a condition that checks if the field equals the value.
func AddressIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// AddressStreetEq returns a condition that checks if the field equals the value.
func AddressStreetEq(value interface{}) Condition {
	return EqualsCondition{Field: "street", Value: value}
}

// AddressCityEq returns a condition that checks if the field equals the value.
func AddressCityEq(value interface{}) Condition {
	return EqualsCondition{Field: "city", Value: value}
}

// AddressStateEq returns a condition that checks if the field equals the value.
func AddressStateEq(value interface{}) Condition {
	return EqualsCondition{Field: "state", Value: value}
}

// AddressZipEq returns a condition that checks if the field equals the value.
func AddressZipEq(value interface{}) Condition {
	return EqualsCondition{Field: "zip", Value: value}
}

// AddressUserIdEq returns a condition that checks if the field equals the value.
func AddressUserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "user_id", Value: value}
}

// UserIdEq returns a condition that checks if the field equals the value.
func UserIdEq(value interface{}) Condition {
	return EqualsCondition{Field: "id", Value: value}
}

// UserNameEq returns a condition that checks if the field equals the value.
func UserNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "name", Value: value}
}

// UserAgeEq returns a condition that checks if the field equals the value.
func UserAgeEq(value interface{}) Condition {
	return EqualsCondition{Field: "age", Value: value}
}

// UserEmailEq returns a condition that checks if the field equals the value.
func UserEmailEq(value interface{}) Condition {
	return EqualsCondition{Field: "email", Value: value}
}

// UserLastNameEq returns a condition that checks if the field equals the value.
func UserLastNameEq(value interface{}) Condition {
	return EqualsCondition{Field: "last_name", Value: value}
}

// ------------------------------

// NotEqualsCondition not equals condition.
type NotEqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotEqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotEqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// NotEq returns a condition that checks if the field equals the value.
func NotEq(field string, value interface{}) Condition {
	return NotEqualsCondition{Field: field, Value: value}
}

// AddressIdNotEq returns a condition that checks if the field equals the value.
func AddressIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// AddressStreetNotEq returns a condition that checks if the field equals the value.
func AddressStreetNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "street", Value: value}
}

// AddressCityNotEq returns a condition that checks if the field equals the value.
func AddressCityNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "city", Value: value}
}

// AddressStateNotEq returns a condition that checks if the field equals the value.
func AddressStateNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "state", Value: value}
}

// AddressZipNotEq returns a condition that checks if the field equals the value.
func AddressZipNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "zip", Value: value}
}

// AddressUserIdNotEq returns a condition that checks if the field equals the value.
func AddressUserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// UserIdNotEq returns a condition that checks if the field equals the value.
func UserIdNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "id", Value: value}
}

// UserNameNotEq returns a condition that checks if the field equals the value.
func UserNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "name", Value: value}
}

// UserAgeNotEq returns a condition that checks if the field equals the value.
func UserAgeNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "age", Value: value}
}

// UserEmailNotEq returns a condition that checks if the field equals the value.
func UserEmailNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "email", Value: value}
}

// UserLastNameNotEq returns a condition that checks if the field equals the value.
func UserLastNameNotEq(value interface{}) Condition {
	return NotEqualsCondition{Field: "last_name", Value: value}
}

// --------------------------------

// GreaterThanCondition greaterThanCondition than condition.
type GreaterThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// GreaterThan returns a condition that checks if the field equals the value.
func GreaterThan(field string, value interface{}) Condition {
	return GreaterThanCondition{Field: field, Value: value}
}

// AddressIdGreaterThan returns a condition that checks if the field equals the value.
func AddressIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// AddressStreetGreaterThan returns a condition that checks if the field equals the value.
func AddressStreetGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "street", Value: value}
}

// AddressCityGreaterThan returns a condition that checks if the field equals the value.
func AddressCityGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "city", Value: value}
}

// AddressStateGreaterThan returns a condition that checks if the field equals the value.
func AddressStateGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "state", Value: value}
}

// AddressZipGreaterThan returns a condition that checks if the field equals the value.
func AddressZipGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "zip", Value: value}
}

// AddressUserIdGreaterThan returns a condition that checks if the field equals the value.
func AddressUserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// UserIdGreaterThan returns a condition that checks if the field equals the value.
func UserIdGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "id", Value: value}
}

// UserNameGreaterThan returns a condition that checks if the field equals the value.
func UserNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "name", Value: value}
}

// UserAgeGreaterThan returns a condition that checks if the field equals the value.
func UserAgeGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "age", Value: value}
}

// UserEmailGreaterThan returns a condition that checks if the field equals the value.
func UserEmailGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "email", Value: value}
}

// UserLastNameGreaterThan returns a condition that checks if the field equals the value.
func UserLastNameGreaterThan(value interface{}) Condition {
	return GreaterThanCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LessThanCondition less than condition.
type LessThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// LessThan returns a condition that checks if the field equals the value.
func LessThan(field string, value interface{}) Condition {
	return LessThanCondition{Field: field, Value: value}
}

// AddressIdLessThan returns a condition that checks if the field equals the value.
func AddressIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// AddressStreetLessThan returns a condition that checks if the field equals the value.
func AddressStreetLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "street", Value: value}
}

// AddressCityLessThan returns a condition that checks if the field equals the value.
func AddressCityLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "city", Value: value}
}

// AddressStateLessThan returns a condition that checks if the field equals the value.
func AddressStateLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "state", Value: value}
}

// AddressZipLessThan returns a condition that checks if the field equals the value.
func AddressZipLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "zip", Value: value}
}

// AddressUserIdLessThan returns a condition that checks if the field equals the value.
func AddressUserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "user_id", Value: value}
}

// UserIdLessThan returns a condition that checks if the field equals the value.
func UserIdLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "id", Value: value}
}

// UserNameLessThan returns a condition that checks if the field equals the value.
func UserNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "name", Value: value}
}

// UserAgeLessThan returns a condition that checks if the field equals the value.
func UserAgeLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "age", Value: value}
}

// UserEmailLessThan returns a condition that checks if the field equals the value.
func UserEmailLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "email", Value: value}
}

// UserLastNameLessThan returns a condition that checks if the field equals the value.
func UserLastNameLessThan(value interface{}) Condition {
	return LessThanCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LessThanOrEqualCondition less than or equal condition.
type GreaterThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// GreaterThanOrEqual returns a condition that checks if the field equals the value.
func GreaterThanOrEqual(field string, value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: field, Value: value}
}

// AddressIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func AddressIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// AddressStreetGreaterThanOrEqual returns a condition that checks if the field equals the value.
func AddressStreetGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "street", Value: value}
}

// AddressCityGreaterThanOrEqual returns a condition that checks if the field equals the value.
func AddressCityGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "city", Value: value}
}

// AddressStateGreaterThanOrEqual returns a condition that checks if the field equals the value.
func AddressStateGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "state", Value: value}
}

// AddressZipGreaterThanOrEqual returns a condition that checks if the field equals the value.
func AddressZipGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "zip", Value: value}
}

// AddressUserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func AddressUserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// UserIdGreaterThanOrEqual returns a condition that checks if the field equals the value.
func UserIdGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// UserNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func UserNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// UserAgeGreaterThanOrEqual returns a condition that checks if the field equals the value.
func UserAgeGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "age", Value: value}
}

// UserEmailGreaterThanOrEqual returns a condition that checks if the field equals the value.
func UserEmailGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "email", Value: value}
}

// UserLastNameGreaterThanOrEqual returns a condition that checks if the field equals the value.
func UserLastNameGreaterThanOrEqual(value interface{}) Condition {
	return GreaterThanOrEqualCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LessThanOrEqualCondition less than or equal condition.
type LessThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

func LessThanOrEqual(field string, value interface{}) Condition {
	return LessThanOrEqualCondition{Field: field, Value: value}
}

// AddressIdLessThanOrEqual returns a condition that checks if the field equals the value.
func AddressIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// AddressStreetLessThanOrEqual returns a condition that checks if the field equals the value.
func AddressStreetLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "street", Value: value}
}

// AddressCityLessThanOrEqual returns a condition that checks if the field equals the value.
func AddressCityLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "city", Value: value}
}

// AddressStateLessThanOrEqual returns a condition that checks if the field equals the value.
func AddressStateLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "state", Value: value}
}

// AddressZipLessThanOrEqual returns a condition that checks if the field equals the value.
func AddressZipLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "zip", Value: value}
}

// AddressUserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func AddressUserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// UserIdLessThanOrEqual returns a condition that checks if the field equals the value.
func UserIdLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// UserNameLessThanOrEqual returns a condition that checks if the field equals the value.
func UserNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// UserAgeLessThanOrEqual returns a condition that checks if the field equals the value.
func UserAgeLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "age", Value: value}
}

// UserEmailLessThanOrEqual returns a condition that checks if the field equals the value.
func UserEmailLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "email", Value: value}
}

// UserLastNameLessThanOrEqual returns a condition that checks if the field equals the value.
func UserLastNameLessThanOrEqual(value interface{}) Condition {
	return LessThanOrEqualCondition{Field: "last_name", Value: value}
}

// --------------------------------

// LikeCondition like condition.
type LikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// Like returns a condition that checks if the field equals the value.
func Like(field string, value interface{}) Condition {
	return LikeCondition{Field: field, Value: value}
}

// AddressIdLike returns a condition that checks if the field equals the value.
func AddressIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// AddressStreetLike returns a condition that checks if the field equals the value.
func AddressStreetLike(value interface{}) Condition {
	return LikeCondition{Field: "street", Value: value}
}

// AddressCityLike returns a condition that checks if the field equals the value.
func AddressCityLike(value interface{}) Condition {
	return LikeCondition{Field: "city", Value: value}
}

// AddressStateLike returns a condition that checks if the field equals the value.
func AddressStateLike(value interface{}) Condition {
	return LikeCondition{Field: "state", Value: value}
}

// AddressZipLike returns a condition that checks if the field equals the value.
func AddressZipLike(value interface{}) Condition {
	return LikeCondition{Field: "zip", Value: value}
}

// AddressUserIdLike returns a condition that checks if the field equals the value.
func AddressUserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "user_id", Value: value}
}

// UserIdLike returns a condition that checks if the field equals the value.
func UserIdLike(value interface{}) Condition {
	return LikeCondition{Field: "id", Value: value}
}

// UserNameLike returns a condition that checks if the field equals the value.
func UserNameLike(value interface{}) Condition {
	return LikeCondition{Field: "name", Value: value}
}

// UserAgeLike returns a condition that checks if the field equals the value.
func UserAgeLike(value interface{}) Condition {
	return LikeCondition{Field: "age", Value: value}
}

// UserEmailLike returns a condition that checks if the field equals the value.
func UserEmailLike(value interface{}) Condition {
	return LikeCondition{Field: "email", Value: value}
}

// UserLastNameLike returns a condition that checks if the field equals the value.
func UserLastNameLike(value interface{}) Condition {
	return LikeCondition{Field: "last_name", Value: value}
}

// --------------------------------

// NotLikeCondition not like condition.
type NotLikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotLikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotLikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// NotLike returns a condition that checks if the field equals the value.
func NotLike(field string, value interface{}) Condition {
	return NotLikeCondition{Field: field, Value: value}
}

// AddressIdNotLike returns a condition that checks if the field equals the value.
func AddressIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// AddressStreetNotLike returns a condition that checks if the field equals the value.
func AddressStreetNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "street", Value: value}
}

// AddressCityNotLike returns a condition that checks if the field equals the value.
func AddressCityNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "city", Value: value}
}

// AddressStateNotLike returns a condition that checks if the field equals the value.
func AddressStateNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "state", Value: value}
}

// AddressZipNotLike returns a condition that checks if the field equals the value.
func AddressZipNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "zip", Value: value}
}

// AddressUserIdNotLike returns a condition that checks if the field equals the value.
func AddressUserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// UserIdNotLike returns a condition that checks if the field equals the value.
func UserIdNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "id", Value: value}
}

// UserNameNotLike returns a condition that checks if the field equals the value.
func UserNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "name", Value: value}
}

// UserAgeNotLike returns a condition that checks if the field equals the value.
func UserAgeNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "age", Value: value}
}

// UserEmailNotLike returns a condition that checks if the field equals the value.
func UserEmailNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "email", Value: value}
}

// UserLastNameNotLike returns a condition that checks if the field equals the value.
func UserLastNameNotLike(value interface{}) Condition {
	return NotLikeCondition{Field: "last_name", Value: value}
}

// --------------------------------

// IsNullCondition represents the IS NULL condition.
type IsNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// IsNull returns a condition that checks if the field is null.
func IsNull(field string) Condition {
	return IsNullCondition{Field: field}
}

// AddressIdIsNull returns a condition that checks if the field is null.
func AddressIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// AddressStreetIsNull returns a condition that checks if the field is null.
func AddressStreetIsNull() Condition {
	return IsNullCondition{Field: "street"}
}

// AddressCityIsNull returns a condition that checks if the field is null.
func AddressCityIsNull() Condition {
	return IsNullCondition{Field: "city"}
}

// AddressStateIsNull returns a condition that checks if the field is null.
func AddressStateIsNull() Condition {
	return IsNullCondition{Field: "state"}
}

// AddressZipIsNull returns a condition that checks if the field is null.
func AddressZipIsNull() Condition {
	return IsNullCondition{Field: "zip"}
}

// AddressUserIdIsNull returns a condition that checks if the field is null.
func AddressUserIdIsNull() Condition {
	return IsNullCondition{Field: "user_id"}
}

// UserIdIsNull returns a condition that checks if the field is null.
func UserIdIsNull() Condition {
	return IsNullCondition{Field: "id"}
}

// UserNameIsNull returns a condition that checks if the field is null.
func UserNameIsNull() Condition {
	return IsNullCondition{Field: "name"}
}

// UserAgeIsNull returns a condition that checks if the field is null.
func UserAgeIsNull() Condition {
	return IsNullCondition{Field: "age"}
}

// UserEmailIsNull returns a condition that checks if the field is null.
func UserEmailIsNull() Condition {
	return IsNullCondition{Field: "email"}
}

// UserLastNameIsNull returns a condition that checks if the field is null.
func UserLastNameIsNull() Condition {
	return IsNullCondition{Field: "last_name"}
}

// --------------------------------

// IsNotNullCondition represents the IS NOT NULL condition.
type IsNotNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNotNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNotNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// IsNotNull returns a condition that checks if the field is not null.
func IsNotNull(field string) Condition {
	return IsNotNullCondition{Field: field}
}

// AddressIdIsNotNull returns a condition that checks if the field is not null.
func AddressIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// AddressStreetIsNotNull returns a condition that checks if the field is not null.
func AddressStreetIsNotNull() Condition {
	return IsNotNullCondition{Field: "street"}
}

// AddressCityIsNotNull returns a condition that checks if the field is not null.
func AddressCityIsNotNull() Condition {
	return IsNotNullCondition{Field: "city"}
}

// AddressStateIsNotNull returns a condition that checks if the field is not null.
func AddressStateIsNotNull() Condition {
	return IsNotNullCondition{Field: "state"}
}

// AddressZipIsNotNull returns a condition that checks if the field is not null.
func AddressZipIsNotNull() Condition {
	return IsNotNullCondition{Field: "zip"}
}

// AddressUserIdIsNotNull returns a condition that checks if the field is not null.
func AddressUserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "user_id"}
}

// UserIdIsNotNull returns a condition that checks if the field is not null.
func UserIdIsNotNull() Condition {
	return IsNotNullCondition{Field: "id"}
}

// UserNameIsNotNull returns a condition that checks if the field is not null.
func UserNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "name"}
}

// UserAgeIsNotNull returns a condition that checks if the field is not null.
func UserAgeIsNotNull() Condition {
	return IsNotNullCondition{Field: "age"}
}

// UserEmailIsNotNull returns a condition that checks if the field is not null.
func UserEmailIsNotNull() Condition {
	return IsNotNullCondition{Field: "email"}
}

// UserLastNameIsNotNull returns a condition that checks if the field is not null.
func UserLastNameIsNotNull() Condition {
	return IsNotNullCondition{Field: "last_name"}
}

// --------------------------------

// InCondition represents the IN condition.
type InCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c InCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c InCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// In returns a condition that checks if the field is in the given values.
func In(field string, values ...interface{}) Condition {
	return InCondition{Field: field, Values: values}
}

// AddressIdIn returns a condition that checks if the field is in the given values.
func AddressIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// AddressStreetIn returns a condition that checks if the field is in the given values.
func AddressStreetIn(values ...interface{}) Condition {
	return InCondition{Field: "street", Values: values}
}

// AddressCityIn returns a condition that checks if the field is in the given values.
func AddressCityIn(values ...interface{}) Condition {
	return InCondition{Field: "city", Values: values}
}

// AddressStateIn returns a condition that checks if the field is in the given values.
func AddressStateIn(values ...interface{}) Condition {
	return InCondition{Field: "state", Values: values}
}

// AddressZipIn returns a condition that checks if the field is in the given values.
func AddressZipIn(values ...interface{}) Condition {
	return InCondition{Field: "zip", Values: values}
}

// AddressUserIdIn returns a condition that checks if the field is in the given values.
func AddressUserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "user_id", Values: values}
}

// UserIdIn returns a condition that checks if the field is in the given values.
func UserIdIn(values ...interface{}) Condition {
	return InCondition{Field: "id", Values: values}
}

// UserNameIn returns a condition that checks if the field is in the given values.
func UserNameIn(values ...interface{}) Condition {
	return InCondition{Field: "name", Values: values}
}

// UserAgeIn returns a condition that checks if the field is in the given values.
func UserAgeIn(values ...interface{}) Condition {
	return InCondition{Field: "age", Values: values}
}

// UserEmailIn returns a condition that checks if the field is in the given values.
func UserEmailIn(values ...interface{}) Condition {
	return InCondition{Field: "email", Values: values}
}

// UserLastNameIn returns a condition that checks if the field is in the given values.
func UserLastNameIn(values ...interface{}) Condition {
	return InCondition{Field: "last_name", Values: values}
}

// --------------------------------

// NotInCondition represents the NOT IN condition.
type NotInCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c NotInCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c NotInCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// NotIn returns a condition that checks if the field is not in the given values.
func NotIn(field string, values ...interface{}) Condition {
	return NotInCondition{Field: field, Values: values}
}

// AddressIdNotIn returns a condition that checks if the field is not in the given values.
func AddressIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// AddressStreetNotIn returns a condition that checks if the field is not in the given values.
func AddressStreetNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "street", Values: values}
}

// AddressCityNotIn returns a condition that checks if the field is not in the given values.
func AddressCityNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "city", Values: values}
}

// AddressStateNotIn returns a condition that checks if the field is not in the given values.
func AddressStateNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "state", Values: values}
}

// AddressZipNotIn returns a condition that checks if the field is not in the given values.
func AddressZipNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "zip", Values: values}
}

// AddressUserIdNotIn returns a condition that checks if the field is not in the given values.
func AddressUserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "user_id", Values: values}
}

// UserIdNotIn returns a condition that checks if the field is not in the given values.
func UserIdNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "id", Values: values}
}

// UserNameNotIn returns a condition that checks if the field is not in the given values.
func UserNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "name", Values: values}
}

// UserAgeNotIn returns a condition that checks if the field is not in the given values.
func UserAgeNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "age", Values: values}
}

// UserEmailNotIn returns a condition that checks if the field is not in the given values.
func UserEmailNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "email", Values: values}
}

// UserLastNameNotIn returns a condition that checks if the field is not in the given values.
func UserLastNameNotIn(values ...interface{}) Condition {
	return NotInCondition{Field: "last_name", Values: values}
}

// --------------------------------

// BetweenCondition represents the BETWEEN condition.
type BetweenCondition struct {
	Field string
	From  interface{}
	To    interface{}
}

// Apply applies the condition to the query.
func (c BetweenCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s BETWEEN ? AND ?", c.Field), c.From, c.To))
}

// ApplyDelete applies the condition to the query.
func (c BetweenCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(fmt.Sprintf("%s BETWEEN ? AND ?", c.Field), c.From, c.To))
}

// Between returns a condition that checks if the field is between the given values.
func Between(field string, from, to interface{}) Condition {
	return BetweenCondition{Field: field, From: from, To: to}
}

// AddressIdBetween returns a condition that checks if the field is between the given values.
func AddressIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// AddressStreetBetween returns a condition that checks if the field is between the given values.
func AddressStreetBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "street", From: from, To: to}
}

// AddressCityBetween returns a condition that checks if the field is between the given values.
func AddressCityBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "city", From: from, To: to}
}

// AddressStateBetween returns a condition that checks if the field is between the given values.
func AddressStateBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "state", From: from, To: to}
}

// AddressZipBetween returns a condition that checks if the field is between the given values.
func AddressZipBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "zip", From: from, To: to}
}

// AddressUserIdBetween returns a condition that checks if the field is between the given values.
func AddressUserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "user_id", From: from, To: to}
}

// UserIdBetween returns a condition that checks if the field is between the given values.
func UserIdBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "id", From: from, To: to}
}

// UserNameBetween returns a condition that checks if the field is between the given values.
func UserNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "name", From: from, To: to}
}

// UserAgeBetween returns a condition that checks if the field is between the given values.
func UserAgeBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "age", From: from, To: to}
}

// UserEmailBetween returns a condition that checks if the field is between the given values.
func UserEmailBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "email", From: from, To: to}
}

// UserLastNameBetween returns a condition that checks if the field is between the given values.
func UserLastNameBetween(from, to interface{}) Condition {
	return BetweenCondition{Field: "last_name", From: from, To: to}
}

// --------------------------------

// OrderCondition represents the ORDER BY condition.
type OrderCondition struct {
	Column string
	Asc    bool
}

// Apply applies the condition to the query.
func OrderBy(column string, asc bool) Condition {
	return OrderCondition{Column: column, Asc: asc}
}

// Apply applies the condition to the query.
func (c OrderCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	if c.Asc {
		return query.OrderBy(c.Column + " ASC")
	}
	return query.OrderBy(c.Column + " DESC")
}

func (c OrderCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query
}

// AddressIdOrderBy returns a condition that orders the query by the given column.
func AddressIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// AddressStreetOrderBy returns a condition that orders the query by the given column.
func AddressStreetOrderBy(asc bool) Condition {
	return OrderCondition{Column: "street", Asc: asc}
}

// AddressCityOrderBy returns a condition that orders the query by the given column.
func AddressCityOrderBy(asc bool) Condition {
	return OrderCondition{Column: "city", Asc: asc}
}

// AddressStateOrderBy returns a condition that orders the query by the given column.
func AddressStateOrderBy(asc bool) Condition {
	return OrderCondition{Column: "state", Asc: asc}
}

// AddressZipOrderBy returns a condition that orders the query by the given column.
func AddressZipOrderBy(asc bool) Condition {
	return OrderCondition{Column: "zip", Asc: asc}
}

// AddressUserIdOrderBy returns a condition that orders the query by the given column.
func AddressUserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "user_id", Asc: asc}
}

// UserIdOrderBy returns a condition that orders the query by the given column.
func UserIdOrderBy(asc bool) Condition {
	return OrderCondition{Column: "id", Asc: asc}
}

// UserNameOrderBy returns a condition that orders the query by the given column.
func UserNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "name", Asc: asc}
}

// UserAgeOrderBy returns a condition that orders the query by the given column.
func UserAgeOrderBy(asc bool) Condition {
	return OrderCondition{Column: "age", Asc: asc}
}

// UserEmailOrderBy returns a condition that orders the query by the given column.
func UserEmailOrderBy(asc bool) Condition {
	return OrderCondition{Column: "email", Asc: asc}
}

// UserLastNameOrderBy returns a condition that orders the query by the given column.
func UserLastNameOrderBy(asc bool) Condition {
	return OrderCondition{Column: "last_name", Asc: asc}
}
