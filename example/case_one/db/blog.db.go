// Code generated by protoc-gen-structify. DO NOT EDIT.
// source: example/case_one/db/blog.proto
// provider: postgres
// protoc-gen-structify: (version=v0.0.1, branch=main, revision=ed6b31f2b37717411a1151436bf2a085f000bbd5), build: (go=go1.21.0, date=2023-08-24T15:52:48+0300)
// protoc: 3.15.8
package db

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	"github.com/lib/pq"
	_ "github.com/lib/pq"
	"github.com/pkg/errors"
	"math"
	"strconv"
	"strings"
	"time"
)

//
// Database connection.
//

// Dsn builds the DSN string for the database connection.
// See https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING
func Dsn(host string, port int, user string, password string, dbname string, sslMode string, timeout int) string {
	dsn := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s", host, port, user, password, dbname)

	// sslMode is optional. If not provided, it will be omitted.
	// valid values are: disable, allow, prefer, require, verify-ca, verify-full
	if sslMode != "" {
		dsn += " sslmode=" + sslMode
	}

	if timeout != 0 {
		dsn += " connect_timeout=" + strconv.Itoa(timeout)
	}

	return dsn
}

// Open connects to the database and returns a *sql.DB.
// The caller is responsible for closing the database.
// The caller is responsible for calling db.Ping() to verify the connection.
// The caller is responsible for setting the connection pool options.
//
// See https://golang.org/pkg/database/sql/#DB.SetMaxOpenConns
// See https://golang.org/pkg/database/sql/#DB.SetMaxIdleConns
// See https://golang.org/pkg/database/sql/#DB.SetConnMaxIdleTime
// See https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime
// See https://golang.org/pkg/database/sql/#DB.Ping
func Open(dsn string, opts ...BlogDatabaseClientOption) (*sql.DB, error) {
	options := &BlogDatabaseClientOptions{
		MaxOpenConns:    10,
		MaxIdleConns:    5,
		ConnMaxIdleTime: time.Minute,
		MaxLifetime:     time.Minute * 2,
	}

	for _, opt := range opts {
		opt(options)
	}

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Ping verifies a connection to the database is still alive, establishing a connection if necessary.
	if err = db.Ping(); err != nil {
		// If Ping fails, close the DB and return an error.
		db.Close() // Ignoring error from Close, as we already have a more significant error.
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	// Set the connection pool options.
	db.SetMaxOpenConns(options.MaxOpenConns)
	// SetMaxIdleConns sets the maximum number of connections in the idle connection pool.
	db.SetMaxIdleConns(options.MaxIdleConns)
	// SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.
	db.SetConnMaxIdleTime(options.ConnMaxIdleTime)
	// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
	db.SetConnMaxLifetime(options.MaxLifetime)

	return db, nil
}

// BlogDatabaseClientOptions are the options for the BlogDatabaseClient.
type BlogDatabaseClientOptions struct {
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxIdleTime time.Duration
	MaxLifetime     time.Duration
}

// Option is a function that configures the BlogDatabaseClient.
type BlogDatabaseClientOption func(*BlogDatabaseClientOptions)

// WithMaxOpenConns sets the maximum number of open connections to the database.
func WithMaxOpenConns(maxOpenConns int) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.MaxOpenConns = maxOpenConns
	}
}

// WithMaxIdleConns sets the maximum number of idle connections to the database.
func WithMaxIdleConns(maxIdleConns int) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.MaxIdleConns = maxIdleConns
	}
}

// WithConnMaxIdleTime sets the maximum amount of time a connection may be idle.
func WithConnMaxIdleTime(connMaxIdleTime time.Duration) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.ConnMaxIdleTime = connMaxIdleTime
	}
}

// WithMaxLifetime sets the maximum amount of time a connection may be reused.
func WithMaxLifetime(maxLifetime time.Duration) BlogDatabaseClientOption {
	return func(opts *BlogDatabaseClientOptions) {
		opts.MaxLifetime = maxLifetime
	}
}

//
// storages.
//

// blogStorages is a map of provider to init function.
type blogStorages struct {
	db *sql.DB    // The database connection.
	tx *TxManager // The transaction manager.

	addressStorage AddressStorage
	deviceStorage  DeviceStorage
	postStorage    PostStorage
	settingStorage SettingStorage
	userStorage    UserStorage
}

// BlogStorages is the interface for the BlogStorages.
type BlogStorages interface {
	// GetAddressStorage returns the AddressStorage store.
	GetAddressStorage() AddressStorage
	// GetDeviceStorage returns the DeviceStorage store.
	GetDeviceStorage() DeviceStorage
	// GetPostStorage returns the PostStorage store.
	GetPostStorage() PostStorage
	// GetSettingStorage returns the SettingStorage store.
	GetSettingStorage() SettingStorage
	// GetUserStorage returns the UserStorage store.
	GetUserStorage() UserStorage
	// TxManager returns the transaction manager.
	TxManager() *TxManager
	// CreateTables creates the tables for all the stores.
	CreateTables(ctx context.Context) error
	// DropTables drops the tables for all the stores.
	DropTables(ctx context.Context) error
	// TruncateTables truncates the tables for all the stores.
	TruncateTables(ctx context.Context) error
	// UpgradeTables upgrades the tables for all the stores.
	UpgradeTables(ctx context.Context) error
}

// NewBlogStorages returns a new BlogStorages.
func NewBlogStorages(db *sql.DB) BlogStorages {
	return &blogStorages{
		db: db,
		tx: NewTxManager(db),

		addressStorage: NewAddressStorage(db),
		deviceStorage:  NewDeviceStorage(db),
		postStorage:    NewPostStorage(db),
		settingStorage: NewSettingStorage(db),
		userStorage:    NewUserStorage(db),
	}
}

// TxManager returns the transaction manager.
func (c *blogStorages) TxManager() *TxManager {
	return c.tx
}

// GetAddressStorage returns the AddressStorage store.
func (c *blogStorages) GetAddressStorage() AddressStorage {
	return c.addressStorage
}

// GetDeviceStorage returns the DeviceStorage store.
func (c *blogStorages) GetDeviceStorage() DeviceStorage {
	return c.deviceStorage
}

// GetPostStorage returns the PostStorage store.
func (c *blogStorages) GetPostStorage() PostStorage {
	return c.postStorage
}

// GetSettingStorage returns the SettingStorage store.
func (c *blogStorages) GetSettingStorage() SettingStorage {
	return c.settingStorage
}

// GetUserStorage returns the UserStorage store.
func (c *blogStorages) GetUserStorage() UserStorage {
	return c.userStorage
}

// CreateTables creates the tables for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) CreateTables(ctx context.Context) error {
	var err error

	// create the AddressStorage table.
	err = c.addressStorage.CreateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the DeviceStorage table.
	err = c.deviceStorage.CreateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the PostStorage table.
	err = c.postStorage.CreateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the SettingStorage table.
	err = c.settingStorage.CreateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	// create the UserStorage table.
	err = c.userStorage.CreateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	return nil
}

// DropTables drops the tables for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) DropTables(ctx context.Context) error {
	var err error

	// drop the AddressStorage table.
	err = c.addressStorage.DropTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the DeviceStorage table.
	err = c.deviceStorage.DropTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the PostStorage table.
	err = c.postStorage.DropTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the SettingStorage table.
	err = c.settingStorage.DropTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	// drop the UserStorage table.
	err = c.userStorage.DropTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	return nil
}

// TruncateTables truncates the tables for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) TruncateTables(ctx context.Context) error {
	var err error

	// truncate the AddressStorage table.
	err = c.addressStorage.TruncateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the DeviceStorage table.
	err = c.deviceStorage.TruncateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the PostStorage table.
	err = c.postStorage.TruncateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the SettingStorage table.
	err = c.settingStorage.TruncateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	// truncate the UserStorage table.
	err = c.userStorage.TruncateTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to truncate table: %w", err)
	}

	return nil
}

// UpgradeTables runs the database upgrades for all the stores.
// This is idempotent and safe to run multiple times.
func (c *blogStorages) UpgradeTables(ctx context.Context) error {
	var err error

	// run the AddressStorage upgrade.
	err = c.addressStorage.UpgradeTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the DeviceStorage upgrade.
	err = c.deviceStorage.UpgradeTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the PostStorage upgrade.
	err = c.postStorage.UpgradeTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the SettingStorage upgrade.
	err = c.settingStorage.UpgradeTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	// run the UserStorage upgrade.
	err = c.userStorage.UpgradeTable(ctx)
	if err != nil {
		return fmt.Errorf("failed to upgrade: %w", err)
	}

	return nil
}

//
// Json types.
//

// Comment is a JSON type nested in another message.
type UserComment struct {
	Name string       `json:"name"`
	Meta *CommentMeta `json:"meta"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserComment) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserComment) Value() (driver.Value, error) {
	if m == nil {
		m = &UserComment{}
	}
	return json.Marshal(m)
}

// Meta is a JSON type nested in another message.
type CommentMeta struct {
	Ip      string `json:"ip"`
	Browser string `json:"browser"`
	Os      string `json:"os"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *CommentMeta) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *CommentMeta) Value() (driver.Value, error) {
	if m == nil {
		m = &CommentMeta{}
	}
	return json.Marshal(m)
}

// NotificationSetting is a JSON type nested in another message.
type UserNotificationSetting struct {
	RegistrationEmail bool `json:"registration_email"`
	OrderEmail        bool `json:"order_email"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserNotificationSetting) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserNotificationSetting) Value() (driver.Value, error) {
	if m == nil {
		m = &UserNotificationSetting{}
	}
	return json.Marshal(m)
}

// Numr is a JSON type nested in another message.
type UserNumr struct {
	Street string `json:"street"`
	City   string `json:"city"`
	State  int32  `json:"state"`
	Zip    int64  `json:"zip"`
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserNumr) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m *UserNumr) Value() (driver.Value, error) {
	if m == nil {
		m = &UserNumr{}
	}
	return json.Marshal(m)
}

//
// Single repeated types.
//

// UserBallsRepeated is a JSON type nested in another message.
type UserBallsRepeated []int32

// NewBallsField returns a new UserBallsRepeated.
func NewBallsField(v []int32) UserBallsRepeated {
	return v
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserBallsRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m UserBallsRepeated) Value() (driver.Value, error) {
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m UserBallsRepeated) Get() []int32 {
	return m
}

func (m *UserBallsRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// UserCommentsRepeated is a JSON type nested in another message.
type UserCommentsRepeated []UserComment

// NewCommentsField returns a new UserCommentsRepeated.
func NewCommentsField(v []UserComment) UserCommentsRepeated {
	return v
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserCommentsRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m UserCommentsRepeated) Value() (driver.Value, error) {
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m UserCommentsRepeated) Get() []UserComment {
	return m
}

func (m *UserCommentsRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// UserNumrsRepeated is a JSON type nested in another message.
type UserNumrsRepeated []UserNumr

// NewNumrsField returns a new UserNumrsRepeated.
func NewNumrsField(v []UserNumr) UserNumrsRepeated {
	return v
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserNumrsRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m UserNumrsRepeated) Value() (driver.Value, error) {
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m UserNumrsRepeated) Get() []UserNumr {
	return m
}

func (m *UserNumrsRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// UserPhonesRepeated is a JSON type nested in another message.
type UserPhonesRepeated []string

// NewPhonesField returns a new UserPhonesRepeated.
func NewPhonesField(v []string) UserPhonesRepeated {
	return v
}

// Scan implements the sql.Scanner interface for JSON.
func (m *UserPhonesRepeated) Scan(src interface{}) error {
	if bytes, ok := src.([]byte); ok {
		return json.Unmarshal(bytes, m)
	}

	return fmt.Errorf("can't convert %T", src)
}

// Value implements the driver.Valuer interface for JSON.
func (m UserPhonesRepeated) Value() (driver.Value, error) {
	return json.Marshal(m)
}

// Get returns the value of the field.
func (m UserPhonesRepeated) Get() []string {
	return m
}

func (m *UserPhonesRepeated) String() string {
	return fmt.Sprintf("%v", m.Get())
}

// Pagination is the pagination.
type Paginator struct {
	TotalCount int64
	Limit      int
	Page       int
	TotalPages int
}

//
// errors.
//

var (
	// ErrNotFound is returned when a record is not found.
	ErrRowNotFound = errors.New("row not found")
	// ErrNoTransaction is returned when a transaction is not provided.
	ErrNoTransaction = errors.New("no transaction provided")
	// ErrRowAlreadyExist is returned when a row already exist.
	ErrRowAlreadyExist = errors.New("row already exist")
	// ErrModelIsNil is returned when a relation model is nil.
	ErrModelIsNil = errors.New("model is nil")
)

//
// Transaction manager.
//

// txKey is the key used to store the transaction in the context.
type txKey struct{}

// TxFromContext returns the transaction from the context.
func TxFromContext(ctx context.Context) (*sql.Tx, bool) {
	tx, ok := ctx.Value(txKey{}).(*sql.Tx)
	return tx, ok
}

// TxManager is a transaction manager.
type TxManager struct {
	db *sql.DB
}

// NewTxManager creates a new transaction manager.
func NewTxManager(db *sql.DB) *TxManager {
	return &TxManager{
		db: db,
	}
}

// Begin begins a transaction.
func (m *TxManager) Begin(ctx context.Context) (context.Context, error) {
	if _, ok := TxFromContext(ctx); ok {
		return ctx, nil
	}

	tx, err := m.db.Begin()
	if err != nil {
		return ctx, fmt.Errorf("could not begin transaction: %w", err)
	}

	// store the transaction in the context.
	return context.WithValue(ctx, txKey{}, tx), nil
}

// IsTxOpen returns true if a transaction is open.
func (m *TxManager) Commit(ctx context.Context) error {
	tx, ok := TxFromContext(ctx)
	if !ok {
		return errors.New("transactions wasn't opened")
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("could not commit transaction: %w", err)
	}

	return nil
}

// Rollback rolls back a transaction.
func (m *TxManager) Rollback(ctx context.Context) error {
	if tx, ok := TxFromContext(ctx); ok {
		err := tx.Rollback()
		if err != nil && !errors.Is(err, sql.ErrTxDone) {
			return err
		}
	}

	return nil
}

// ExecFuncWithTx executes a function with a transaction.
func (m *TxManager) ExecFuncWithTx(ctx context.Context, f func(context.Context) error) error {
	// if a transaction is already open, just execute the function.
	if m.IsTxOpen(ctx) {
		return f(ctx)
	}

	ctx, err := m.Begin(ctx)
	if err != nil {
		return err
	}
	// rollback the transaction if there is an error.
	defer func() { _ = m.Rollback(ctx) }()

	if err := f(ctx); err != nil {
		return err
	}

	// commit the transaction.
	if err := m.Commit(ctx); err != nil {
		return err
	}

	return nil
}

// IsTxOpen returns true if a transaction is open.
func (m *TxManager) IsTxOpen(ctx context.Context) bool {
	_, ok := TxFromContext(ctx)
	return ok
}

// QueryExecer is an interface that can execute queries.
type QueryExecer interface {
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

// IsPgCheckViolation returns true if the error is a postgres check violation.
func IsPgUniqueViolation(err error) bool {
	pgErr, ok := err.(*pq.Error)
	if !ok {
		return false
	}

	return pgErr.Code == errPgUniqueViolationError
}

// IsPgCheckViolation returns true if the error is a postgres check violation.
func IsPgViolationError(err error) bool {
	pgErr, ok := err.(*pq.Error)
	if !ok {
		return false
	}

	return pgErr.Code == errPgCheckViolation ||
		pgErr.Code == errPgNotNullViolation ||
		pgErr.Code == errPgForeignKeyViolation ||
		pgErr.Code == errPgUniqueViolationError
}

// PgPrettyErr returns a pretty postgres error.
func PgPrettyErr(err error) error {
	if pgErr, ok := err.(*pq.Error); ok {
		return errors.New(pgErr.Detail)
	}
	return err
}

// errors for postgres.
// https://www.postgresql.org/docs/9.3/errcodes-appendix.html
const (
	errPgCheckViolation       = "23514"
	errPgNotNullViolation     = "23502"
	errPgForeignKeyViolation  = "23503"
	errPgUniqueViolationError = "23505"
)

//
// Options.
//

// Option is a function that configures the BlogStorages.
type Option func(*Options)

// Options are the options for the BlogStorages.
type Options struct {
	// if true, then method was create/update relations
	relations bool
}

// WithRelations sets the relations flag.
// This is used to determine if the relations should be created or updated.
func WithRelations() Option {
	return func(o *Options) {
		o.relations = true
	}
}

// FilterApplier is a condition filters.
type FilterApplier interface {
	Apply(query sq.SelectBuilder) sq.SelectBuilder
	ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder
}

// QueryBuilder is a query builder.
type QueryBuilder struct {
	// additional options for the query.
	options []Option
	// filterOptions are the filter options.
	filterOptions []FilterApplier
	// pagination is the pagination.
	pagination *Pagination
}

// NewQueryBuilder returns a new query builder.
func NewQueryBuilder() *QueryBuilder {
	return &QueryBuilder{}
}

// WithOptions sets the options for the query.
func (b *QueryBuilder) WithOptions(options ...Option) *QueryBuilder {
	b.options = options
	return b
}

// WithFilterOptions sets the filter options for the query.
func (b *QueryBuilder) WithFilter(filterOptions ...FilterApplier) *QueryBuilder {
	b.filterOptions = filterOptions
	return b
}

// WithPagination sets the pagination for the query.
func (b *QueryBuilder) WithPagination(pagination *Pagination) *QueryBuilder {
	b.pagination = pagination
	return b
}

// Filter is a helper function to create a new query builder with filter options.
func FilterBuilder(filterOptions ...FilterApplier) *QueryBuilder {
	return NewQueryBuilder().WithFilter(filterOptions...)
}

// Options is a helper function to create a new query builder with options.
func LimitBuilder(limit uint64) *QueryBuilder {
	return NewQueryBuilder().WithPagination(&Pagination{
		limit: &limit,
	})
}

// Offset is a helper function to create a new query builder with options.
func OffsetBuilder(offset uint64) *QueryBuilder {
	return NewQueryBuilder().WithPagination(&Pagination{
		offset: &offset,
	})
}

// Paginate is a helper function to create a new query builder with options.
func PaginateBuilder(limit, offset uint64) *QueryBuilder {
	return NewQueryBuilder().WithPagination(NewPagination(limit, offset))
}

// Pagination is the pagination.
type Pagination struct {
	// limit is the limit.
	limit *uint64
	// offset is the offset.
	offset *uint64
}

// NewPagination returns a new pagination.
// If limit or offset are nil, then they will be omitted.
func NewPagination(limit, offset uint64) *Pagination {
	return &Pagination{
		limit:  &limit,
		offset: &offset,
	}
}

// Limit is a helper function to create a new pagination.
func Limit(limit uint64) *Pagination {
	return &Pagination{
		limit: &limit,
	}
}

// Offset is a helper function to create a new pagination.
func Offset(offset uint64) *Pagination {
	return &Pagination{
		offset: &offset,
	}
}

//
// Conditions for query builder.
//

// And returns a condition that combines the given conditions with AND.
type AndCondition struct {
	Where []FilterApplier
}

// And returns a condition that combines the given conditions with AND.
func And(conditions ...FilterApplier) FilterApplier {
	return AndCondition{Where: conditions}
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	for _, condition := range c.Where {
		query = condition.Apply(query)
	}
	return query
}

// And returns a condition that combines the given conditions with AND.
func (c AndCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	for _, condition := range c.Where {
		query = condition.ApplyDelete(query)
	}
	return query
}

//
// Or returns a condition that checks if any of the conditions are true.
//

// Or returns a condition that checks if any of the conditions are true.
type OrCondition struct {
	Conditions []FilterApplier
}

// Or returns a condition that checks if any of the conditions are true.
func Or(conditions ...FilterApplier) FilterApplier {
	return OrCondition{Conditions: conditions}
}

// Apply applies the condition to the query.
func (c OrCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// Apply applies the condition to the query.
func (c OrCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	or := sq.Or{}
	for _, condition := range c.Conditions {
		subQuery := condition.Apply(sq.Select("*"))
		// Extract WHERE clause from the subquery
		whereParts, args, _ := subQuery.ToSql()
		whereParts = strings.TrimPrefix(whereParts, "SELECT * WHERE ")
		// Append the WHERE clause to the OR condition
		or = append(or, sq.Expr(whereParts, args...))
	}
	return query.Where(or)
}

// EqualsCondition equals condition.
type EqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c EqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

func (c EqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Value})
}

// Eq returns a condition that checks if the field equals the value.
func Eq(field string, value interface{}) FilterApplier {
	return EqualsCondition{Field: field, Value: value}
}

// DeviceNameEq returns a condition that checks if the field equals the value.
func DeviceNameEq(value string) FilterApplier {
	return EqualsCondition{Field: "name", Value: value}
}

// DeviceValueEq returns a condition that checks if the field equals the value.
func DeviceValueEq(value string) FilterApplier {
	return EqualsCondition{Field: "value", Value: value}
}

// DeviceUserIdEq returns a condition that checks if the field equals the value.
func DeviceUserIdEq(value string) FilterApplier {
	return EqualsCondition{Field: "user_id", Value: value}
}

// PostIdEq returns a condition that checks if the field equals the value.
func PostIdEq(value int32) FilterApplier {
	return EqualsCondition{Field: "id", Value: value}
}

// PostTitleEq returns a condition that checks if the field equals the value.
func PostTitleEq(value string) FilterApplier {
	return EqualsCondition{Field: "title", Value: value}
}

// PostBodyEq returns a condition that checks if the field equals the value.
func PostBodyEq(value string) FilterApplier {
	return EqualsCondition{Field: "body", Value: value}
}

// PostAuthorIdEq returns a condition that checks if the field equals the value.
func PostAuthorIdEq(value string) FilterApplier {
	return EqualsCondition{Field: "author_id", Value: value}
}

// UserIdEq returns a condition that checks if the field equals the value.
func UserIdEq(value string) FilterApplier {
	return EqualsCondition{Field: "id", Value: value}
}

// UserNameEq returns a condition that checks if the field equals the value.
func UserNameEq(value string) FilterApplier {
	return EqualsCondition{Field: "name", Value: value}
}

// UserAgeEq returns a condition that checks if the field equals the value.
func UserAgeEq(value int32) FilterApplier {
	return EqualsCondition{Field: "age", Value: value}
}

// UserEmailEq returns a condition that checks if the field equals the value.
func UserEmailEq(value string) FilterApplier {
	return EqualsCondition{Field: "email", Value: value}
}

// UserLastNameEq returns a condition that checks if the field equals the value.
func UserLastNameEq(value *string) FilterApplier {
	return EqualsCondition{Field: "last_name", Value: value}
}

// UserCreatedAtEq returns a condition that checks if the field equals the value.
func UserCreatedAtEq(value time.Time) FilterApplier {
	return EqualsCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtEq returns a condition that checks if the field equals the value.
func UserUpdatedAtEq(value *time.Time) FilterApplier {
	return EqualsCondition{Field: "updated_at", Value: value}
}

// SettingIdEq returns a condition that checks if the field equals the value.
func SettingIdEq(value int32) FilterApplier {
	return EqualsCondition{Field: "id", Value: value}
}

// SettingNameEq returns a condition that checks if the field equals the value.
func SettingNameEq(value string) FilterApplier {
	return EqualsCondition{Field: "name", Value: value}
}

// SettingValueEq returns a condition that checks if the field equals the value.
func SettingValueEq(value string) FilterApplier {
	return EqualsCondition{Field: "value", Value: value}
}

// SettingUserIdEq returns a condition that checks if the field equals the value.
func SettingUserIdEq(value string) FilterApplier {
	return EqualsCondition{Field: "user_id", Value: value}
}

// AddressIdEq returns a condition that checks if the field equals the value.
func AddressIdEq(value string) FilterApplier {
	return EqualsCondition{Field: "id", Value: value}
}

// AddressStreetEq returns a condition that checks if the field equals the value.
func AddressStreetEq(value string) FilterApplier {
	return EqualsCondition{Field: "street", Value: value}
}

// AddressCityEq returns a condition that checks if the field equals the value.
func AddressCityEq(value string) FilterApplier {
	return EqualsCondition{Field: "city", Value: value}
}

// AddressStateEq returns a condition that checks if the field equals the value.
func AddressStateEq(value int32) FilterApplier {
	return EqualsCondition{Field: "state", Value: value}
}

// AddressZipEq returns a condition that checks if the field equals the value.
func AddressZipEq(value int64) FilterApplier {
	return EqualsCondition{Field: "zip", Value: value}
}

// AddressUserIdEq returns a condition that checks if the field equals the value.
func AddressUserIdEq(value string) FilterApplier {
	return EqualsCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtEq returns a condition that checks if the field equals the value.
func AddressCreatedAtEq(value time.Time) FilterApplier {
	return EqualsCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtEq returns a condition that checks if the field equals the value.
func AddressUpdatedAtEq(value *time.Time) FilterApplier {
	return EqualsCondition{Field: "updated_at", Value: value}
}

// NotEqualsCondition not equals condition.
type NotEqualsCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotEqualsCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotEqualsCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Value})
}

// NotEq returns a condition that checks if the field equals the value.
func NotEq(field string, value interface{}) FilterApplier {
	return NotEqualsCondition{Field: field, Value: value}
}

// DeviceNameNotEq returns a condition that checks if the field equals the value.
func DeviceNameNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "name", Value: value}
}

// DeviceValueNotEq returns a condition that checks if the field equals the value.
func DeviceValueNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "value", Value: value}
}

// DeviceUserIdNotEq returns a condition that checks if the field equals the value.
func DeviceUserIdNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// PostIdNotEq returns a condition that checks if the field equals the value.
func PostIdNotEq(value int32) FilterApplier {
	return NotEqualsCondition{Field: "id", Value: value}
}

// PostTitleNotEq returns a condition that checks if the field equals the value.
func PostTitleNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "title", Value: value}
}

// PostBodyNotEq returns a condition that checks if the field equals the value.
func PostBodyNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "body", Value: value}
}

// PostAuthorIdNotEq returns a condition that checks if the field equals the value.
func PostAuthorIdNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "author_id", Value: value}
}

// UserIdNotEq returns a condition that checks if the field equals the value.
func UserIdNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "id", Value: value}
}

// UserNameNotEq returns a condition that checks if the field equals the value.
func UserNameNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "name", Value: value}
}

// UserAgeNotEq returns a condition that checks if the field equals the value.
func UserAgeNotEq(value int32) FilterApplier {
	return NotEqualsCondition{Field: "age", Value: value}
}

// UserEmailNotEq returns a condition that checks if the field equals the value.
func UserEmailNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "email", Value: value}
}

// UserLastNameNotEq returns a condition that checks if the field equals the value.
func UserLastNameNotEq(value *string) FilterApplier {
	return NotEqualsCondition{Field: "last_name", Value: value}
}

// UserCreatedAtNotEq returns a condition that checks if the field equals the value.
func UserCreatedAtNotEq(value time.Time) FilterApplier {
	return NotEqualsCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtNotEq returns a condition that checks if the field equals the value.
func UserUpdatedAtNotEq(value *time.Time) FilterApplier {
	return NotEqualsCondition{Field: "updated_at", Value: value}
}

// SettingIdNotEq returns a condition that checks if the field equals the value.
func SettingIdNotEq(value int32) FilterApplier {
	return NotEqualsCondition{Field: "id", Value: value}
}

// SettingNameNotEq returns a condition that checks if the field equals the value.
func SettingNameNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "name", Value: value}
}

// SettingValueNotEq returns a condition that checks if the field equals the value.
func SettingValueNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "value", Value: value}
}

// SettingUserIdNotEq returns a condition that checks if the field equals the value.
func SettingUserIdNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// AddressIdNotEq returns a condition that checks if the field equals the value.
func AddressIdNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "id", Value: value}
}

// AddressStreetNotEq returns a condition that checks if the field equals the value.
func AddressStreetNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "street", Value: value}
}

// AddressCityNotEq returns a condition that checks if the field equals the value.
func AddressCityNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "city", Value: value}
}

// AddressStateNotEq returns a condition that checks if the field equals the value.
func AddressStateNotEq(value int32) FilterApplier {
	return NotEqualsCondition{Field: "state", Value: value}
}

// AddressZipNotEq returns a condition that checks if the field equals the value.
func AddressZipNotEq(value int64) FilterApplier {
	return NotEqualsCondition{Field: "zip", Value: value}
}

// AddressUserIdNotEq returns a condition that checks if the field equals the value.
func AddressUserIdNotEq(value string) FilterApplier {
	return NotEqualsCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtNotEq returns a condition that checks if the field equals the value.
func AddressCreatedAtNotEq(value time.Time) FilterApplier {
	return NotEqualsCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtNotEq returns a condition that checks if the field equals the value.
func AddressUpdatedAtNotEq(value *time.Time) FilterApplier {
	return NotEqualsCondition{Field: "updated_at", Value: value}
}

// GreaterThanCondition greaterThanCondition than condition.
type GreaterThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Gt{c.Field: c.Value})
}

// GreaterThan returns a condition that checks if the field equals the value.
func GreaterThan(field string, value interface{}) FilterApplier {
	return GreaterThanCondition{Field: field, Value: value}
}

// DeviceNameGreaterThan greaterThanCondition than condition.
func DeviceNameGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "name", Value: value}
}

// DeviceValueGreaterThan greaterThanCondition than condition.
func DeviceValueGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "value", Value: value}
}

// DeviceUserIdGreaterThan greaterThanCondition than condition.
func DeviceUserIdGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// PostIdGreaterThan greaterThanCondition than condition.
func PostIdGreaterThan(value int32) FilterApplier {
	return GreaterThanCondition{Field: "id", Value: value}
}

// PostTitleGreaterThan greaterThanCondition than condition.
func PostTitleGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "title", Value: value}
}

// PostBodyGreaterThan greaterThanCondition than condition.
func PostBodyGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "body", Value: value}
}

// PostAuthorIdGreaterThan greaterThanCondition than condition.
func PostAuthorIdGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "author_id", Value: value}
}

// UserIdGreaterThan greaterThanCondition than condition.
func UserIdGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "id", Value: value}
}

// UserNameGreaterThan greaterThanCondition than condition.
func UserNameGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "name", Value: value}
}

// UserAgeGreaterThan greaterThanCondition than condition.
func UserAgeGreaterThan(value int32) FilterApplier {
	return GreaterThanCondition{Field: "age", Value: value}
}

// UserEmailGreaterThan greaterThanCondition than condition.
func UserEmailGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "email", Value: value}
}

// UserLastNameGreaterThan greaterThanCondition than condition.
func UserLastNameGreaterThan(value *string) FilterApplier {
	return GreaterThanCondition{Field: "last_name", Value: value}
}

// UserCreatedAtGreaterThan greaterThanCondition than condition.
func UserCreatedAtGreaterThan(value time.Time) FilterApplier {
	return GreaterThanCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtGreaterThan greaterThanCondition than condition.
func UserUpdatedAtGreaterThan(value *time.Time) FilterApplier {
	return GreaterThanCondition{Field: "updated_at", Value: value}
}

// SettingIdGreaterThan greaterThanCondition than condition.
func SettingIdGreaterThan(value int32) FilterApplier {
	return GreaterThanCondition{Field: "id", Value: value}
}

// SettingNameGreaterThan greaterThanCondition than condition.
func SettingNameGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "name", Value: value}
}

// SettingValueGreaterThan greaterThanCondition than condition.
func SettingValueGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "value", Value: value}
}

// SettingUserIdGreaterThan greaterThanCondition than condition.
func SettingUserIdGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// AddressIdGreaterThan greaterThanCondition than condition.
func AddressIdGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "id", Value: value}
}

// AddressStreetGreaterThan greaterThanCondition than condition.
func AddressStreetGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "street", Value: value}
}

// AddressCityGreaterThan greaterThanCondition than condition.
func AddressCityGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "city", Value: value}
}

// AddressStateGreaterThan greaterThanCondition than condition.
func AddressStateGreaterThan(value int32) FilterApplier {
	return GreaterThanCondition{Field: "state", Value: value}
}

// AddressZipGreaterThan greaterThanCondition than condition.
func AddressZipGreaterThan(value int64) FilterApplier {
	return GreaterThanCondition{Field: "zip", Value: value}
}

// AddressUserIdGreaterThan greaterThanCondition than condition.
func AddressUserIdGreaterThan(value string) FilterApplier {
	return GreaterThanCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtGreaterThan greaterThanCondition than condition.
func AddressCreatedAtGreaterThan(value time.Time) FilterApplier {
	return GreaterThanCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtGreaterThan greaterThanCondition than condition.
func AddressUpdatedAtGreaterThan(value *time.Time) FilterApplier {
	return GreaterThanCondition{Field: "updated_at", Value: value}
}

// LessThanCondition less than condition.
type LessThanCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Lt{c.Field: c.Value})
}

// LessThan returns a condition that checks if the field equals the value.
func LessThan(field string, value interface{}) FilterApplier {
	return LessThanCondition{Field: field, Value: value}
}

// DeviceNameLessThan less than condition.
func DeviceNameLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "name", Value: value}
}

// DeviceValueLessThan less than condition.
func DeviceValueLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "value", Value: value}
}

// DeviceUserIdLessThan less than condition.
func DeviceUserIdLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "user_id", Value: value}
}

// PostIdLessThan less than condition.
func PostIdLessThan(value int32) FilterApplier {
	return LessThanCondition{Field: "id", Value: value}
}

// PostTitleLessThan less than condition.
func PostTitleLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "title", Value: value}
}

// PostBodyLessThan less than condition.
func PostBodyLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "body", Value: value}
}

// PostAuthorIdLessThan less than condition.
func PostAuthorIdLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "author_id", Value: value}
}

// UserIdLessThan less than condition.
func UserIdLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "id", Value: value}
}

// UserNameLessThan less than condition.
func UserNameLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "name", Value: value}
}

// UserAgeLessThan less than condition.
func UserAgeLessThan(value int32) FilterApplier {
	return LessThanCondition{Field: "age", Value: value}
}

// UserEmailLessThan less than condition.
func UserEmailLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "email", Value: value}
}

// UserLastNameLessThan less than condition.
func UserLastNameLessThan(value *string) FilterApplier {
	return LessThanCondition{Field: "last_name", Value: value}
}

// UserCreatedAtLessThan less than condition.
func UserCreatedAtLessThan(value time.Time) FilterApplier {
	return LessThanCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtLessThan less than condition.
func UserUpdatedAtLessThan(value *time.Time) FilterApplier {
	return LessThanCondition{Field: "updated_at", Value: value}
}

// SettingIdLessThan less than condition.
func SettingIdLessThan(value int32) FilterApplier {
	return LessThanCondition{Field: "id", Value: value}
}

// SettingNameLessThan less than condition.
func SettingNameLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "name", Value: value}
}

// SettingValueLessThan less than condition.
func SettingValueLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "value", Value: value}
}

// SettingUserIdLessThan less than condition.
func SettingUserIdLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "user_id", Value: value}
}

// AddressIdLessThan less than condition.
func AddressIdLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "id", Value: value}
}

// AddressStreetLessThan less than condition.
func AddressStreetLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "street", Value: value}
}

// AddressCityLessThan less than condition.
func AddressCityLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "city", Value: value}
}

// AddressStateLessThan less than condition.
func AddressStateLessThan(value int32) FilterApplier {
	return LessThanCondition{Field: "state", Value: value}
}

// AddressZipLessThan less than condition.
func AddressZipLessThan(value int64) FilterApplier {
	return LessThanCondition{Field: "zip", Value: value}
}

// AddressUserIdLessThan less than condition.
func AddressUserIdLessThan(value string) FilterApplier {
	return LessThanCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtLessThan less than condition.
func AddressCreatedAtLessThan(value time.Time) FilterApplier {
	return LessThanCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtLessThan less than condition.
func AddressUpdatedAtLessThan(value *time.Time) FilterApplier {
	return LessThanCondition{Field: "updated_at", Value: value}
}

// LessThanOrEqualCondition less than or equal condition.
type GreaterThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c GreaterThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c GreaterThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.GtOrEq{c.Field: c.Value})
}

// GreaterThanOrEqual returns a condition that checks if the field equals the value.
func GreaterThanOrEq(field string, value interface{}) FilterApplier {
	return GreaterThanOrEqualCondition{Field: field, Value: value}
}

// DeviceNameGreaterThanOrEq less than condition.
func DeviceNameGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// DeviceValueGreaterThanOrEq less than condition.
func DeviceValueGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "value", Value: value}
}

// DeviceUserIdGreaterThanOrEq less than condition.
func DeviceUserIdGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// PostIdGreaterThanOrEq less than condition.
func PostIdGreaterThanOrEq(value int32) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// PostTitleGreaterThanOrEq less than condition.
func PostTitleGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "title", Value: value}
}

// PostBodyGreaterThanOrEq less than condition.
func PostBodyGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "body", Value: value}
}

// PostAuthorIdGreaterThanOrEq less than condition.
func PostAuthorIdGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "author_id", Value: value}
}

// UserIdGreaterThanOrEq less than condition.
func UserIdGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// UserNameGreaterThanOrEq less than condition.
func UserNameGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// UserAgeGreaterThanOrEq less than condition.
func UserAgeGreaterThanOrEq(value int32) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "age", Value: value}
}

// UserEmailGreaterThanOrEq less than condition.
func UserEmailGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "email", Value: value}
}

// UserLastNameGreaterThanOrEq less than condition.
func UserLastNameGreaterThanOrEq(value *string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "last_name", Value: value}
}

// UserCreatedAtGreaterThanOrEq less than condition.
func UserCreatedAtGreaterThanOrEq(value time.Time) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtGreaterThanOrEq less than condition.
func UserUpdatedAtGreaterThanOrEq(value *time.Time) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "updated_at", Value: value}
}

// SettingIdGreaterThanOrEq less than condition.
func SettingIdGreaterThanOrEq(value int32) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// SettingNameGreaterThanOrEq less than condition.
func SettingNameGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "name", Value: value}
}

// SettingValueGreaterThanOrEq less than condition.
func SettingValueGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "value", Value: value}
}

// SettingUserIdGreaterThanOrEq less than condition.
func SettingUserIdGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// AddressIdGreaterThanOrEq less than condition.
func AddressIdGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "id", Value: value}
}

// AddressStreetGreaterThanOrEq less than condition.
func AddressStreetGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "street", Value: value}
}

// AddressCityGreaterThanOrEq less than condition.
func AddressCityGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "city", Value: value}
}

// AddressStateGreaterThanOrEq less than condition.
func AddressStateGreaterThanOrEq(value int32) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "state", Value: value}
}

// AddressZipGreaterThanOrEq less than condition.
func AddressZipGreaterThanOrEq(value int64) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "zip", Value: value}
}

// AddressUserIdGreaterThanOrEq less than condition.
func AddressUserIdGreaterThanOrEq(value string) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtGreaterThanOrEq less than condition.
func AddressCreatedAtGreaterThanOrEq(value time.Time) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtGreaterThanOrEq less than condition.
func AddressUpdatedAtGreaterThanOrEq(value *time.Time) FilterApplier {
	return GreaterThanOrEqualCondition{Field: "updated_at", Value: value}
}

// LessThanOrEqualCondition less than or equal condition.
type LessThanOrEqualCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LessThanOrEqualCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LessThanOrEqualCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.LtOrEq{c.Field: c.Value})
}

func LessThanOrEq(field string, value interface{}) FilterApplier {
	return LessThanOrEqualCondition{Field: field, Value: value}
}

// DeviceNameLessThanOrEq less than condition.
func DeviceNameLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// DeviceValueLessThanOrEq less than condition.
func DeviceValueLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "value", Value: value}
}

// DeviceUserIdLessThanOrEq less than condition.
func DeviceUserIdLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// PostIdLessThanOrEq less than condition.
func PostIdLessThanOrEq(value int32) FilterApplier {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// PostTitleLessThanOrEq less than condition.
func PostTitleLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "title", Value: value}
}

// PostBodyLessThanOrEq less than condition.
func PostBodyLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "body", Value: value}
}

// PostAuthorIdLessThanOrEq less than condition.
func PostAuthorIdLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "author_id", Value: value}
}

// UserIdLessThanOrEq less than condition.
func UserIdLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// UserNameLessThanOrEq less than condition.
func UserNameLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// UserAgeLessThanOrEq less than condition.
func UserAgeLessThanOrEq(value int32) FilterApplier {
	return LessThanOrEqualCondition{Field: "age", Value: value}
}

// UserEmailLessThanOrEq less than condition.
func UserEmailLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "email", Value: value}
}

// UserLastNameLessThanOrEq less than condition.
func UserLastNameLessThanOrEq(value *string) FilterApplier {
	return LessThanOrEqualCondition{Field: "last_name", Value: value}
}

// UserCreatedAtLessThanOrEq less than condition.
func UserCreatedAtLessThanOrEq(value time.Time) FilterApplier {
	return LessThanOrEqualCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtLessThanOrEq less than condition.
func UserUpdatedAtLessThanOrEq(value *time.Time) FilterApplier {
	return LessThanOrEqualCondition{Field: "updated_at", Value: value}
}

// SettingIdLessThanOrEq less than condition.
func SettingIdLessThanOrEq(value int32) FilterApplier {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// SettingNameLessThanOrEq less than condition.
func SettingNameLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "name", Value: value}
}

// SettingValueLessThanOrEq less than condition.
func SettingValueLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "value", Value: value}
}

// SettingUserIdLessThanOrEq less than condition.
func SettingUserIdLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// AddressIdLessThanOrEq less than condition.
func AddressIdLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "id", Value: value}
}

// AddressStreetLessThanOrEq less than condition.
func AddressStreetLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "street", Value: value}
}

// AddressCityLessThanOrEq less than condition.
func AddressCityLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "city", Value: value}
}

// AddressStateLessThanOrEq less than condition.
func AddressStateLessThanOrEq(value int32) FilterApplier {
	return LessThanOrEqualCondition{Field: "state", Value: value}
}

// AddressZipLessThanOrEq less than condition.
func AddressZipLessThanOrEq(value int64) FilterApplier {
	return LessThanOrEqualCondition{Field: "zip", Value: value}
}

// AddressUserIdLessThanOrEq less than condition.
func AddressUserIdLessThanOrEq(value string) FilterApplier {
	return LessThanOrEqualCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtLessThanOrEq less than condition.
func AddressCreatedAtLessThanOrEq(value time.Time) FilterApplier {
	return LessThanOrEqualCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtLessThanOrEq less than condition.
func AddressUpdatedAtLessThanOrEq(value *time.Time) FilterApplier {
	return LessThanOrEqualCondition{Field: "updated_at", Value: value}
}

// LikeCondition like condition.
type LikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c LikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c LikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Like{c.Field: c.Value})
}

// Like returns a condition that checks if the field equals the value.
func Like(field string, value interface{}) FilterApplier {
	return LikeCondition{Field: field, Value: value}
}

// DeviceNameLike less than condition.
func DeviceNameLike(value string) FilterApplier {
	return LikeCondition{Field: "name", Value: value}
}

// DeviceValueLike less than condition.
func DeviceValueLike(value string) FilterApplier {
	return LikeCondition{Field: "value", Value: value}
}

// DeviceUserIdLike less than condition.
func DeviceUserIdLike(value string) FilterApplier {
	return LikeCondition{Field: "user_id", Value: value}
}

// PostIdLike less than condition.
func PostIdLike(value int32) FilterApplier {
	return LikeCondition{Field: "id", Value: value}
}

// PostTitleLike less than condition.
func PostTitleLike(value string) FilterApplier {
	return LikeCondition{Field: "title", Value: value}
}

// PostBodyLike less than condition.
func PostBodyLike(value string) FilterApplier {
	return LikeCondition{Field: "body", Value: value}
}

// PostAuthorIdLike less than condition.
func PostAuthorIdLike(value string) FilterApplier {
	return LikeCondition{Field: "author_id", Value: value}
}

// UserIdLike less than condition.
func UserIdLike(value string) FilterApplier {
	return LikeCondition{Field: "id", Value: value}
}

// UserNameLike less than condition.
func UserNameLike(value string) FilterApplier {
	return LikeCondition{Field: "name", Value: value}
}

// UserAgeLike less than condition.
func UserAgeLike(value int32) FilterApplier {
	return LikeCondition{Field: "age", Value: value}
}

// UserEmailLike less than condition.
func UserEmailLike(value string) FilterApplier {
	return LikeCondition{Field: "email", Value: value}
}

// UserLastNameLike less than condition.
func UserLastNameLike(value *string) FilterApplier {
	return LikeCondition{Field: "last_name", Value: value}
}

// UserCreatedAtLike less than condition.
func UserCreatedAtLike(value time.Time) FilterApplier {
	return LikeCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtLike less than condition.
func UserUpdatedAtLike(value *time.Time) FilterApplier {
	return LikeCondition{Field: "updated_at", Value: value}
}

// SettingIdLike less than condition.
func SettingIdLike(value int32) FilterApplier {
	return LikeCondition{Field: "id", Value: value}
}

// SettingNameLike less than condition.
func SettingNameLike(value string) FilterApplier {
	return LikeCondition{Field: "name", Value: value}
}

// SettingValueLike less than condition.
func SettingValueLike(value string) FilterApplier {
	return LikeCondition{Field: "value", Value: value}
}

// SettingUserIdLike less than condition.
func SettingUserIdLike(value string) FilterApplier {
	return LikeCondition{Field: "user_id", Value: value}
}

// AddressIdLike less than condition.
func AddressIdLike(value string) FilterApplier {
	return LikeCondition{Field: "id", Value: value}
}

// AddressStreetLike less than condition.
func AddressStreetLike(value string) FilterApplier {
	return LikeCondition{Field: "street", Value: value}
}

// AddressCityLike less than condition.
func AddressCityLike(value string) FilterApplier {
	return LikeCondition{Field: "city", Value: value}
}

// AddressStateLike less than condition.
func AddressStateLike(value int32) FilterApplier {
	return LikeCondition{Field: "state", Value: value}
}

// AddressZipLike less than condition.
func AddressZipLike(value int64) FilterApplier {
	return LikeCondition{Field: "zip", Value: value}
}

// AddressUserIdLike less than condition.
func AddressUserIdLike(value string) FilterApplier {
	return LikeCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtLike less than condition.
func AddressCreatedAtLike(value time.Time) FilterApplier {
	return LikeCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtLike less than condition.
func AddressUpdatedAtLike(value *time.Time) FilterApplier {
	return LikeCondition{Field: "updated_at", Value: value}
}

// NotLikeCondition not like condition.
type NotLikeCondition struct {
	Field string
	Value interface{}
}

// Apply applies the condition to the query.
func (c NotLikeCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// ApplyDelete applies the condition to the query.
func (c NotLikeCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotLike{c.Field: c.Value})
}

// NotLike returns a condition that checks if the field equals the value.
func NotLike(field string, value interface{}) FilterApplier {
	return NotLikeCondition{Field: field, Value: value}
}

// DeviceNameNotLike less than condition.
func DeviceNameNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "name", Value: value}
}

// DeviceValueNotLike less than condition.
func DeviceValueNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "value", Value: value}
}

// DeviceUserIdNotLike less than condition.
func DeviceUserIdNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// PostIdNotLike less than condition.
func PostIdNotLike(value int32) FilterApplier {
	return NotLikeCondition{Field: "id", Value: value}
}

// PostTitleNotLike less than condition.
func PostTitleNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "title", Value: value}
}

// PostBodyNotLike less than condition.
func PostBodyNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "body", Value: value}
}

// PostAuthorIdNotLike less than condition.
func PostAuthorIdNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "author_id", Value: value}
}

// UserIdNotLike less than condition.
func UserIdNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "id", Value: value}
}

// UserNameNotLike less than condition.
func UserNameNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "name", Value: value}
}

// UserAgeNotLike less than condition.
func UserAgeNotLike(value int32) FilterApplier {
	return NotLikeCondition{Field: "age", Value: value}
}

// UserEmailNotLike less than condition.
func UserEmailNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "email", Value: value}
}

// UserLastNameNotLike less than condition.
func UserLastNameNotLike(value *string) FilterApplier {
	return NotLikeCondition{Field: "last_name", Value: value}
}

// UserCreatedAtNotLike less than condition.
func UserCreatedAtNotLike(value time.Time) FilterApplier {
	return NotLikeCondition{Field: "created_at", Value: value}
}

// UserUpdatedAtNotLike less than condition.
func UserUpdatedAtNotLike(value *time.Time) FilterApplier {
	return NotLikeCondition{Field: "updated_at", Value: value}
}

// SettingIdNotLike less than condition.
func SettingIdNotLike(value int32) FilterApplier {
	return NotLikeCondition{Field: "id", Value: value}
}

// SettingNameNotLike less than condition.
func SettingNameNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "name", Value: value}
}

// SettingValueNotLike less than condition.
func SettingValueNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "value", Value: value}
}

// SettingUserIdNotLike less than condition.
func SettingUserIdNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// AddressIdNotLike less than condition.
func AddressIdNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "id", Value: value}
}

// AddressStreetNotLike less than condition.
func AddressStreetNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "street", Value: value}
}

// AddressCityNotLike less than condition.
func AddressCityNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "city", Value: value}
}

// AddressStateNotLike less than condition.
func AddressStateNotLike(value int32) FilterApplier {
	return NotLikeCondition{Field: "state", Value: value}
}

// AddressZipNotLike less than condition.
func AddressZipNotLike(value int64) FilterApplier {
	return NotLikeCondition{Field: "zip", Value: value}
}

// AddressUserIdNotLike less than condition.
func AddressUserIdNotLike(value string) FilterApplier {
	return NotLikeCondition{Field: "user_id", Value: value}
}

// AddressCreatedAtNotLike less than condition.
func AddressCreatedAtNotLike(value time.Time) FilterApplier {
	return NotLikeCondition{Field: "created_at", Value: value}
}

// AddressUpdatedAtNotLike less than condition.
func AddressUpdatedAtNotLike(value *time.Time) FilterApplier {
	return NotLikeCondition{Field: "updated_at", Value: value}
}

// IsNullCondition represents the IS NULL condition.
type IsNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NULL"))
}

// IsNull returns a condition that checks if the field is null.
func IsNull(field string) FilterApplier {
	return IsNullCondition{Field: field}
}

// DeviceNameIsNull less than condition.
func DeviceNameIsNull() FilterApplier {
	return IsNullCondition{Field: "name"}
}

// DeviceValueIsNull less than condition.
func DeviceValueIsNull() FilterApplier {
	return IsNullCondition{Field: "value"}
}

// DeviceUserIdIsNull less than condition.
func DeviceUserIdIsNull() FilterApplier {
	return IsNullCondition{Field: "user_id"}
}

// PostIdIsNull less than condition.
func PostIdIsNull() FilterApplier {
	return IsNullCondition{Field: "id"}
}

// PostTitleIsNull less than condition.
func PostTitleIsNull() FilterApplier {
	return IsNullCondition{Field: "title"}
}

// PostBodyIsNull less than condition.
func PostBodyIsNull() FilterApplier {
	return IsNullCondition{Field: "body"}
}

// PostAuthorIdIsNull less than condition.
func PostAuthorIdIsNull() FilterApplier {
	return IsNullCondition{Field: "author_id"}
}

// UserIdIsNull less than condition.
func UserIdIsNull() FilterApplier {
	return IsNullCondition{Field: "id"}
}

// UserNameIsNull less than condition.
func UserNameIsNull() FilterApplier {
	return IsNullCondition{Field: "name"}
}

// UserAgeIsNull less than condition.
func UserAgeIsNull() FilterApplier {
	return IsNullCondition{Field: "age"}
}

// UserEmailIsNull less than condition.
func UserEmailIsNull() FilterApplier {
	return IsNullCondition{Field: "email"}
}

// UserLastNameIsNull less than condition.
func UserLastNameIsNull() FilterApplier {
	return IsNullCondition{Field: "last_name"}
}

// UserCreatedAtIsNull less than condition.
func UserCreatedAtIsNull() FilterApplier {
	return IsNullCondition{Field: "created_at"}
}

// UserUpdatedAtIsNull less than condition.
func UserUpdatedAtIsNull() FilterApplier {
	return IsNullCondition{Field: "updated_at"}
}

// SettingIdIsNull less than condition.
func SettingIdIsNull() FilterApplier {
	return IsNullCondition{Field: "id"}
}

// SettingNameIsNull less than condition.
func SettingNameIsNull() FilterApplier {
	return IsNullCondition{Field: "name"}
}

// SettingValueIsNull less than condition.
func SettingValueIsNull() FilterApplier {
	return IsNullCondition{Field: "value"}
}

// SettingUserIdIsNull less than condition.
func SettingUserIdIsNull() FilterApplier {
	return IsNullCondition{Field: "user_id"}
}

// AddressIdIsNull less than condition.
func AddressIdIsNull() FilterApplier {
	return IsNullCondition{Field: "id"}
}

// AddressStreetIsNull less than condition.
func AddressStreetIsNull() FilterApplier {
	return IsNullCondition{Field: "street"}
}

// AddressCityIsNull less than condition.
func AddressCityIsNull() FilterApplier {
	return IsNullCondition{Field: "city"}
}

// AddressStateIsNull less than condition.
func AddressStateIsNull() FilterApplier {
	return IsNullCondition{Field: "state"}
}

// AddressZipIsNull less than condition.
func AddressZipIsNull() FilterApplier {
	return IsNullCondition{Field: "zip"}
}

// AddressUserIdIsNull less than condition.
func AddressUserIdIsNull() FilterApplier {
	return IsNullCondition{Field: "user_id"}
}

// AddressCreatedAtIsNull less than condition.
func AddressCreatedAtIsNull() FilterApplier {
	return IsNullCondition{Field: "created_at"}
}

// AddressUpdatedAtIsNull less than condition.
func AddressUpdatedAtIsNull() FilterApplier {
	return IsNullCondition{Field: "updated_at"}
}

// IsNotNullCondition represents the IS NOT NULL condition.
type IsNotNullCondition struct {
	Field string
}

// Apply applies the condition to the query.
func (c IsNotNullCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// ApplyDelete applies the condition to the query.
func (c IsNotNullCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Expr(c.Field + " IS NOT NULL"))
}

// IsNotNull returns a condition that checks if the field is not null.
func IsNotNull(field string) FilterApplier {
	return IsNotNullCondition{Field: field}
}

// DeviceNameIsNotNull less than condition.
func DeviceNameIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "name"}
}

// DeviceValueIsNotNull less than condition.
func DeviceValueIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "value"}
}

// DeviceUserIdIsNotNull less than condition.
func DeviceUserIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "user_id"}
}

// PostIdIsNotNull less than condition.
func PostIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "id"}
}

// PostTitleIsNotNull less than condition.
func PostTitleIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "title"}
}

// PostBodyIsNotNull less than condition.
func PostBodyIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "body"}
}

// PostAuthorIdIsNotNull less than condition.
func PostAuthorIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "author_id"}
}

// UserIdIsNotNull less than condition.
func UserIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "id"}
}

// UserNameIsNotNull less than condition.
func UserNameIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "name"}
}

// UserAgeIsNotNull less than condition.
func UserAgeIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "age"}
}

// UserEmailIsNotNull less than condition.
func UserEmailIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "email"}
}

// UserLastNameIsNotNull less than condition.
func UserLastNameIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "last_name"}
}

// UserCreatedAtIsNotNull less than condition.
func UserCreatedAtIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "created_at"}
}

// UserUpdatedAtIsNotNull less than condition.
func UserUpdatedAtIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "updated_at"}
}

// SettingIdIsNotNull less than condition.
func SettingIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "id"}
}

// SettingNameIsNotNull less than condition.
func SettingNameIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "name"}
}

// SettingValueIsNotNull less than condition.
func SettingValueIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "value"}
}

// SettingUserIdIsNotNull less than condition.
func SettingUserIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "user_id"}
}

// AddressIdIsNotNull less than condition.
func AddressIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "id"}
}

// AddressStreetIsNotNull less than condition.
func AddressStreetIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "street"}
}

// AddressCityIsNotNull less than condition.
func AddressCityIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "city"}
}

// AddressStateIsNotNull less than condition.
func AddressStateIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "state"}
}

// AddressZipIsNotNull less than condition.
func AddressZipIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "zip"}
}

// AddressUserIdIsNotNull less than condition.
func AddressUserIdIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "user_id"}
}

// AddressCreatedAtIsNotNull less than condition.
func AddressCreatedAtIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "created_at"}
}

// AddressUpdatedAtIsNotNull less than condition.
func AddressUpdatedAtIsNotNull() FilterApplier {
	return IsNotNullCondition{Field: "updated_at"}
}

// InCondition represents the IN condition.
type InCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c InCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c InCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.Eq{c.Field: c.Values})
}

// In returns a condition that checks if the field is in the given values.
func In(field string, values ...interface{}) FilterApplier {
	return InCondition{Field: field, Values: values}
}

// DeviceNameIn less than condition.
func DeviceNameIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "name", Values: values}
}

// DeviceValueIn less than condition.
func DeviceValueIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "value", Values: values}
}

// DeviceUserIdIn less than condition.
func DeviceUserIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "user_id", Values: values}
}

// PostIdIn less than condition.
func PostIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "id", Values: values}
}

// PostTitleIn less than condition.
func PostTitleIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "title", Values: values}
}

// PostBodyIn less than condition.
func PostBodyIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "body", Values: values}
}

// PostAuthorIdIn less than condition.
func PostAuthorIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "author_id", Values: values}
}

// UserIdIn less than condition.
func UserIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "id", Values: values}
}

// UserNameIn less than condition.
func UserNameIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "name", Values: values}
}

// UserAgeIn less than condition.
func UserAgeIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "age", Values: values}
}

// UserEmailIn less than condition.
func UserEmailIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "email", Values: values}
}

// UserLastNameIn less than condition.
func UserLastNameIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "last_name", Values: values}
}

// UserCreatedAtIn less than condition.
func UserCreatedAtIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "created_at", Values: values}
}

// UserUpdatedAtIn less than condition.
func UserUpdatedAtIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "updated_at", Values: values}
}

// SettingIdIn less than condition.
func SettingIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "id", Values: values}
}

// SettingNameIn less than condition.
func SettingNameIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "name", Values: values}
}

// SettingValueIn less than condition.
func SettingValueIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "value", Values: values}
}

// SettingUserIdIn less than condition.
func SettingUserIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "user_id", Values: values}
}

// AddressIdIn less than condition.
func AddressIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "id", Values: values}
}

// AddressStreetIn less than condition.
func AddressStreetIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "street", Values: values}
}

// AddressCityIn less than condition.
func AddressCityIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "city", Values: values}
}

// AddressStateIn less than condition.
func AddressStateIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "state", Values: values}
}

// AddressZipIn less than condition.
func AddressZipIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "zip", Values: values}
}

// AddressUserIdIn less than condition.
func AddressUserIdIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "user_id", Values: values}
}

// AddressCreatedAtIn less than condition.
func AddressCreatedAtIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "created_at", Values: values}
}

// AddressUpdatedAtIn less than condition.
func AddressUpdatedAtIn(values ...interface{}) FilterApplier {
	return InCondition{Field: "updated_at", Values: values}
}

// NotInCondition represents the NOT IN condition.
type NotInCondition struct {
	Field  string
	Values []interface{}
}

// Apply applies the condition to the query.
func (c NotInCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// ApplyDelete applies the condition to the query.
func (c NotInCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query.Where(sq.NotEq{c.Field: c.Values})
}

// NotIn returns a condition that checks if the field is not in the given values.
func NotIn(field string, values ...interface{}) FilterApplier {
	return NotInCondition{Field: field, Values: values}
}

// DeviceNameNotIn less than condition.
func DeviceNameNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "name", Values: values}
}

// DeviceValueNotIn less than condition.
func DeviceValueNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "value", Values: values}
}

// DeviceUserIdNotIn less than condition.
func DeviceUserIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "user_id", Values: values}
}

// PostIdNotIn less than condition.
func PostIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "id", Values: values}
}

// PostTitleNotIn less than condition.
func PostTitleNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "title", Values: values}
}

// PostBodyNotIn less than condition.
func PostBodyNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "body", Values: values}
}

// PostAuthorIdNotIn less than condition.
func PostAuthorIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "author_id", Values: values}
}

// UserIdNotIn less than condition.
func UserIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "id", Values: values}
}

// UserNameNotIn less than condition.
func UserNameNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "name", Values: values}
}

// UserAgeNotIn less than condition.
func UserAgeNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "age", Values: values}
}

// UserEmailNotIn less than condition.
func UserEmailNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "email", Values: values}
}

// UserLastNameNotIn less than condition.
func UserLastNameNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "last_name", Values: values}
}

// UserCreatedAtNotIn less than condition.
func UserCreatedAtNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "created_at", Values: values}
}

// UserUpdatedAtNotIn less than condition.
func UserUpdatedAtNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "updated_at", Values: values}
}

// SettingIdNotIn less than condition.
func SettingIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "id", Values: values}
}

// SettingNameNotIn less than condition.
func SettingNameNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "name", Values: values}
}

// SettingValueNotIn less than condition.
func SettingValueNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "value", Values: values}
}

// SettingUserIdNotIn less than condition.
func SettingUserIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "user_id", Values: values}
}

// AddressIdNotIn less than condition.
func AddressIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "id", Values: values}
}

// AddressStreetNotIn less than condition.
func AddressStreetNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "street", Values: values}
}

// AddressCityNotIn less than condition.
func AddressCityNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "city", Values: values}
}

// AddressStateNotIn less than condition.
func AddressStateNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "state", Values: values}
}

// AddressZipNotIn less than condition.
func AddressZipNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "zip", Values: values}
}

// AddressUserIdNotIn less than condition.
func AddressUserIdNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "user_id", Values: values}
}

// AddressCreatedAtNotIn less than condition.
func AddressCreatedAtNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "created_at", Values: values}
}

// AddressUpdatedAtNotIn less than condition.
func AddressUpdatedAtNotIn(values ...interface{}) FilterApplier {
	return NotInCondition{Field: "updated_at", Values: values}
}

// OrderCondition represents the ORDER BY condition.
type OrderCondition struct {
	Column string
	Asc    bool
}

// Apply applies the condition to the query.
func OrderBy(column string, asc bool) FilterApplier {
	return OrderCondition{Column: column, Asc: asc}
}

// Apply applies the condition to the query.
func (c OrderCondition) Apply(query sq.SelectBuilder) sq.SelectBuilder {
	if c.Asc {
		return query.OrderBy(c.Column + " ASC")
	}

	// default to descending.
	return query.OrderBy(c.Column + " DESC")
}

// ApplyDelete applies the condition to the query.
func (c OrderCondition) ApplyDelete(query sq.DeleteBuilder) sq.DeleteBuilder {
	return query
}

// DeviceNameNotIn less than condition.
func DeviceNameOrderBy(asc bool) FilterApplier {
	return OrderBy("name", asc)
}

// DeviceValueNotIn less than condition.
func DeviceValueOrderBy(asc bool) FilterApplier {
	return OrderBy("value", asc)
}

// DeviceUserIdNotIn less than condition.
func DeviceUserIdOrderBy(asc bool) FilterApplier {
	return OrderBy("user_id", asc)
}

// PostIdNotIn less than condition.
func PostIdOrderBy(asc bool) FilterApplier {
	return OrderBy("id", asc)
}

// PostTitleNotIn less than condition.
func PostTitleOrderBy(asc bool) FilterApplier {
	return OrderBy("title", asc)
}

// PostBodyNotIn less than condition.
func PostBodyOrderBy(asc bool) FilterApplier {
	return OrderBy("body", asc)
}

// PostAuthorIdNotIn less than condition.
func PostAuthorIdOrderBy(asc bool) FilterApplier {
	return OrderBy("author_id", asc)
}

// UserIdNotIn less than condition.
func UserIdOrderBy(asc bool) FilterApplier {
	return OrderBy("id", asc)
}

// UserNameNotIn less than condition.
func UserNameOrderBy(asc bool) FilterApplier {
	return OrderBy("name", asc)
}

// UserAgeNotIn less than condition.
func UserAgeOrderBy(asc bool) FilterApplier {
	return OrderBy("age", asc)
}

// UserEmailNotIn less than condition.
func UserEmailOrderBy(asc bool) FilterApplier {
	return OrderBy("email", asc)
}

// UserLastNameNotIn less than condition.
func UserLastNameOrderBy(asc bool) FilterApplier {
	return OrderBy("last_name", asc)
}

// UserCreatedAtNotIn less than condition.
func UserCreatedAtOrderBy(asc bool) FilterApplier {
	return OrderBy("created_at", asc)
}

// UserUpdatedAtNotIn less than condition.
func UserUpdatedAtOrderBy(asc bool) FilterApplier {
	return OrderBy("updated_at", asc)
}

// SettingIdNotIn less than condition.
func SettingIdOrderBy(asc bool) FilterApplier {
	return OrderBy("id", asc)
}

// SettingNameNotIn less than condition.
func SettingNameOrderBy(asc bool) FilterApplier {
	return OrderBy("name", asc)
}

// SettingValueNotIn less than condition.
func SettingValueOrderBy(asc bool) FilterApplier {
	return OrderBy("value", asc)
}

// SettingUserIdNotIn less than condition.
func SettingUserIdOrderBy(asc bool) FilterApplier {
	return OrderBy("user_id", asc)
}

// AddressIdNotIn less than condition.
func AddressIdOrderBy(asc bool) FilterApplier {
	return OrderBy("id", asc)
}

// AddressStreetNotIn less than condition.
func AddressStreetOrderBy(asc bool) FilterApplier {
	return OrderBy("street", asc)
}

// AddressCityNotIn less than condition.
func AddressCityOrderBy(asc bool) FilterApplier {
	return OrderBy("city", asc)
}

// AddressStateNotIn less than condition.
func AddressStateOrderBy(asc bool) FilterApplier {
	return OrderBy("state", asc)
}

// AddressZipNotIn less than condition.
func AddressZipOrderBy(asc bool) FilterApplier {
	return OrderBy("zip", asc)
}

// AddressUserIdNotIn less than condition.
func AddressUserIdOrderBy(asc bool) FilterApplier {
	return OrderBy("user_id", asc)
}

// AddressCreatedAtNotIn less than condition.
func AddressCreatedAtOrderBy(asc bool) FilterApplier {
	return OrderBy("created_at", asc)
}

// AddressUpdatedAtNotIn less than condition.
func AddressUpdatedAtOrderBy(asc bool) FilterApplier {
	return OrderBy("updated_at", asc)
}

// deviceStorage is a struct for the "devices" table.
type deviceStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type DeviceStorage interface {
	// CreateTable creates the table.
	CreateTable(ctx context.Context) error
	// DropTable drops the table.
	DropTable(ctx context.Context) error
	// TruncateTable truncates the table.
	TruncateTable(ctx context.Context) error
	// UpgradeTable upgrades the table.
	UpgradeTable(ctx context.Context) error
	// Create creates a new Device.
	Create(ctx context.Context, model *Device, opts ...Option) error
	// Update updates an existing Device.
	Update(ctx context.Context, id int64, updateData *DeviceUpdate) error
	// FindMany finds multiple Device based on the provided options.
	FindMany(ctx context.Context, builder ...*QueryBuilder) ([]*Device, error)
	// FindOne finds a single Device based on the provided options.
	FindOne(ctx context.Context, builders ...*QueryBuilder) (*Device, error)
	// Count counts Device based on the provided options.
	Count(ctx context.Context, builders ...*QueryBuilder) (int64, error)
	// FindManyWithPagination finds multiple Device with pagination support.
	FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Device, *Paginator, error)

	//
	// Lazy load relations methods
	//
}

// NewDeviceStorage returns a new deviceStorage.
func NewDeviceStorage(db *sql.DB) DeviceStorage {
	return &deviceStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// TableName returns the table name.
func (t *deviceStorage) TableName() string {
	return "devices"
}

// Columns returns the columns for the table.
func (t *deviceStorage) Columns() []string {
	return []string{
		"name", "value", "user_id",
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *deviceStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *deviceStorage) CreateTable(ctx context.Context) error {
	sqlQuery := `
		-- Table: devices
		CREATE TABLE IF NOT EXISTS devices (
		name TEXT,
		value TEXT,
		user_id UUID NOT NULL);
		
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// DropTable drops the table.
func (t *deviceStorage) DropTable(ctx context.Context) error {
	sqlQuery := `
		DROP TABLE IF EXISTS devices;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *deviceStorage) TruncateTable(ctx context.Context) error {
	sqlQuery := `
		TRUNCATE TABLE devices;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
// todo: delete this method
func (t *deviceStorage) UpgradeTable(ctx context.Context) error {
	return nil
}

// Device is a struct for the "devices" table.
type Device struct {
	Name   string `db:"name"`
	Value  string `db:"value"`
	UserId string `db:"user_id"`
}

// ScanRow scans a row into a Device.
func (t *Device) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Name, &t.Value, &t.UserId)
}

// ScanRow scans a single row into the Device.
func (t *Device) ScanRows(r *sql.Rows) error {
	return r.Scan(
		&t.Name,
		&t.Value,
		&t.UserId,
	)
}

// Create creates a new Device.
func (t *deviceStorage) Create(ctx context.Context, model *Device, opts ...Option) error {
	if model == nil {
		return errors.New("model is nil")
	}

	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Insert("devices").
		Columns(
			"name",
			"value",
			"user_id",
		).
		Values(
			model.Name,
			model.Value,
			model.UserId,
		)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return fmt.Errorf("failed to create Device: %w", err)
	}

	return nil
}

// DeviceUpdate is used to update an existing Device.
type DeviceUpdate struct {
	Name   *string
	Value  *string
	UserId *string
}

// Update updates an existing Device based on non-nil fields.
func (t *deviceStorage) Update(ctx context.Context, id int64, updateData *DeviceUpdate) error {
	if updateData == nil {
		return errors.New("update data is nil")
	}

	query := t.queryBuilder.Update("devices")
	if updateData.Name != nil {
		query = query.Set("name", *updateData.Name)
	}
	if updateData.Value != nil {
		query = query.Set("value", *updateData.Value)
	}
	if updateData.UserId != nil {
		query = query.Set("user_id", *updateData.UserId)
	}

	query = query.Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to update Device: %w", err)
	}

	return nil
}

// findMany finds multiple Device based on the provided options.
func (t *deviceStorage) FindMany(ctx context.Context, builders ...*QueryBuilder) ([]*Device, error) {
	// build query
	query := t.queryBuilder.Select(t.Columns()...).From(t.TableName())

	// set default options
	options := &Options{}

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
		// apply pagination
		if builder.pagination != nil {
			if builder.pagination.limit != nil {
				query = query.Limit(*builder.pagination.limit)
			}
			if builder.pagination.offset != nil {
				query = query.Offset(*builder.pagination.offset)
			}
		}

		// apply options
		for _, o := range builder.options {
			o(options)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	rows, err := t.DB(ctx).QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to find Device: %w", err)
	}
	defer rows.Close()

	var results []*Device
	for rows.Next() {
		model := &Device{}
		if err := model.ScanRows(rows); err != nil {
			return nil, fmt.Errorf("failed to scan Device: %w", err)
		}
		results = append(results, model)
	}

	return results, nil
}

// findOne finds a single Device based on the provided options.
func (t *deviceStorage) FindOne(ctx context.Context, builders ...*QueryBuilder) (*Device, error) {
	// Use findMany but limit the results to 1
	builders = append(builders, LimitBuilder(1))
	results, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, ErrRowNotFound
	}

	return results[0], nil
}

// Count counts Device based on the provided options.
func (t *deviceStorage) Count(ctx context.Context, builders ...*QueryBuilder) (int64, error) {
	// build query
	query := t.queryBuilder.Select("COUNT(*)").From(t.TableName())

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build query: %w", err)
	}

	row := t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("failed to count Device: %w", err)
	}

	return count, nil
}

// FindManyWithPagination finds multiple Device with pagination support.
func (t *deviceStorage) FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Device, *Paginator, error) {
	// Count the total number of records
	totalCount, err := t.Count(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to count Device: %w", err)
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Build the pagination object
	paginator := &Paginator{
		TotalCount: totalCount,
		Limit:      limit,
		Page:       page,
		TotalPages: int(math.Ceil(float64(totalCount) / float64(limit))),
	}

	// Add pagination to query builder
	builders = append(builders, PaginateBuilder(uint64(limit), uint64(offset)))

	// Find records using FindMany
	records, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to find Device: %w", err)
	}

	return records, paginator, nil
}

// postStorage is a struct for the "posts" table.
type postStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type PostStorage interface {
	// CreateTable creates the table.
	CreateTable(ctx context.Context) error
	// DropTable drops the table.
	DropTable(ctx context.Context) error
	// TruncateTable truncates the table.
	TruncateTable(ctx context.Context) error
	// UpgradeTable upgrades the table.
	UpgradeTable(ctx context.Context) error
	// Create creates a new Post.
	Create(ctx context.Context, model *Post, opts ...Option) (*int32, error)
	// Update updates an existing Post.
	Update(ctx context.Context, id int32, updateData *PostUpdate) error
	// Delete removes an existing Post by its ID.
	DeleteById(ctx context.Context, id int32, opts ...Option) error
	// FindById retrieves a Post by its id.
	FindById(ctx context.Context, id int32, opts ...Option) (*Post, error)
	// FindMany finds multiple Post based on the provided options.
	FindMany(ctx context.Context, builder ...*QueryBuilder) ([]*Post, error)
	// FindOne finds a single Post based on the provided options.
	FindOne(ctx context.Context, builders ...*QueryBuilder) (*Post, error)
	// Count counts Post based on the provided options.
	Count(ctx context.Context, builders ...*QueryBuilder) (int64, error)
	// FindManyWithPagination finds multiple Post with pagination support.
	FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Post, *Paginator, error)

	//
	// Lazy load relations methods
	//
	// LoadAuthor loads the Author relation.
	LoadAuthor(ctx context.Context, model *Post, builders ...*QueryBuilder) error
	// LoadBatchAuthor loads the Author relation.
	LoadBatchAuthor(ctx context.Context, items []*Post, builders ...*QueryBuilder) error
}

// NewPostStorage returns a new postStorage.
func NewPostStorage(db *sql.DB) PostStorage {
	return &postStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// TableName returns the table name.
func (t *postStorage) TableName() string {
	return "posts"
}

// Columns returns the columns for the table.
func (t *postStorage) Columns() []string {
	return []string{
		"id", "title", "body", "author_id",
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *postStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *postStorage) CreateTable(ctx context.Context) error {
	sqlQuery := `
		-- Table: posts
		CREATE TABLE IF NOT EXISTS posts (
		id  SERIAL PRIMARY KEY,
		title TEXT NOT NULL,
		body TEXT,
		author_id UUID NOT NULL);
		
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// DropTable drops the table.
func (t *postStorage) DropTable(ctx context.Context) error {
	sqlQuery := `
		DROP TABLE IF EXISTS posts;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *postStorage) TruncateTable(ctx context.Context) error {
	sqlQuery := `
		TRUNCATE TABLE posts;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
// todo: delete this method
func (t *postStorage) UpgradeTable(ctx context.Context) error {
	return nil
}

// LoadAuthor loads the Author relation.
func (t *postStorage) LoadAuthor(ctx context.Context, model *Post, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "Post is nil")
	}

	// NewUserStorage creates a new UserStorage.
	s := NewUserStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(UserIdEq(model.AuthorId)))
	relationModel, err := s.FindOne(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find UserStorage: %w", err)
	}

	model.Author = relationModel
	return nil
}

// LoadBatchAuthor loads the Author relation.
func (t *postStorage) LoadBatchAuthor(ctx context.Context, items []*Post, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.AuthorId
	}

	// NewUserStorage creates a new UserStorage.
	s := NewUserStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(UserIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many UserStorage: %w", err)
	}

	// Assign User to items
	// todo: optimize this, use map. Find way to get User from items
	for _, item := range items {
		for _, result := range results {
			if item.AuthorId == result.Id {
				item.Author = result
			}
		}
	}

	return nil
}

// Post is a struct for the "posts" table.
type Post struct {
	Id       int32  `db:"id"`
	Title    string `db:"title"`
	Body     string `db:"body"`
	Author   *User
	AuthorId string `db:"author_id"`
}

// ScanRow scans a row into a Post.
func (t *Post) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Title, &t.Body, &t.AuthorId)
}

// ScanRow scans a single row into the Post.
func (t *Post) ScanRows(r *sql.Rows) error {
	return r.Scan(
		&t.Id,
		&t.Title,
		&t.Body,
		&t.AuthorId,
	)
}

// Create creates a new Post.
func (t *postStorage) Create(ctx context.Context, model *Post, opts ...Option) (*int32, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Insert("posts").
		Columns(
			"title",
			"body",
			"author_id",
		).
		Values(
			model.Title,
			model.Body,
			model.AuthorId,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id int32
	err = t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create Post: %w", err)
	}

	return &id, nil
}

// PostUpdate is used to update an existing Post.
type PostUpdate struct {
	Title    *string
	Body     *string
	AuthorId *string
}

// Update updates an existing Post based on non-nil fields.
func (t *postStorage) Update(ctx context.Context, id int32, updateData *PostUpdate) error {
	if updateData == nil {
		return errors.New("update data is nil")
	}

	query := t.queryBuilder.Update("posts")
	if updateData.Title != nil {
		query = query.Set("title", *updateData.Title)
	}
	if updateData.Body != nil {
		query = query.Set("body", *updateData.Body)
	}
	if updateData.AuthorId != nil {
		query = query.Set("author_id", *updateData.AuthorId)
	}

	query = query.Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to update Post: %w", err)
	}

	return nil
}

// Delete removes an existing Post by its ID.
func (t *postStorage) DeleteById(ctx context.Context, id int32, opts ...Option) error {
	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Delete("posts").Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete Post: %w", err)
	}

	return nil
}

// FindById retrieves a Post by its id.
func (t *postStorage) FindById(ctx context.Context, id int32, opts ...Option) (*Post, error) {
	builder := NewQueryBuilder()
	{
		builder.WithFilter(PostIdEq(id))
		builder.WithOptions(opts...)
	}

	// Use FindOne to get a single result
	model, err := t.FindOne(ctx, builder)
	if err != nil {
		return nil, errors.Wrap(err, "find one Post: ")
	}

	return model, nil
}

// findMany finds multiple Post based on the provided options.
func (t *postStorage) FindMany(ctx context.Context, builders ...*QueryBuilder) ([]*Post, error) {
	// build query
	query := t.queryBuilder.Select(t.Columns()...).From(t.TableName())

	// set default options
	options := &Options{}

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
		// apply pagination
		if builder.pagination != nil {
			if builder.pagination.limit != nil {
				query = query.Limit(*builder.pagination.limit)
			}
			if builder.pagination.offset != nil {
				query = query.Offset(*builder.pagination.offset)
			}
		}

		// apply options
		for _, o := range builder.options {
			o(options)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	rows, err := t.DB(ctx).QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to find Post: %w", err)
	}
	defer rows.Close()

	var results []*Post
	for rows.Next() {
		model := &Post{}
		if err := model.ScanRows(rows); err != nil {
			return nil, fmt.Errorf("failed to scan Post: %w", err)
		}
		results = append(results, model)
	}

	return results, nil
}

// findOne finds a single Post based on the provided options.
func (t *postStorage) FindOne(ctx context.Context, builders ...*QueryBuilder) (*Post, error) {
	// Use findMany but limit the results to 1
	builders = append(builders, LimitBuilder(1))
	results, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, ErrRowNotFound
	}

	return results[0], nil
}

// Count counts Post based on the provided options.
func (t *postStorage) Count(ctx context.Context, builders ...*QueryBuilder) (int64, error) {
	// build query
	query := t.queryBuilder.Select("COUNT(*)").From(t.TableName())

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build query: %w", err)
	}

	row := t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("failed to count Post: %w", err)
	}

	return count, nil
}

// FindManyWithPagination finds multiple Post with pagination support.
func (t *postStorage) FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Post, *Paginator, error) {
	// Count the total number of records
	totalCount, err := t.Count(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to count Post: %w", err)
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Build the pagination object
	paginator := &Paginator{
		TotalCount: totalCount,
		Limit:      limit,
		Page:       page,
		TotalPages: int(math.Ceil(float64(totalCount) / float64(limit))),
	}

	// Add pagination to query builder
	builders = append(builders, PaginateBuilder(uint64(limit), uint64(offset)))

	// Find records using FindMany
	records, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to find Post: %w", err)
	}

	return records, paginator, nil
}

// userStorage is a struct for the "users" table.
type userStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type UserStorage interface {
	// CreateTable creates the table.
	CreateTable(ctx context.Context) error
	// DropTable drops the table.
	DropTable(ctx context.Context) error
	// TruncateTable truncates the table.
	TruncateTable(ctx context.Context) error
	// UpgradeTable upgrades the table.
	UpgradeTable(ctx context.Context) error
	// Create creates a new User.
	Create(ctx context.Context, model *User, opts ...Option) (*string, error)
	// Update updates an existing User.
	Update(ctx context.Context, id string, updateData *UserUpdate) error
	// Delete removes an existing User by its ID.
	DeleteById(ctx context.Context, id string, opts ...Option) error
	// FindById retrieves a User by its id.
	FindById(ctx context.Context, id string, opts ...Option) (*User, error)
	// FindMany finds multiple User based on the provided options.
	FindMany(ctx context.Context, builder ...*QueryBuilder) ([]*User, error)
	// FindOne finds a single User based on the provided options.
	FindOne(ctx context.Context, builders ...*QueryBuilder) (*User, error)
	// Count counts User based on the provided options.
	Count(ctx context.Context, builders ...*QueryBuilder) (int64, error)
	// FindManyWithPagination finds multiple User with pagination support.
	FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*User, *Paginator, error)

	//
	// Lazy load relations methods
	//
	// LoadDevice loads the Device relation.
	LoadDevice(ctx context.Context, model *User, builders ...*QueryBuilder) error
	// LoadSettings loads the Settings relation.
	LoadSettings(ctx context.Context, model *User, builders ...*QueryBuilder) error
	// LoadAddresses loads the Addresses relation.
	LoadAddresses(ctx context.Context, model *User, builders ...*QueryBuilder) error
	// LoadPosts loads the Posts relation.
	LoadPosts(ctx context.Context, model *User, builders ...*QueryBuilder) error
	// LoadBatchDevice loads the Device relation.
	LoadBatchDevice(ctx context.Context, items []*User, builders ...*QueryBuilder) error
	// LoadBatchSettings loads the Settings relation.
	LoadBatchSettings(ctx context.Context, items []*User, builders ...*QueryBuilder) error
	// LoadBatchAddresses loads the Addresses relation.
	LoadBatchAddresses(ctx context.Context, items []*User, builders ...*QueryBuilder) error
	// LoadBatchPosts loads the Posts relation.
	LoadBatchPosts(ctx context.Context, items []*User, builders ...*QueryBuilder) error
}

// NewUserStorage returns a new userStorage.
func NewUserStorage(db *sql.DB) UserStorage {
	return &userStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// TableName returns the table name.
func (t *userStorage) TableName() string {
	return "users"
}

// Columns returns the columns for the table.
func (t *userStorage) Columns() []string {
	return []string{
		"id", "name", "age", "email", "last_name", "created_at", "updated_at", "notification_settings", "phones", "balls", "numrs", "comments",
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *userStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *userStorage) CreateTable(ctx context.Context) error {
	sqlQuery := `
		CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
		-- Table: users
		CREATE TABLE IF NOT EXISTS users (
		id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
		name TEXT NOT NULL,
		age INTEGER,
		email TEXT UNIQUE NOT NULL,
		last_name TEXT,
		created_at TIMESTAMP NOT NULL DEFAULT now(),
		updated_at TIMESTAMP,
		notification_settings JSONB,
		phones JSONB,
		balls JSONB,
		numrs JSONB,
		comments JSONB);
		COMMENT ON TABLE users IS 'This is a comment of User';
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// DropTable drops the table.
func (t *userStorage) DropTable(ctx context.Context) error {
	sqlQuery := `
		DROP TABLE IF EXISTS users;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *userStorage) TruncateTable(ctx context.Context) error {
	sqlQuery := `
		TRUNCATE TABLE users;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
// todo: delete this method
func (t *userStorage) UpgradeTable(ctx context.Context) error {
	return nil
}

// LoadDevice loads the Device relation.
func (t *userStorage) LoadDevice(ctx context.Context, model *User, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "User is nil")
	}

	// NewDeviceStorage creates a new DeviceStorage.
	s := NewDeviceStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(DeviceUserIdEq(model.Id)))
	relationModel, err := s.FindOne(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find DeviceStorage: %w", err)
	}

	model.Device = relationModel
	return nil
}

// LoadSettings loads the Settings relation.
func (t *userStorage) LoadSettings(ctx context.Context, model *User, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "User is nil")
	}

	// NewSettingStorage creates a new SettingStorage.
	s := NewSettingStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(SettingUserIdEq(model.Id)))
	relationModel, err := s.FindOne(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find SettingStorage: %w", err)
	}

	model.Settings = relationModel
	return nil
}

// LoadAddresses loads the Addresses relation.
func (t *userStorage) LoadAddresses(ctx context.Context, model *User, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "User is nil")
	}

	// NewAddressStorage creates a new AddressStorage.
	s := NewAddressStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(AddressUserIdEq(model.Id)))
	relationModels, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many AddressStorage: %w", err)
	}

	model.Addresses = relationModels
	return nil
}

// LoadPosts loads the Posts relation.
func (t *userStorage) LoadPosts(ctx context.Context, model *User, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "User is nil")
	}

	// NewPostStorage creates a new PostStorage.
	s := NewPostStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(PostAuthorIdEq(model.Id)))
	relationModels, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many PostStorage: %w", err)
	}

	model.Posts = relationModels
	return nil
}

// LoadBatchDevice loads the Device relation.
func (t *userStorage) LoadBatchDevice(ctx context.Context, items []*User, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.Id
	}

	// NewDeviceStorage creates a new DeviceStorage.
	s := NewDeviceStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(DeviceUserIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many DeviceStorage: %w", err)
	}

	// Assign Device to items
	// todo: optimize this, use map. Find way to get Device from items
	for _, item := range items {
		for _, result := range results {
			if item.Id == result.UserId {
				item.Device = result
			}
		}
	}

	return nil
}

// LoadBatchSettings loads the Settings relation.
func (t *userStorage) LoadBatchSettings(ctx context.Context, items []*User, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.Id
	}

	// NewSettingStorage creates a new SettingStorage.
	s := NewSettingStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(SettingUserIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many SettingStorage: %w", err)
	}

	// Assign Setting to items
	// todo: optimize this, use map. Find way to get Setting from items
	for _, item := range items {
		for _, result := range results {
			if item.Id == result.UserId {
				item.Settings = result
			}
		}
	}

	return nil
}

// LoadBatchAddresses loads the Addresses relation.
func (t *userStorage) LoadBatchAddresses(ctx context.Context, items []*User, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.Id
	}

	// NewAddressStorage creates a new AddressStorage.
	s := NewAddressStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(AddressUserIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many AddressStorage: %w", err)
	}

	// Assign Address to items
	// todo: optimize this, use map. Find way to get Address from items
	for _, item := range items {
		for _, result := range results {
			if item.Id == result.UserId {
				item.Addresses = append(item.Addresses, result)
			}
		}
	}

	return nil
}

// LoadBatchPosts loads the Posts relation.
func (t *userStorage) LoadBatchPosts(ctx context.Context, items []*User, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.Id
	}

	// NewPostStorage creates a new PostStorage.
	s := NewPostStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(PostAuthorIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many PostStorage: %w", err)
	}

	// Assign Post to items
	// todo: optimize this, use map. Find way to get Post from items
	for _, item := range items {
		for _, result := range results {
			if item.Id == result.AuthorId {
				item.Posts = append(item.Posts, result)
			}
		}
	}

	return nil
}

// User is a struct for the "users" table.
type User struct {
	Id                   string  `db:"id"`
	Name                 string  `db:"name"`
	Age                  int32   `db:"age"`
	Email                string  `db:"email"`
	LastName             *string `db:"last_name"`
	Device               *Device
	Settings             *Setting
	Addresses            []*Address
	Posts                []*Post
	CreatedAt            time.Time                `db:"created_at"`
	UpdatedAt            *time.Time               `db:"updated_at"`
	NotificationSettings *UserNotificationSetting `db:"notification_settings"`
	Phones               UserPhonesRepeated       `db:"phones"`
	Balls                UserBallsRepeated        `db:"balls"`
	Numrs                UserNumrsRepeated        `db:"numrs"`
	Comments             UserCommentsRepeated     `db:"comments"`
}

// ScanRow scans a row into a User.
func (t *User) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Name, &t.Age, &t.Email, &t.LastName, &t.CreatedAt, &t.UpdatedAt, &t.NotificationSettings, &t.Phones, &t.Balls, &t.Numrs, &t.Comments)
}

// ScanRow scans a single row into the User.
func (t *User) ScanRows(r *sql.Rows) error {
	return r.Scan(
		&t.Id,
		&t.Name,
		&t.Age,
		&t.Email,
		&t.LastName,
		&t.CreatedAt,
		&t.UpdatedAt,
		&t.NotificationSettings,
		&t.Phones,
		&t.Balls,
		&t.Numrs,
		&t.Comments,
	)
}

// Create creates a new User.
func (t *userStorage) Create(ctx context.Context, model *User, opts ...Option) (*string, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}
	// get value of phones
	phones, err := model.Phones.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get phones value: %w", err)
	}
	// get value of balls
	balls, err := model.Balls.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get balls value: %w", err)
	}
	// get value of numrs
	numrs, err := model.Numrs.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get numrs value: %w", err)
	}
	// get value of comments
	comments, err := model.Comments.Value()
	if err != nil {
		return nil, fmt.Errorf("failed to get comments value: %w", err)
	}

	query := t.queryBuilder.Insert("users").
		Columns(
			"name",
			"age",
			"email",
			"last_name",
			"created_at",
			"updated_at",
			"notification_settings",
			"phones",
			"balls",
			"numrs",
			"comments",
		).
		Values(
			model.Name,
			model.Age,
			model.Email,
			model.LastName,
			model.CreatedAt,
			model.UpdatedAt,
			model.NotificationSettings,
			phones,
			balls,
			numrs,
			comments,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id string
	err = t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create User: %w", err)
	}

	if options.relations && model.Device != nil {
		s := NewDeviceStorage(t.db)
		model.Device.UserId = id
		err := s.Create(ctx, model.Device)
		if err != nil {
			return nil, fmt.Errorf("failed to create Device: %w", err)
		}
	}
	if options.relations && model.Settings != nil {
		s := NewSettingStorage(t.db)
		model.Settings.UserId = id
		_, err := s.Create(ctx, model.Settings)
		if err != nil {
			return nil, fmt.Errorf("failed to create Settings: %w", err)
		}
	}
	if options.relations && model.Addresses != nil {
		for _, item := range model.Addresses {
			item.UserId = id
			s := NewAddressStorage(t.db)
			_, err := s.Create(ctx, item)
			if err != nil {
				return nil, fmt.Errorf("failed to create Addresses: %w", err)
			}
		}
	}

	return &id, nil
}

// UserUpdate is used to update an existing User.
type UserUpdate struct {
	Name                 *string
	Age                  *int32
	Email                *string
	LastName             *string
	CreatedAt            *time.Time
	UpdatedAt            *time.Time
	NotificationSettings *UserNotificationSetting
	Phones               *UserPhonesRepeated
	Balls                *UserBallsRepeated
	Numrs                *UserNumrsRepeated
	Comments             *UserCommentsRepeated
}

// Update updates an existing User based on non-nil fields.
func (t *userStorage) Update(ctx context.Context, id string, updateData *UserUpdate) error {
	if updateData == nil {
		return errors.New("update data is nil")
	}

	query := t.queryBuilder.Update("users")
	if updateData.Name != nil {
		query = query.Set("name", *updateData.Name)
	}
	if updateData.Age != nil {
		query = query.Set("age", *updateData.Age)
	}
	if updateData.Email != nil {
		query = query.Set("email", *updateData.Email)
	}
	if updateData.LastName != nil {
		query = query.Set("last_name", *updateData.LastName)
	}
	if updateData.CreatedAt != nil {
		query = query.Set("created_at", *updateData.CreatedAt)
	}
	if updateData.UpdatedAt != nil {
		query = query.Set("updated_at", *updateData.UpdatedAt)
	}
	if updateData.NotificationSettings != nil {
		query = query.Set("notification_settings", *updateData.NotificationSettings)
	}
	if updateData.Phones != nil {
		value, err := updateData.Phones.Value()
		if err != nil {
			return fmt.Errorf("failed to get phones value: %w", err)
		}
		query = query.Set("phones", value)
	}
	if updateData.Balls != nil {
		value, err := updateData.Balls.Value()
		if err != nil {
			return fmt.Errorf("failed to get balls value: %w", err)
		}
		query = query.Set("balls", value)
	}
	if updateData.Numrs != nil {
		value, err := updateData.Numrs.Value()
		if err != nil {
			return fmt.Errorf("failed to get numrs value: %w", err)
		}
		query = query.Set("numrs", value)
	}
	if updateData.Comments != nil {
		value, err := updateData.Comments.Value()
		if err != nil {
			return fmt.Errorf("failed to get comments value: %w", err)
		}
		query = query.Set("comments", value)
	}

	query = query.Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to update User: %w", err)
	}

	return nil
}

// Delete removes an existing User by its ID.
func (t *userStorage) DeleteById(ctx context.Context, id string, opts ...Option) error {
	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Delete("users").Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete User: %w", err)
	}

	return nil
}

// FindById retrieves a User by its id.
func (t *userStorage) FindById(ctx context.Context, id string, opts ...Option) (*User, error) {
	builder := NewQueryBuilder()
	{
		builder.WithFilter(UserIdEq(id))
		builder.WithOptions(opts...)
	}

	// Use FindOne to get a single result
	model, err := t.FindOne(ctx, builder)
	if err != nil {
		return nil, errors.Wrap(err, "find one User: ")
	}

	return model, nil
}

// findMany finds multiple User based on the provided options.
func (t *userStorage) FindMany(ctx context.Context, builders ...*QueryBuilder) ([]*User, error) {
	// build query
	query := t.queryBuilder.Select(t.Columns()...).From(t.TableName())

	// set default options
	options := &Options{}

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
		// apply pagination
		if builder.pagination != nil {
			if builder.pagination.limit != nil {
				query = query.Limit(*builder.pagination.limit)
			}
			if builder.pagination.offset != nil {
				query = query.Offset(*builder.pagination.offset)
			}
		}

		// apply options
		for _, o := range builder.options {
			o(options)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	rows, err := t.DB(ctx).QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to find User: %w", err)
	}
	defer rows.Close()

	var results []*User
	for rows.Next() {
		model := &User{}
		if err := model.ScanRows(rows); err != nil {
			return nil, fmt.Errorf("failed to scan User: %w", err)
		}
		results = append(results, model)
	}

	return results, nil
}

// findOne finds a single User based on the provided options.
func (t *userStorage) FindOne(ctx context.Context, builders ...*QueryBuilder) (*User, error) {
	// Use findMany but limit the results to 1
	builders = append(builders, LimitBuilder(1))
	results, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, ErrRowNotFound
	}

	return results[0], nil
}

// Count counts User based on the provided options.
func (t *userStorage) Count(ctx context.Context, builders ...*QueryBuilder) (int64, error) {
	// build query
	query := t.queryBuilder.Select("COUNT(*)").From(t.TableName())

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build query: %w", err)
	}

	row := t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("failed to count User: %w", err)
	}

	return count, nil
}

// FindManyWithPagination finds multiple User with pagination support.
func (t *userStorage) FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*User, *Paginator, error) {
	// Count the total number of records
	totalCount, err := t.Count(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to count User: %w", err)
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Build the pagination object
	paginator := &Paginator{
		TotalCount: totalCount,
		Limit:      limit,
		Page:       page,
		TotalPages: int(math.Ceil(float64(totalCount) / float64(limit))),
	}

	// Add pagination to query builder
	builders = append(builders, PaginateBuilder(uint64(limit), uint64(offset)))

	// Find records using FindMany
	records, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to find User: %w", err)
	}

	return records, paginator, nil
}

// settingStorage is a struct for the "settings" table.
type settingStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type SettingStorage interface {
	// CreateTable creates the table.
	CreateTable(ctx context.Context) error
	// DropTable drops the table.
	DropTable(ctx context.Context) error
	// TruncateTable truncates the table.
	TruncateTable(ctx context.Context) error
	// UpgradeTable upgrades the table.
	UpgradeTable(ctx context.Context) error
	// Create creates a new Setting.
	Create(ctx context.Context, model *Setting, opts ...Option) (*int32, error)
	// Update updates an existing Setting.
	Update(ctx context.Context, id int32, updateData *SettingUpdate) error
	// Delete removes an existing Setting by its ID.
	DeleteById(ctx context.Context, id int32, opts ...Option) error
	// FindById retrieves a Setting by its id.
	FindById(ctx context.Context, id int32, opts ...Option) (*Setting, error)
	// FindMany finds multiple Setting based on the provided options.
	FindMany(ctx context.Context, builder ...*QueryBuilder) ([]*Setting, error)
	// FindOne finds a single Setting based on the provided options.
	FindOne(ctx context.Context, builders ...*QueryBuilder) (*Setting, error)
	// Count counts Setting based on the provided options.
	Count(ctx context.Context, builders ...*QueryBuilder) (int64, error)
	// FindManyWithPagination finds multiple Setting with pagination support.
	FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Setting, *Paginator, error)

	//
	// Lazy load relations methods
	//
	// LoadUser loads the User relation.
	LoadUser(ctx context.Context, model *Setting, builders ...*QueryBuilder) error
	// LoadBatchUser loads the User relation.
	LoadBatchUser(ctx context.Context, items []*Setting, builders ...*QueryBuilder) error
}

// NewSettingStorage returns a new settingStorage.
func NewSettingStorage(db *sql.DB) SettingStorage {
	return &settingStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// TableName returns the table name.
func (t *settingStorage) TableName() string {
	return "settings"
}

// Columns returns the columns for the table.
func (t *settingStorage) Columns() []string {
	return []string{
		"id", "name", "value", "user_id",
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *settingStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *settingStorage) CreateTable(ctx context.Context) error {
	sqlQuery := `
		-- Table: settings
		CREATE TABLE IF NOT EXISTS settings (
		id  SERIAL PRIMARY KEY,
		name TEXT NOT NULL,
		value TEXT,
		user_id UUID NOT NULL);
		
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// DropTable drops the table.
func (t *settingStorage) DropTable(ctx context.Context) error {
	sqlQuery := `
		DROP TABLE IF EXISTS settings;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *settingStorage) TruncateTable(ctx context.Context) error {
	sqlQuery := `
		TRUNCATE TABLE settings;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
// todo: delete this method
func (t *settingStorage) UpgradeTable(ctx context.Context) error {
	return nil
}

// LoadUser loads the User relation.
func (t *settingStorage) LoadUser(ctx context.Context, model *Setting, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "Setting is nil")
	}

	// NewUserStorage creates a new UserStorage.
	s := NewUserStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(UserIdEq(model.UserId)))
	relationModel, err := s.FindOne(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find UserStorage: %w", err)
	}

	model.User = relationModel
	return nil
}

// LoadBatchUser loads the User relation.
func (t *settingStorage) LoadBatchUser(ctx context.Context, items []*Setting, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.UserId
	}

	// NewUserStorage creates a new UserStorage.
	s := NewUserStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(UserIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many UserStorage: %w", err)
	}

	// Assign User to items
	// todo: optimize this, use map. Find way to get User from items
	for _, item := range items {
		for _, result := range results {
			if item.UserId == result.Id {
				item.User = result
			}
		}
	}

	return nil
}

// Setting is a struct for the "settings" table.
type Setting struct {
	Id     int32  `db:"id"`
	Name   string `db:"name"`
	Value  string `db:"value"`
	User   *User
	UserId string `db:"user_id"`
}

// ScanRow scans a row into a Setting.
func (t *Setting) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Name, &t.Value, &t.UserId)
}

// ScanRow scans a single row into the Setting.
func (t *Setting) ScanRows(r *sql.Rows) error {
	return r.Scan(
		&t.Id,
		&t.Name,
		&t.Value,
		&t.UserId,
	)
}

// Create creates a new Setting.
func (t *settingStorage) Create(ctx context.Context, model *Setting, opts ...Option) (*int32, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Insert("settings").
		Columns(
			"name",
			"value",
			"user_id",
		).
		Values(
			model.Name,
			model.Value,
			model.UserId,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id int32
	err = t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create Setting: %w", err)
	}

	return &id, nil
}

// SettingUpdate is used to update an existing Setting.
type SettingUpdate struct {
	Name   *string
	Value  *string
	UserId *string
}

// Update updates an existing Setting based on non-nil fields.
func (t *settingStorage) Update(ctx context.Context, id int32, updateData *SettingUpdate) error {
	if updateData == nil {
		return errors.New("update data is nil")
	}

	query := t.queryBuilder.Update("settings")
	if updateData.Name != nil {
		query = query.Set("name", *updateData.Name)
	}
	if updateData.Value != nil {
		query = query.Set("value", *updateData.Value)
	}
	if updateData.UserId != nil {
		query = query.Set("user_id", *updateData.UserId)
	}

	query = query.Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to update Setting: %w", err)
	}

	return nil
}

// Delete removes an existing Setting by its ID.
func (t *settingStorage) DeleteById(ctx context.Context, id int32, opts ...Option) error {
	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Delete("settings").Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete Setting: %w", err)
	}

	return nil
}

// FindById retrieves a Setting by its id.
func (t *settingStorage) FindById(ctx context.Context, id int32, opts ...Option) (*Setting, error) {
	builder := NewQueryBuilder()
	{
		builder.WithFilter(SettingIdEq(id))
		builder.WithOptions(opts...)
	}

	// Use FindOne to get a single result
	model, err := t.FindOne(ctx, builder)
	if err != nil {
		return nil, errors.Wrap(err, "find one Setting: ")
	}

	return model, nil
}

// findMany finds multiple Setting based on the provided options.
func (t *settingStorage) FindMany(ctx context.Context, builders ...*QueryBuilder) ([]*Setting, error) {
	// build query
	query := t.queryBuilder.Select(t.Columns()...).From(t.TableName())

	// set default options
	options := &Options{}

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
		// apply pagination
		if builder.pagination != nil {
			if builder.pagination.limit != nil {
				query = query.Limit(*builder.pagination.limit)
			}
			if builder.pagination.offset != nil {
				query = query.Offset(*builder.pagination.offset)
			}
		}

		// apply options
		for _, o := range builder.options {
			o(options)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	rows, err := t.DB(ctx).QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to find Setting: %w", err)
	}
	defer rows.Close()

	var results []*Setting
	for rows.Next() {
		model := &Setting{}
		if err := model.ScanRows(rows); err != nil {
			return nil, fmt.Errorf("failed to scan Setting: %w", err)
		}
		results = append(results, model)
	}

	return results, nil
}

// findOne finds a single Setting based on the provided options.
func (t *settingStorage) FindOne(ctx context.Context, builders ...*QueryBuilder) (*Setting, error) {
	// Use findMany but limit the results to 1
	builders = append(builders, LimitBuilder(1))
	results, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, ErrRowNotFound
	}

	return results[0], nil
}

// Count counts Setting based on the provided options.
func (t *settingStorage) Count(ctx context.Context, builders ...*QueryBuilder) (int64, error) {
	// build query
	query := t.queryBuilder.Select("COUNT(*)").From(t.TableName())

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build query: %w", err)
	}

	row := t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("failed to count Setting: %w", err)
	}

	return count, nil
}

// FindManyWithPagination finds multiple Setting with pagination support.
func (t *settingStorage) FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Setting, *Paginator, error) {
	// Count the total number of records
	totalCount, err := t.Count(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to count Setting: %w", err)
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Build the pagination object
	paginator := &Paginator{
		TotalCount: totalCount,
		Limit:      limit,
		Page:       page,
		TotalPages: int(math.Ceil(float64(totalCount) / float64(limit))),
	}

	// Add pagination to query builder
	builders = append(builders, PaginateBuilder(uint64(limit), uint64(offset)))

	// Find records using FindMany
	records, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to find Setting: %w", err)
	}

	return records, paginator, nil
}

// addressStorage is a struct for the "addresses" table.
type addressStorage struct {
	db           *sql.DB                 // The database connection.
	queryBuilder sq.StatementBuilderType // queryBuilder is used to build queries.
}

type AddressStorage interface {
	// CreateTable creates the table.
	CreateTable(ctx context.Context) error
	// DropTable drops the table.
	DropTable(ctx context.Context) error
	// TruncateTable truncates the table.
	TruncateTable(ctx context.Context) error
	// UpgradeTable upgrades the table.
	UpgradeTable(ctx context.Context) error
	// Create creates a new Address.
	Create(ctx context.Context, model *Address, opts ...Option) (*string, error)
	// Update updates an existing Address.
	Update(ctx context.Context, id string, updateData *AddressUpdate) error
	// Delete removes an existing Address by its ID.
	DeleteById(ctx context.Context, id string, opts ...Option) error
	// FindById retrieves a Address by its id.
	FindById(ctx context.Context, id string, opts ...Option) (*Address, error)
	// FindMany finds multiple Address based on the provided options.
	FindMany(ctx context.Context, builder ...*QueryBuilder) ([]*Address, error)
	// FindOne finds a single Address based on the provided options.
	FindOne(ctx context.Context, builders ...*QueryBuilder) (*Address, error)
	// Count counts Address based on the provided options.
	Count(ctx context.Context, builders ...*QueryBuilder) (int64, error)
	// FindManyWithPagination finds multiple Address with pagination support.
	FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Address, *Paginator, error)

	//
	// Lazy load relations methods
	//
	// LoadUser loads the User relation.
	LoadUser(ctx context.Context, model *Address, builders ...*QueryBuilder) error
	// LoadBatchUser loads the User relation.
	LoadBatchUser(ctx context.Context, items []*Address, builders ...*QueryBuilder) error
}

// NewAddressStorage returns a new addressStorage.
func NewAddressStorage(db *sql.DB) AddressStorage {
	return &addressStorage{
		db:           db,
		queryBuilder: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
	}
}

// TableName returns the table name.
func (t *addressStorage) TableName() string {
	return "addresses"
}

// Columns returns the columns for the table.
func (t *addressStorage) Columns() []string {
	return []string{
		"id", "street", "city", "state", "zip", "user_id", "created_at", "updated_at",
	}
}

// DB returns the underlying sql.DB. This is useful for doing transactions.
func (t *addressStorage) DB(ctx context.Context) QueryExecer {
	var db QueryExecer = t.db
	if tx, ok := TxFromContext(ctx); ok {
		db = tx
	}

	return db
}

// createTable creates the table.
func (t *addressStorage) CreateTable(ctx context.Context) error {
	sqlQuery := `
		CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
		-- Table: addresses
		CREATE TABLE IF NOT EXISTS addresses (
		id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
		street TEXT,
		city TEXT NOT NULL,
		state INTEGER,
		zip BIGINT,
		user_id UUID NOT NULL,
		created_at TIMESTAMP NOT NULL DEFAULT now(),
		updated_at TIMESTAMP);
		
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// DropTable drops the table.
func (t *addressStorage) DropTable(ctx context.Context) error {
	sqlQuery := `
		DROP TABLE IF EXISTS addresses;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// TruncateTable truncates the table.
func (t *addressStorage) TruncateTable(ctx context.Context) error {
	sqlQuery := `
		TRUNCATE TABLE addresses;
	`

	_, err := t.db.ExecContext(ctx, sqlQuery)
	return err
}

// UpgradeTable upgrades the table.
// todo: delete this method
func (t *addressStorage) UpgradeTable(ctx context.Context) error {
	return nil
}

// LoadUser loads the User relation.
func (t *addressStorage) LoadUser(ctx context.Context, model *Address, builders ...*QueryBuilder) error {
	if model == nil {
		return errors.Wrap(ErrModelIsNil, "Address is nil")
	}

	// NewUserStorage creates a new UserStorage.
	s := NewUserStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(UserIdEq(model.UserId)))
	relationModel, err := s.FindOne(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find UserStorage: %w", err)
	}

	model.User = relationModel
	return nil
}

// LoadBatchUser loads the User relation.
func (t *addressStorage) LoadBatchUser(ctx context.Context, items []*Address, builders ...*QueryBuilder) error {
	requestItems := make([]interface{}, len(items))
	for i, item := range items {
		requestItems[i] = item.UserId
	}

	// NewUserStorage creates a new UserStorage.
	s := NewUserStorage(t.db)

	// Add the filter for the relation
	builders = append(builders, FilterBuilder(UserIdIn(requestItems...)))

	results, err := s.FindMany(ctx, builders...)
	if err != nil {
		return fmt.Errorf("failed to find many UserStorage: %w", err)
	}

	// Assign User to items
	// todo: optimize this, use map. Find way to get User from items
	for _, item := range items {
		for _, result := range results {
			if item.UserId == result.Id {
				item.User = result
			}
		}
	}

	return nil
}

// Address is a struct for the "addresses" table.
type Address struct {
	Id        string `db:"id"`
	Street    string `db:"street"`
	City      string `db:"city"`
	State     int32  `db:"state"`
	Zip       int64  `db:"zip"`
	User      *User
	UserId    string     `db:"user_id"`
	CreatedAt time.Time  `db:"created_at"`
	UpdatedAt *time.Time `db:"updated_at"`
}

// ScanRow scans a row into a Address.
func (t *Address) ScanRow(r *sql.Row) error {
	return r.Scan(&t.Id, &t.Street, &t.City, &t.State, &t.Zip, &t.UserId, &t.CreatedAt, &t.UpdatedAt)
}

// ScanRow scans a single row into the Address.
func (t *Address) ScanRows(r *sql.Rows) error {
	return r.Scan(
		&t.Id,
		&t.Street,
		&t.City,
		&t.State,
		&t.Zip,
		&t.UserId,
		&t.CreatedAt,
		&t.UpdatedAt,
	)
}

// Create creates a new Address.
func (t *addressStorage) Create(ctx context.Context, model *Address, opts ...Option) (*string, error) {
	if model == nil {
		return nil, errors.New("model is nil")
	}

	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Insert("addresses").
		Columns(
			"street",
			"city",
			"state",
			"zip",
			"user_id",
			"created_at",
			"updated_at",
		).
		Values(
			model.Street,
			model.City,
			model.State,
			model.Zip,
			model.UserId,
			model.CreatedAt,
			model.UpdatedAt,
		)

	// add RETURNING "id" to query
	query = query.Suffix("RETURNING \"id\"")

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	var id string
	err = t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...).Scan(&id)
	if err != nil {
		if IsPgUniqueViolation(err) {
			return nil, errors.Wrap(ErrRowAlreadyExist, PgPrettyErr(err).Error())
		}

		return nil, fmt.Errorf("failed to create Address: %w", err)
	}

	return &id, nil
}

// AddressUpdate is used to update an existing Address.
type AddressUpdate struct {
	Street    *string
	City      *string
	State     *int32
	Zip       *int64
	UserId    *string
	CreatedAt *time.Time
	UpdatedAt *time.Time
}

// Update updates an existing Address based on non-nil fields.
func (t *addressStorage) Update(ctx context.Context, id string, updateData *AddressUpdate) error {
	if updateData == nil {
		return errors.New("update data is nil")
	}

	query := t.queryBuilder.Update("addresses")
	if updateData.Street != nil {
		query = query.Set("street", *updateData.Street)
	}
	if updateData.City != nil {
		query = query.Set("city", *updateData.City)
	}
	if updateData.State != nil {
		query = query.Set("state", *updateData.State)
	}
	if updateData.Zip != nil {
		query = query.Set("zip", *updateData.Zip)
	}
	if updateData.UserId != nil {
		query = query.Set("user_id", *updateData.UserId)
	}
	if updateData.CreatedAt != nil {
		query = query.Set("created_at", *updateData.CreatedAt)
	}
	if updateData.UpdatedAt != nil {
		query = query.Set("updated_at", *updateData.UpdatedAt)
	}

	query = query.Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to update Address: %w", err)
	}

	return nil
}

// Delete removes an existing Address by its ID.
func (t *addressStorage) DeleteById(ctx context.Context, id string, opts ...Option) error {
	// set default options
	options := &Options{}
	for _, o := range opts {
		o(options)
	}

	query := t.queryBuilder.Delete("addresses").Where("id = ?", id)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build query: %w", err)
	}

	_, err = t.DB(ctx).ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return fmt.Errorf("failed to delete Address: %w", err)
	}

	return nil
}

// FindById retrieves a Address by its id.
func (t *addressStorage) FindById(ctx context.Context, id string, opts ...Option) (*Address, error) {
	builder := NewQueryBuilder()
	{
		builder.WithFilter(AddressIdEq(id))
		builder.WithOptions(opts...)
	}

	// Use FindOne to get a single result
	model, err := t.FindOne(ctx, builder)
	if err != nil {
		return nil, errors.Wrap(err, "find one Address: ")
	}

	return model, nil
}

// findMany finds multiple Address based on the provided options.
func (t *addressStorage) FindMany(ctx context.Context, builders ...*QueryBuilder) ([]*Address, error) {
	// build query
	query := t.queryBuilder.Select(t.Columns()...).From(t.TableName())

	// set default options
	options := &Options{}

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
		// apply pagination
		if builder.pagination != nil {
			if builder.pagination.limit != nil {
				query = query.Limit(*builder.pagination.limit)
			}
			if builder.pagination.offset != nil {
				query = query.Offset(*builder.pagination.offset)
			}
		}

		// apply options
		for _, o := range builder.options {
			o(options)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to build query: %w", err)
	}

	rows, err := t.DB(ctx).QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to find Address: %w", err)
	}
	defer rows.Close()

	var results []*Address
	for rows.Next() {
		model := &Address{}
		if err := model.ScanRows(rows); err != nil {
			return nil, fmt.Errorf("failed to scan Address: %w", err)
		}
		results = append(results, model)
	}

	return results, nil
}

// findOne finds a single Address based on the provided options.
func (t *addressStorage) FindOne(ctx context.Context, builders ...*QueryBuilder) (*Address, error) {
	// Use findMany but limit the results to 1
	builders = append(builders, LimitBuilder(1))
	results, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, err
	}

	if len(results) == 0 {
		return nil, ErrRowNotFound
	}

	return results[0], nil
}

// Count counts Address based on the provided options.
func (t *addressStorage) Count(ctx context.Context, builders ...*QueryBuilder) (int64, error) {
	// build query
	query := t.queryBuilder.Select("COUNT(*)").From(t.TableName())

	// apply options from builder
	for _, builder := range builders {
		if builder == nil {
			continue
		}

		// apply filter options
		for _, option := range builder.filterOptions {
			query = option.Apply(query)
		}
	}

	// execute query
	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to build query: %w", err)
	}

	row := t.DB(ctx).QueryRowContext(ctx, sqlQuery, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("failed to count Address: %w", err)
	}

	return count, nil
}

// FindManyWithPagination finds multiple Address with pagination support.
func (t *addressStorage) FindManyWithPagination(ctx context.Context, limit int, page int, builders ...*QueryBuilder) ([]*Address, *Paginator, error) {
	// Count the total number of records
	totalCount, err := t.Count(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to count Address: %w", err)
	}

	// Calculate offset
	offset := (page - 1) * limit

	// Build the pagination object
	paginator := &Paginator{
		TotalCount: totalCount,
		Limit:      limit,
		Page:       page,
		TotalPages: int(math.Ceil(float64(totalCount) / float64(limit))),
	}

	// Add pagination to query builder
	builders = append(builders, PaginateBuilder(uint64(limit), uint64(offset)))

	// Find records using FindMany
	records, err := t.FindMany(ctx, builders...)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to find Address: %w", err)
	}

	return records, paginator, nil
}
